<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一汀烟雨杏花寒</title>
  <icon>https://www.gravatar.com/avatar/0ea669b5e2b58cee0067c243e72e6c1d</icon>
  <subtitle>no error, no warning。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://geoffen.github.io/"/>
  <updated>2019-11-14T06:39:24.171Z</updated>
  <id>http://geoffen.github.io/</id>
  
  <author>
    <name>Frank</name>
    <email>foreverlovemichael@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 Kubernetes 上搭建 EFK 日志收集系统</title>
    <link href="http://geoffen.github.io/2019/11/06/%E5%9C%A8Kubernetes%E4%B8%8A%E6%90%AD%E5%BB%BAEFK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://geoffen.github.io/2019/11/06/在Kubernetes上搭建EFK日志收集系统/</id>
    <published>2019-11-06T10:54:02.000Z</published>
    <updated>2019-11-14T06:39:24.171Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes 中比较流行的日志收集解决方案是 <code>Elasticsearch</code>、<code>Fluentd</code> 和 <code>Kibana</code>（EFK）技术栈，也是官方现在比较推荐的一种方案。</p><p><code>Elasticsearch</code> 是一个实时的、分布式的可扩展的搜索引擎，允许进行全文、结构化搜索，它通常用于索引和搜索大量日志数据，也可用于搜索许多不同类型的文档。</p><a id="more"></a><p>Elasticsearch 通常与 <code>Kibana</code> 一起部署，Kibana 是 Elasticsearch 的一个功能强大的数据可视化 Dashboard，Kibana 允许你通过 web 界面来浏览 Elasticsearch 日志数据。</p><p><code>Fluentd</code>是一个流行的开源数据收集器，我们将在 Kubernetes 集群节点上安装 Fluentd，通过获取容器日志文件、过滤和转换日志数据，然后将数据传递到 Elasticsearch 集群，在该集群中对其进行索引和存储。</p><p>我们先来配置启动一个可扩展的 Elasticsearch 集群，然后在 Kubernetes 集群中创建一个 Kibana 应用，最后通过 DaemonSet 来运行 Fluentd，以便它在每个 Kubernetes 工作节点上都可以运行一个 Pod。</p><p><img src="/2019/11/06/%E5%9C%A8Kubernetes%E4%B8%8A%E6%90%AD%E5%BB%BAEFK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F/20180511161547422" alt="img"></p><h2 id="部署nfs-client"><a href="#部署nfs-client" class="headerlink" title="部署nfs-client"></a>部署nfs-client</h2><h3 id="创建-Provisioner"><a href="#创建-Provisioner" class="headerlink" title="创建 Provisioner"></a>创建 Provisioner</h3><p>要使用 StorageClass，我们就得安装对应的自动配置程序，比如我们这里存储后端使用的是 nfs，那么我们就需要使用到一个 nfs-client 的自动配置程序，我们也叫它 Provisioner，这个程序使用我们已经配置好的 nfs 服务器，来自动创建持久卷，也就是自动帮我们创建 PV。</p><ul><li>自动创建的 PV 以<code>${namespace}-${pvcName}-${pvName}</code>这样的命名格式创建在 NFS 服务器上的共享数据目录中</li><li>而当这个 PV 被回收后会以<code>archieved-${namespace}-${pvcName}-${pvName}</code>这样的命名格式存在 NFS 服务器上。</li></ul><p>当然在部署<code>nfs-client</code>之前，我们需要先成功安装上 nfs 服务器，前面的课程中我们已经过了，服务地址是<strong>10.151.30.57</strong>，共享数据目录是<strong>/data/k8s/</strong>，然后接下来我们部署 nfs-client 即可，我们也可以直接参考<a href="https://github.com/kubernetes-incubator/external-storage/tree/master/nfs-client" target="_blank" rel="noopener">nfs-client 的文档</a>，进行安装即可。</p><p><strong>第一步</strong>：配置 Deployment，将里面的对应的参数替换成我们自己的 nfs 配置（nfs-client.yaml）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Recreate</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      serviceAccountName:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">quay.io/external_storage/nfs-client-provisioner:latest</span></span><br><span class="line"><span class="attr">          volumeMounts:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">nfs-client-root</span></span><br><span class="line"><span class="attr">              mountPath:</span> <span class="string">/persistentvolumes</span></span><br><span class="line"><span class="attr">          env:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">PROVISIONER_NAME</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">fuseim.pri/ifs</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">NFS_SERVER</span></span><br><span class="line"><span class="attr">              value:</span> <span class="number">10.151</span><span class="number">.30</span><span class="number">.57</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">NFS_PATH</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">/data/k8s</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">nfs-client-root</span></span><br><span class="line"><span class="attr">          nfs:</span></span><br><span class="line"><span class="attr">            server:</span> <span class="number">10.151</span><span class="number">.30</span><span class="number">.57</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/data/k8s</span></span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：将环境变量 NFS_SERVER 和 NFS_PATH 替换，当然也包括下面的 nfs 配置，我们可以看到我们这里使用了一个名为 nfs-client-provisioner 的<code>serviceAccount</code>，所以我们也需要创建一个 sa，然后绑定上对应的权限：（nfs-client-sa.yaml）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="attr">  - apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">    resources:</span> <span class="string">["persistentvolumes"]</span></span><br><span class="line"><span class="attr">    verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"create"</span><span class="string">,</span> <span class="string">"delete"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  - apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">    resources:</span> <span class="string">["persistentvolumeclaims"]</span></span><br><span class="line"><span class="attr">    verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"update"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  - apiGroups:</span> <span class="string">["storage.k8s.io"]</span></span><br><span class="line"><span class="attr">    resources:</span> <span class="string">["storageclasses"]</span></span><br><span class="line"><span class="attr">    verbs:</span> <span class="string">["get",</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  - apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">    resources:</span> <span class="string">["events"]</span></span><br><span class="line"><span class="attr">    verbs:</span> <span class="string">["list",</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"create"</span><span class="string">,</span> <span class="string">"update"</span><span class="string">,</span> <span class="string">"patch"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  - apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">    resources:</span> <span class="string">["endpoints"]</span></span><br><span class="line"><span class="attr">    verbs:</span> <span class="string">["create",</span> <span class="string">"delete"</span><span class="string">,</span> <span class="string">"get"</span><span class="string">,</span> <span class="string">"list"</span><span class="string">,</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"patch"</span><span class="string">,</span> <span class="string">"update"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">run-nfs-client-provisioner</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">  - kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line"><span class="attr">    namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>我们这里新建的一个名为 nfs-client-provisioner 的<code>ServiceAccount</code>，然后绑定了一个名为 nfs-client-provisioner-runner 的<code>ClusterRole</code>，而该<code>ClusterRole</code>声明了一些权限，其中就包括对<code>persistentvolumes</code>的增、删、改、查等权限，所以我们可以利用该<code>ServiceAccount</code>来自动创建 PV。</p><p><strong>第三步</strong>：nfs-client 的 Deployment 声明完成后，我们就可以来创建一个<code>StorageClass</code>对象了：（nfs-client-class.yaml）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">course-nfs-storage</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">fuseim.pri/ifs</span> <span class="comment"># or choose another name, must match deployment's env PROVISIONER_NAME'</span></span><br></pre></td></tr></table></figure><p>我们声明了一个名为 course-nfs-storage 的<code>StorageClass</code>对象，注意下面的<code>provisioner</code>对应的值一定要和上面的<code>Deployment</code>下面的 PROVISIONER_NAME 这个环境变量的值一样。</p><p>现在我们来创建这些资源对象吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f nfs-client.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f nfs-client-sa.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f nfs-client-class.yaml</span></span><br></pre></td></tr></table></figure><p>创建完成后查看下资源状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME                                             READY     STATUS             RESTARTS   AGE</span><br><span class="line">...</span><br><span class="line">nfs-client-provisioner-7648b664bc-7f9pk          1/1       Running            0          7h</span><br><span class="line">...</span><br><span class="line">$ kubectl get storageclass</span><br><span class="line">NAME                 PROVISIONER      AGE</span><br><span class="line">course-nfs-storage   fuseim.pri/ifs   11s</span><br></pre></td></tr></table></figure><h3 id="新建-PVC"><a href="#新建-PVC" class="headerlink" title="新建 PVC"></a>新建 PVC</h3><p>上面把<code>StorageClass</code>资源对象创建成功了，接下来我们来通过一个示例测试下动态 PV，首先创建一个 PVC 对象：(test-pvc.yaml)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteMany</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">1</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure><p>我们这里声明了一个<code>PVC</code>对象，采用 <code>ReadWriteMany</code> 的访问模式，请求 1Mi 的空间，但是我们可以看到上面的 PVC 文件我们没有标识出任何和 StorageClass 相关联的信息，那么如果我们现在直接创建这个 PVC 对象能够自动绑定上合适的 PV 对象吗？显然是不能的(前提是没有合适的 PV)，我们这里有两种方法可以来利用上面我们创建的 StorageClass 对象来自动帮我们创建一个合适的 PV:</p><ul><li>第一种方法：在这个<code>PVC</code>对象中添加一个声明<code>StorageClass</code>对象的标识，这里我们可以利用一个<code>annotations</code>属性来标识，如下</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-pvc</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">volume.beta.kubernetes.io/storage-class:</span> <span class="string">"course-nfs-storage"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteMany</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">1</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure><ul><li><p>第二种方法：我们可以设置这个 course-nfs-storage 的 StorageClass 为 Kubernetes 的默认存储后端，我们可以用<code>kubectl patch</code>命令来更新：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">patch</span> <span class="string">storageclass</span> <span class="string">course-nfs-storage</span> <span class="bullet">-p</span> <span class="string">'&#123;"metadata": &#123;"annotations":&#123;"storageclass.kubernetes.io/is-default-class":"true"&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure><p>上面这两种方法都是可以的，当然为了不影响系统的默认行为，我们这里还是采用第一种方法，直接创建即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">create</span> <span class="bullet">-f</span> <span class="string">test-pvc.yaml</span></span><br><span class="line"><span class="string">persistentvolumeclaim</span> <span class="string">"test-pvc"</span> <span class="string">created</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">pvc</span></span><br><span class="line"><span class="string">NAME</span>         <span class="string">STATUS</span>    <span class="string">VOLUME</span>                                     <span class="string">CAPACITY</span>   <span class="string">ACCESS</span> <span class="string">MODES</span>   <span class="string">STORAGECLASS</span>          <span class="string">AGE</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">test-pvc</span>     <span class="string">Bound</span>     <span class="string">pvc-73b5ffd2-8b4b-11e8-b585-525400db4df7</span>   <span class="number">1</span><span class="string">Mi</span>        <span class="string">RWX</span>            <span class="string">course-nfs-storage</span>    <span class="number">2</span><span class="string">m</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></li></ul><p>我们可以看到一个名为 test-pvc 的 PVC 对象创建成功了，状态已经是<code>Bound</code>了，是不是也产生了一个对应的<code>VOLUME</code> 对象，最重要的一栏是<code>STORAGECLASS</code>，现在是不是也有值了，就是我们刚刚创建的<code>StorageClass</code>对象 course-nfs-storage。</p><p>然后查看下 PV 对象呢：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pv</span></span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                STORAGECLASS          REASON    AGE</span><br><span class="line">...</span><br><span class="line">pvc-73b5ffd2-8b4b-11e8-b585-525400db4df7   1Mi        RWX            Delete           Bound       default/test-pvc     course-nfs-storage              8m</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到是不是自动生成了一个关联的 PV 对象，访问模式是<code>RWX</code>，回收策略是 <code>Delete</code>，这个 PV 对象并不是我们手动创建的吧，这是通过我们上面的 <code>StorageClass</code> 对象自动创建的。这就是 StorageClass 的创建方法。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>接下来我们还是用一个简单的示例来测试下我们上面用 StorageClass 方式声明的 PVC 对象吧：(test-pod.yaml)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"/bin/sh"</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"-c"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"touch /mnt/SUCCESS &amp;&amp; exit 0 || exit 1"</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nfs-pvc</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">"/mnt"</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">"Never"</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nfs-pvc</span></span><br><span class="line"><span class="attr">    persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">      claimName:</span> <span class="string">test-pvc</span></span><br></pre></td></tr></table></figure><p>上面这个 Pod 非常简单，就是用一个 <strong>busybox</strong> 容器，在 /mnt 目录下面新建一个 SUCCESS 的文件，然后把 /mnt 目录挂载到上面我们新建的 test-pvc 这个资源对象上面了，要验证很简单，只需要去查看下我们 nfs 服务器上面的共享数据目录下面是否有 SUCCESS 这个文件即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f <span class="built_in">test</span>-pod.yaml</span></span><br><span class="line">pod "test-pod" created</span><br></pre></td></tr></table></figure><p>然后我们可以在 nfs 服务器的共享数据目录下面查看下数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /data/k8s/</span></span><br><span class="line">default-test-pvc-pvc-73b5ffd2-8b4b-11e8-b585-525400db4df7</span><br></pre></td></tr></table></figure><p>我们可以看到下面有名字很长的文件夹，这个文件夹的命名方式是不是和我们上面的规则：<strong>${namespace}-${pvcName}-${pvName}</strong>是一样的，再看下这个文件夹下面是否有其他文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /data/k8s/default-test-pvc-pvc-73b5ffd2-8b4b-11e8-b585-525400db4df7</span></span><br><span class="line">SUCCESS</span><br></pre></td></tr></table></figure><p>我们看到下面有一个 SUCCESS 的文件，是不是就证明我们上面的验证是成功的啊。</p><p>另外我们可以看到我们这里是手动创建的一个 PVC 对象，在实际工作中，使用 StorageClass 更多的是 StatefulSet 类型的服务，<code>StatefulSet</code>类型的服务我们也可以通过一个<code>volumeClaimTemplates</code>属性来直接使用 StorageClass，如下：(test-statefulset-nfs.yaml)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nfs-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">"nginx"</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nfs-web</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">www</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">  volumeClaimTemplates:</span></span><br><span class="line"><span class="attr">  - metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">www</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">volume.beta.kubernetes.io/storage-class:</span> <span class="string">course-nfs-storage</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      accessModes:</span> <span class="string">[</span> <span class="string">"ReadWriteOnce"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        requests:</span></span><br><span class="line"><span class="attr">          storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure><p>实际上 volumeClaimTemplates 下面就是一个 PVC 对象的模板，就类似于我们这里 StatefulSet 下面的 template，实际上就是一个 Pod 的模板，我们不单独创建成 PVC 对象，而用这种模板就可以动态的去创建了对象了，这种方式在 StatefulSet 类型的服务下面使用得非常多。</p><p>直接创建上面的对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f <span class="built_in">test</span>-statefulset-nfs.yaml</span></span><br><span class="line">statefulset.apps "nfs-web" created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                                             READY     STATUS              RESTARTS   AGE</span><br><span class="line">...</span><br><span class="line">nfs-web-0                                        1/1       Running             0          1m</span><br><span class="line">nfs-web-1                                        1/1       Running             0          1m</span><br><span class="line">nfs-web-2                                        1/1       Running             0          33s</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>创建完成后可以看到上面的3个 Pod 已经运行成功，然后查看下 PVC 对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pvc</span></span><br><span class="line">NAME            STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS          AGE</span><br><span class="line">...</span><br><span class="line">www-nfs-web-0   Bound     pvc-cc36b3ce-8b50-11e8-b585-525400db4df7   1Gi        RWO            course-nfs-storage    2m</span><br><span class="line">www-nfs-web-1   Bound     pvc-d38285f9-8b50-11e8-b585-525400db4df7   1Gi        RWO            course-nfs-storage    2m</span><br><span class="line">www-nfs-web-2   Bound     pvc-e348250b-8b50-11e8-b585-525400db4df7   1Gi        RWO            course-nfs-storage    1m</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们可以看到是不是也生成了3个 PVC 对象，名称由模板名称 name 加上 Pod 的名称组合而成，这3个 PVC 对象也都是 绑定状态了，很显然我们查看 PV 也可以看到对应的3个 PV 对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pv</span></span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                   STORAGECLASS          REASON    AGE</span><br><span class="line">...                                                        1d</span><br><span class="line">pvc-cc36b3ce-8b50-11e8-b585-525400db4df7   1Gi        RWO            Delete           Bound       default/www-nfs-web-0   course-nfs-storage              4m</span><br><span class="line">pvc-d38285f9-8b50-11e8-b585-525400db4df7   1Gi        RWO            Delete           Bound       default/www-nfs-web-1   course-nfs-storage              4m</span><br><span class="line">pvc-e348250b-8b50-11e8-b585-525400db4df7   1Gi        RWO            Delete           Bound       default/www-nfs-web-2   course-nfs-storage              4m</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看 nfs 服务器上面的共享数据目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /data/k8s/</span></span><br><span class="line">...</span><br><span class="line">default-www-nfs-web-0-pvc-cc36b3ce-8b50-11e8-b585-525400db4df7</span><br><span class="line">default-www-nfs-web-1-pvc-d38285f9-8b50-11e8-b585-525400db4df7</span><br><span class="line">default-www-nfs-web-2-pvc-e348250b-8b50-11e8-b585-525400db4df7</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>是不是也有对应的3个数据目录，这就是我们的 StorageClass 的使用方法，对于 StorageClass 多用于 StatefulSet 类型的服务，在后面的课程中我们还学不断的接触到。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.qikqiak.com/post/kubernetes-persistent-volume2/" target="_blank" rel="noopener">https://www.qikqiak.com/post/kubernetes-persistent-volume2/</a></p><h2 id="创建-Elasticsearch-集群"><a href="#创建-Elasticsearch-集群" class="headerlink" title="创建 Elasticsearch 集群"></a>创建 Elasticsearch 集群</h2><p>在创建 Elasticsearch 集群之前，我们先创建一个命名空间，我们将在其中安装所有日志相关的资源对象。</p><p>新建一个 kube-logging.yaml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">logging</span></span><br></pre></td></tr></table></figure><p>然后通过 kubectl 创建该资源清单，创建一个名为 logging 的 namespace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f kube-logging.yaml</span></span><br><span class="line">namespace/logging created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get ns</span></span><br><span class="line">NAME           STATUS    AGE</span><br><span class="line">default        Active    244d</span><br><span class="line">istio-system   Active    100d</span><br><span class="line">kube-ops       Active    179d</span><br><span class="line">kube-public    Active    244d</span><br><span class="line">kube-system    Active    244d</span><br><span class="line">logging        Active    4h</span><br><span class="line">monitoring     Active    35d</span><br></pre></td></tr></table></figure><p>现在创建了一个命名空间来存放我们的日志相关资源，接下来可以部署 EFK 相关组件，首先开始部署一个3节点的 Elasticsearch 集群。</p><p>这里我们使用3个 Elasticsearch Pod 来避免高可用下多节点集群中出现的“脑裂”问题，当一个或多个节点无法与其他节点通信时会产生“脑裂”，可能会出现几个主节点。</p><blockquote><p>了解更多 Elasticsearch 集群脑裂问题，可以查看文档<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html#split-brain" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html#split-brain</a></p></blockquote><p>一个关键点是您应该设置参数<code>discover.zen.minimum_master_nodes=N/2+1</code>，其中<code>N</code>是 Elasticsearch 集群中符合主节点的节点数，比如我们这里3个节点，意味着<code>N</code>应该设置为2。这样，如果一个节点暂时与集群断开连接，则另外两个节点可以选择一个新的主节点，并且集群可以在最后一个节点尝试重新加入时继续运行，在扩展 Elasticsearch 集群时，一定要记住这个参数。</p><p>首先创建一个名为 elasticsearch 的无头服务，新建文件 elasticsearch-svc.yaml，文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">logging</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">rest</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">9300</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">inter-node</span></span><br></pre></td></tr></table></figure><p>定义了一个名为 elasticsearch 的 Service，指定标签<code>app=elasticsearch</code>，当我们将 Elasticsearch StatefulSet 与此服务关联时，服务将返回带有标签<code>app=elasticsearch</code>的 Elasticsearch Pods 的 DNS A 记录，然后设置<code>clusterIP=None</code>，将该服务设置成无头服务。最后，我们分别定义端口9200、9300，分别用于与 REST API 交互，以及用于节点间通信。</p><p>使用 kubectl 直接创建上面的服务资源对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f elasticsearch-svc.yaml</span></span><br><span class="line">service/elasticsearch created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get services --namespace=logging</span></span><br><span class="line">Output</span><br><span class="line">NAME            TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">elasticsearch   ClusterIP   None         &lt;none&gt;        9200/TCP,9300/TCP   26s</span><br></pre></td></tr></table></figure><p>现在我们已经为 Pod 设置了无头服务和一个稳定的域名<code>.elasticsearch.logging.svc.cluster.local</code>，接下来我们通过 StatefulSet 来创建具体的 Elasticsearch 的 Pod 应用。</p><p>Kubernetes StatefulSet 允许我们为 Pod 分配一个稳定的标识和持久化存储，Elasticsearch 需要稳定的存储来保证 Pod 在重新调度或者重启后的数据依然不变，所以需要使用 StatefulSet 来管理 Pod。</p><blockquote><p>要了解更多关于 StaefulSet 的信息，可以查看官网关于 StatefulSet 的相关文档：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/</a>。</p></blockquote><p>新建名为 elasticsearch-statefulset.yaml 的资源清单文件，首先粘贴下面内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">es-cluster</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">elasticsearch</span></span><br></pre></td></tr></table></figure><p>该内容中，我们定义了一个名为 es-cluster 的 StatefulSet 对象，然后定义<code>serviceName=elasticsearch</code>和前面创建的 Service 相关联，这可以确保使用以下 DNS 地址访问 StatefulSet 中的每一个 Pod：<code>es-cluster-[0,1,2].elasticsearch.logging.svc.cluster.local</code>，其中[0,1,2]对应于已分配的 Pod 序号。</p><p>然后指定3个副本，将 matchLabels 设置为<code>app=elasticsearch</code>，所以 Pod 的模板部分<code>.spec.template.metadata.lables</code>也必须包含<code>app=elasticsearch</code>标签。</p><p>然后定义 Pod 模板部分内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">  spec:</span></span><br><span class="line"><span class="attr">    containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch-oss:6.4.3</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        limits:</span></span><br><span class="line"><span class="attr">          cpu:</span> <span class="number">1000</span><span class="string">m</span></span><br><span class="line"><span class="attr">        requests:</span></span><br><span class="line"><span class="attr">          cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - containerPort:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">rest</span></span><br><span class="line"><span class="attr">        protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      - containerPort:</span> <span class="number">9300</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">inter-node</span></span><br><span class="line"><span class="attr">        protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">        mountPath:</span> <span class="string">/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">cluster.name</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">k8s-logs</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">node.name</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">discovery.zen.ping.unicast.hosts</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">"es-cluster-0.elasticsearch,es-cluster-1.elasticsearch,es-cluster-2.elasticsearch"</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">discovery.zen.minimum_master_nodes</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">ES_JAVA_OPTS</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">"-Xms512m -Xmx512m"</span></span><br></pre></td></tr></table></figure><p>该部分是定义 StatefulSet 中的 Pod，我们这里使用一个<code>-oss</code>后缀的镜像，该镜像是 Elasticsearch 的开源版本，如果你想使用包含<code>X-Pack</code>之类的版本，可以去掉该后缀。然后暴露了9200和9300两个端口，注意名称要和上面定义的 Service 保持一致。然后通过 volumeMount 声明了数据持久化目录，下面我们再来定义 VolumeClaims。最后就是我们在容器中设置的一些环境变量了：</p><ul><li>cluster.name：Elasticsearch 集群的名称，我们这里命名成 k8s-logs。</li><li>node.name：节点的名称，通过<code>metadata.name</code>来获取。这将解析为 es-cluster-[0,1,2]，取决于节点的指定顺序。</li><li>discovery.zen.ping.unicast.hosts：此字段用于设置在 Elasticsearch 集群中节点相互连接的发现方法。我们使用 unicastdiscovery 方式，它为我们的集群指定了一个静态主机列表。由于我们之前配置的无头服务，我们的 Pod 具有唯一的 DNS 域<code>es-cluster-[0,1,2].elasticsearch.logging.svc.cluster.local</code>，因此我们相应地设置此变量。由于都在同一个 namespace 下面，所以我们可以将其缩短为<code>es-cluster-[0,1,2].elasticsearch</code>。要了解有关 Elasticsearch 发现的更多信息，请参阅 Elasticsearch 官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery.html</a>。</li><li>discovery.zen.minimum_master_nodes：我们将其设置为<code>(N/2) + 1</code>，<code>N</code>是我们的群集中符合主节点的节点的数量。我们有3个 Elasticsearch 节点，因此我们将此值设置为2（向下舍入到最接近的整数）。要了解有关此参数的更多信息，请参阅官方 Elasticsearch 文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html#split-brain" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html#split-brain</a>。</li><li>ES_JAVA_OPTS：这里我们设置为<code>-Xms512m -Xmx512m</code>，告诉<code>JVM</code>使用<code>512 MB</code>的最小和最大堆。您应该根据群集的资源可用性和需求调整这些参数。要了解更多信息，请参阅设置堆大小的相关文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html</a>。</li></ul><p>接下来添加关于 initContainer 的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">    initContainers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">fix-permissions</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">["sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"chown -R 1000:1000 /usr/share/elasticsearch/data"</span><span class="string">]</span></span><br><span class="line"><span class="attr">      securityContext:</span></span><br><span class="line"><span class="attr">        privileged:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">        mountPath:</span> <span class="string">/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">increase-vm-max-map</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">["sysctl",</span> <span class="string">"-w"</span><span class="string">,</span> <span class="string">"vm.max_map_count=262144"</span><span class="string">]</span></span><br><span class="line"><span class="attr">      securityContext:</span></span><br><span class="line"><span class="attr">        privileged:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">increase-fd-ulimit</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">["sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"ulimit -n 65536"</span><span class="string">]</span></span><br><span class="line"><span class="attr">      securityContext:</span></span><br><span class="line"><span class="attr">        privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这里我们定义了几个在主应用程序之前运行的 Init 容器，这些初始容器按照定义的顺序依次执行，执行完成后才会启动主应用容器。</p><p>第一个名为 fix-permissions 的容器用来运行 chown 命令，将 Elasticsearch 数据目录的用户和组更改为<code>1000:1000</code>（Elasticsearch 用户的 UID）。因为默认情况下，Kubernetes 用 root 用户挂载数据目录，这会使得 Elasticsearch 无法方法该数据目录，可以参考 Elasticsearch 生产中的一些默认注意事项相关文档说明：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#_notes_for_production_use_and_defaults" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#_notes_for_production_use_and_defaults</a>。</p><p>第二个名为 increase-vm-max-map 的容器用来增加操作系统对<code>mmap</code>计数的限制，默认情况下该值可能太低，导致内存不足的错误，要了解更多关于该设置的信息，可以查看 Elasticsearch 官方文档说明：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/vm-max-map-count.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/vm-max-map-count.html</a>。</p><p>最后一个初始化容器是用来执行<code>ulimit</code>命令增加打开文件描述符的最大数量的。</p><blockquote><p>此外 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#_notes_for_production_use_and_defaults" target="_blank" rel="noopener">Elastisearch Notes for Production Use</a> 文档还提到了由于性能原因最好禁用 swap，当然对于 Kubernetes 集群而言，最好也是禁用 swap 分区的。</p></blockquote><p>现在我们已经定义了主应用容器和它之前运行的 Init Containers 来调整一些必要的系统参数，接下来我们可以添加数据目录的持久化相关的配置，在 StatefulSet 中，使用 volumeClaimTemplates 来定义 volume 模板即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">  volumeClaimTemplates:</span></span><br><span class="line"><span class="attr">  - metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      accessModes:</span> <span class="string">[</span> <span class="string">"ReadWriteOnce"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">      storageClassName:</span> <span class="string">es-data-db</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        requests:</span></span><br><span class="line"><span class="attr">          storage:</span> <span class="number">50</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure><p>我们这里使用 volumeClaimTemplates 来定义持久化模板，Kubernetes 会使用它为 Pod 创建 PersistentVolume，设置访问模式为<code>ReadWriteOnce</code>，这意味着它只能被 mount 到单个节点上进行读写，然后最重要的是使用了一个名为 es-data-db 的 StorageClass 对象，所以我们需要提前创建该对象，我们这里使用的 NFS 作为存储后端，所以需要安装一个对应的 provisioner 驱动，前面关于 StorageClass 的课程中已经和大家介绍过方法，新建一个 elasticsearch-storageclass.yaml 的文件，文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">es-data-db</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">fuseim.pri/ifs</span>  <span class="comment"># 该值需要和 provisioner 配置的保持一致</span></span><br></pre></td></tr></table></figure><p>最后，我们指定了每个 PersistentVolume 的大小为 50GB，我们可以根据自己的实际需要进行调整该值。最后，完整的 Elasticsearch StatefulSet 资源清单文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">es-cluster</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch-oss:6.4.3</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">            limits:</span></span><br><span class="line"><span class="attr">              cpu:</span> <span class="number">1000</span><span class="string">m</span></span><br><span class="line"><span class="attr">            requests:</span></span><br><span class="line"><span class="attr">              cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">rest</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">9300</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">inter-node</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">cluster.name</span></span><br><span class="line"><span class="attr">            value:</span> <span class="string">k8s-logs</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">node.name</span></span><br><span class="line"><span class="attr">            valueFrom:</span></span><br><span class="line"><span class="attr">              fieldRef:</span></span><br><span class="line"><span class="attr">                fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">discovery.zen.ping.unicast.hosts</span></span><br><span class="line"><span class="attr">            value:</span> <span class="string">"es-cluster-0.elasticsearch,es-cluster-1.elasticsearch,es-cluster-2.elasticsearch"</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">discovery.zen.minimum_master_nodes</span></span><br><span class="line"><span class="attr">            value:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">ES_JAVA_OPTS</span></span><br><span class="line"><span class="attr">            value:</span> <span class="string">"-Xms512m -Xmx512m"</span></span><br><span class="line"><span class="attr">      initContainers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">fix-permissions</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"chown -R 1000:1000 /usr/share/elasticsearch/data"</span><span class="string">]</span></span><br><span class="line"><span class="attr">        securityContext:</span></span><br><span class="line"><span class="attr">          privileged:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/usr/share/elasticsearch/data</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">increase-vm-max-map</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["sysctl",</span> <span class="string">"-w"</span><span class="string">,</span> <span class="string">"vm.max_map_count=262144"</span><span class="string">]</span></span><br><span class="line"><span class="attr">        securityContext:</span></span><br><span class="line"><span class="attr">          privileged:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">increase-fd-ulimit</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"ulimit -n 65536"</span><span class="string">]</span></span><br><span class="line"><span class="attr">        securityContext:</span></span><br><span class="line"><span class="attr">          privileged:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  volumeClaimTemplates:</span></span><br><span class="line"><span class="attr">  - metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      accessModes:</span> <span class="string">[</span> <span class="string">"ReadWriteOnce"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">      storageClassName:</span> <span class="string">es-data-db</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        requests:</span></span><br><span class="line"><span class="attr">          storage:</span> <span class="number">100</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure><p>现在直接使用 kubectl 工具部署即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f elasticsearch-storageclass.yaml</span></span><br><span class="line">storageclass.storage.k8s.io "es-data-db" created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f elasticsearch-statefulset.yaml</span></span><br><span class="line">statefulset.apps/es-cluster created</span><br></pre></td></tr></table></figure><p>添加成功后，可以看到 logging 命名空间下面的所有的资源对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get sts -n logging</span></span><br><span class="line">NAME         DESIRED   CURRENT   AGE</span><br><span class="line">es-cluster   3         3         20h</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -n logging</span></span><br><span class="line">NAME                      READY     STATUS    RESTARTS   AGE</span><br><span class="line">es-cluster-0              1/1       Running   0          20h</span><br><span class="line">es-cluster-1              1/1       Running   0          20h</span><br><span class="line">es-cluster-2              1/1       Running   0          20h</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc -n logging</span></span><br><span class="line">NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">elasticsearch   ClusterIP   None             &lt;none&gt;        9200/TCP,9300/TCP   20h</span><br></pre></td></tr></table></figure><p>Pods 部署完成后，我们可以通过请求一个 REST API 来检查 Elasticsearch 集群是否正常运行。使用下面的命令将本地端口9200转发到 Elasticsearch 节点（如es-cluster-0）对应的端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward es-cluster-0 9200:9200 --namespace=logging</span></span><br><span class="line">Forwarding from 127.0.0.1:9200 -&gt; 9200</span><br><span class="line">Forwarding from [::1]:9200 -&gt; 9200</span><br></pre></td></tr></table></figure><p>然后，在另外的终端窗口中，执行如下请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://localhost:9200/_cluster/state?pretty</span></span><br></pre></td></tr></table></figure><p>正常来说，应该会看到类似于如下的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "cluster_name" : "k8s-logs",</span><br><span class="line">  "compressed_size_in_bytes" : 348,</span><br><span class="line">  "cluster_uuid" : "QD06dK7CQgids-GQZooNVw",</span><br><span class="line">  "version" : 3,</span><br><span class="line">  "state_uuid" : "mjNIWXAzQVuxNNOQ7xR-qg",</span><br><span class="line">  "master_node" : "IdM5B7cUQWqFgIHXBp0JDg",</span><br><span class="line">  "blocks" : &#123; &#125;,</span><br><span class="line">  "nodes" : &#123;</span><br><span class="line">    "u7DoTpMmSCixOoictzHItA" : &#123;</span><br><span class="line">      "name" : "es-cluster-1",</span><br><span class="line">      "ephemeral_id" : "ZlBflnXKRMC4RvEACHIVdg",</span><br><span class="line">      "transport_address" : "10.244.4.191:9300",</span><br><span class="line">      "attributes" : &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "IdM5B7cUQWqFgIHXBp0JDg" : &#123;</span><br><span class="line">      "name" : "es-cluster-0",</span><br><span class="line">      "ephemeral_id" : "JTk1FDdFQuWbSFAtBxdxAQ",</span><br><span class="line">      "transport_address" : "10.244.2.215:9300",</span><br><span class="line">      "attributes" : &#123; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "R8E7xcSUSbGbgrhAdyAKmQ" : &#123;</span><br><span class="line">      "name" : "es-cluster-2",</span><br><span class="line">      "ephemeral_id" : "9wv6ke71Qqy9vk2LgJTqaA",</span><br><span class="line">      "transport_address" : "10.244.40.4:9300",</span><br><span class="line">      "attributes" : &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看到上面的信息就表明我们名为 k8s-logs 的 Elasticsearch 集群成功创建了3个节点：es-cluster-0，es-cluster-1，和es-cluster-2，当前主节点是 es-cluster-0。</p><h2 id="创建-Kibana-服务"><a href="#创建-Kibana-服务" class="headerlink" title="创建 Kibana 服务"></a>创建 Kibana 服务</h2><p>Elasticsearch 集群启动成功了，接下来我们可以来部署 Kibana 服务，新建一个名为 kibana.yaml 的文件，对应的文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">logging</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">5601</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kibana</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">logging</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">docker.elastic.co/kibana/kibana-oss:6.4.3</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">1000</span><span class="string">m</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">ELASTICSEARCH_URL</span></span><br><span class="line"><span class="attr">            value:</span> <span class="attr">http://elasticsearch:9200</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">5601</span></span><br></pre></td></tr></table></figure><p>上面我们定义了两个资源对象，一个 Service 和 Deployment，为了测试方便，我们将 Service 设置为了 NodePort 类型，Kibana Pod 中配置都比较简单，唯一需要注意的是我们使用 ELASTICSEARCH_URL 这个环境变量来设置Elasticsearch 集群的端点和端口，直接使用 Kubernetes DNS 即可，此端点对应服务名称为 elasticsearch，由于是一个 headless service，所以该域将解析为3个 Elasticsearch Pod 的 IP 地址列表。</p><p>配置完成后，直接使用 kubectl 工具创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f kibana.yaml</span></span><br><span class="line">service/kibana created</span><br><span class="line">deployment.apps/kibana created</span><br></pre></td></tr></table></figure><p>创建完成后，可以查看 Kibana Pod 的运行状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods --namespace=logging</span></span><br><span class="line">NAME                      READY     STATUS    RESTARTS   AGE</span><br><span class="line">es-cluster-0              1/1       Running   0          20h</span><br><span class="line">es-cluster-1              1/1       Running   0          20h</span><br><span class="line">es-cluster-2              1/1       Running   0          20h</span><br><span class="line">kibana-7558d4dc4d-5mqdz   1/1       Running   0          20h</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc --namespace=logging</span></span><br><span class="line">NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">elasticsearch   ClusterIP   None             &lt;none&gt;        9200/TCP,9300/TCP   20h</span><br><span class="line">kibana          NodePort    10.105.208.253   &lt;none&gt;        5601:31816/TCP      20h</span><br></pre></td></tr></table></figure><p>如果 Pod 已经是 Running 状态了，证明应用已经部署成功了，然后可以通过 NodePort 来访问 Kibana 这个服务，在浏览器中打开<code>http://&lt;任意节点IP&gt;:31816</code>即可，如果看到如下欢迎界面证明 Kibana 已经成功部署到了 Kubernetes集群之中。</p><p><img src="/2019/11/06/%E5%9C%A8Kubernetes%E4%B8%8A%E6%90%AD%E5%BB%BAEFK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F/yBp0Hl.jpg" alt="kibana welcome">kibana welcome</p><h2 id="部署-Fluentd"><a href="#部署-Fluentd" class="headerlink" title="部署 Fluentd"></a>部署 Fluentd</h2><p><code>Fluentd</code> 是一个高效的日志聚合器，是用 Ruby 编写的，并且可以很好地扩展。对于大部分企业来说，Fluentd 足够高效并且消耗的资源相对较少，另外一个工具<code>Fluent-bit</code>更轻量级，占用资源更少，但是插件相对 Fluentd 来说不够丰富，所以整体来说，Fluentd 更加成熟，使用更加广泛，所以我们这里也同样使用 Fluentd 来作为日志收集工具。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Fluentd 通过一组给定的数据源抓取日志数据，处理后（转换成结构化的数据格式）将它们转发给其他服务，比如 Elasticsearch、对象存储等等。Fluentd 支持超过300个日志存储和分析服务，所以在这方面是非常灵活的。主要运行步骤如下：</p><ul><li>首先 Fluentd 从多个日志源获取数据</li><li>结构化并且标记这些数据</li><li>然后根据匹配的标签将数据发送到多个目标服务去</li></ul><p><img src="/2019/11/06/%E5%9C%A8Kubernetes%E4%B8%8A%E6%90%AD%E5%BB%BAEFK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F/lfDrcH.jpg" alt="fluentd 架构">fluentd 架构</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>一般来说我们是通过一个配置文件来告诉 Fluentd 如何采集、处理数据的，下面简单和大家介绍下 Fluentd 的配置方法。</p><h4 id="日志源配置"><a href="#日志源配置" class="headerlink" title="日志源配置"></a>日志源配置</h4><p>比如我们这里为了收集 Kubernetes 节点上的所有容器日志，就需要做如下的日志源配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;source&gt;</span><br><span class="line"></span><br><span class="line">@id fluentd-containers.log</span><br><span class="line"></span><br><span class="line">@type tail</span><br><span class="line"></span><br><span class="line">path /var/log/containers/*.log</span><br><span class="line"></span><br><span class="line">pos_file /var/log/fluentd-containers.log.pos</span><br><span class="line"></span><br><span class="line">time_format %Y-%m-%dT%H:%M:%S.%NZ</span><br><span class="line"></span><br><span class="line">tag raw.kubernetes.*</span><br><span class="line"></span><br><span class="line">format json</span><br><span class="line"></span><br><span class="line">read_from_head true</span><br><span class="line"></span><br><span class="line">&lt;/source&gt;</span><br></pre></td></tr></table></figure><p>上面配置部分参数说明如下：</p><ul><li>id：表示引用该日志源的唯一标识符，该标识可用于进一步过滤和路由结构化日志数据</li><li>type：Fluentd 内置的指令，<code>tail</code>表示 Fluentd 从上次读取的位置通过 tail 不断获取数据，另外一个是<code>http</code>表示通过一个 GET 请求来收集数据。</li><li>path：<code>tail</code>类型下的特定参数，告诉 Fluentd 采集<code>/var/log/containers</code>目录下的所有日志，这是 docker 在 Kubernetes 节点上用来存储运行容器 stdout 输出日志数据的目录。</li><li>pos_file：检查点，如果 Fluentd 程序重新启动了，它将使用此文件中的位置来恢复日志数据收集。</li><li>tag：用来将日志源与目标或者过滤器匹配的自定义字符串，Fluentd 匹配源/目标标签来路由日志数据。</li></ul><h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><p>上面是日志源的配置，接下来看看如何将日志数据发送到 Elasticsearch：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;match **&gt;</span><br><span class="line"></span><br><span class="line">@id elasticsearch</span><br><span class="line"></span><br><span class="line">@type elasticsearch</span><br><span class="line"></span><br><span class="line">@log_level info</span><br><span class="line"></span><br><span class="line">include_tag_key true</span><br><span class="line"></span><br><span class="line">type_name fluentd</span><br><span class="line"></span><br><span class="line">host &quot;#&#123;ENV[&apos;OUTPUT_HOST&apos;]&#125;&quot;</span><br><span class="line"></span><br><span class="line">port &quot;#&#123;ENV[&apos;OUTPUT_PORT&apos;]&#125;&quot;</span><br><span class="line"></span><br><span class="line">logstash_format true</span><br><span class="line"></span><br><span class="line">&lt;buffer&gt;</span><br><span class="line"></span><br><span class="line">@type file</span><br><span class="line"></span><br><span class="line">path /var/log/fluentd-buffers/kubernetes.system.buffer</span><br><span class="line"></span><br><span class="line">flush_mode interval</span><br><span class="line"></span><br><span class="line">retry_type exponential_backoff</span><br><span class="line"></span><br><span class="line">flush_thread_count 2</span><br><span class="line"></span><br><span class="line">flush_interval 5s</span><br><span class="line"></span><br><span class="line">retry_forever</span><br><span class="line"></span><br><span class="line">retry_max_interval 30</span><br><span class="line"></span><br><span class="line">chunk_limit_size &quot;#&#123;ENV[&apos;OUTPUT_BUFFER_CHUNK_LIMIT&apos;]&#125;&quot;</span><br><span class="line"></span><br><span class="line">queue_limit_length &quot;#&#123;ENV[&apos;OUTPUT_BUFFER_QUEUE_LIMIT&apos;]&#125;&quot;</span><br><span class="line"></span><br><span class="line">overflow_action block</span><br><span class="line"></span><br><span class="line">&lt;/buffer&gt;</span><br></pre></td></tr></table></figure><ul><li>match：标识一个目标标签，后面是一个匹配日志源的正则表达式，我们这里想要捕获所有的日志并将它们发送给 Elasticsearch，所以需要配置成<code>**</code>。</li><li>id：目标的一个唯一标识符。</li><li>type：支持的输出插件标识符，我们这里要输出到 Elasticsearch，所以配置成 elasticsearch，这是 Fluentd 的一个内置插件。</li><li>log_level：指定要捕获的日志级别，我们这里配置成<code>info</code>，表示任何该级别或者该级别以上（INFO、WARNING、ERROR）的日志都将被路由到 Elsasticsearch。</li><li>host/port：定义 Elasticsearch 的地址，也可以配置认证信息，我们的 Elasticsearch 不需要认证，所以这里直接指定 host 和 port 即可。</li><li>logstash_format：Elasticsearch 服务对日志数据构建反向索引进行搜索，将 logstash_format 设置为<code>true</code>，Fluentd 将会以 logstash 格式来转发结构化的日志数据。</li><li>Buffer： Fluentd 允许在目标不可用时进行缓存，比如，如果网络出现故障或者 Elasticsearch 不可用的时候。缓冲区配置也有助于降低磁盘的 IO。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>要收集 Kubernetes 集群的日志，直接用 DasemonSet 控制器来部署 Fluentd 应用，这样，它就可以从 Kubernetes 节点上采集日志，确保在集群中的每个节点上始终运行一个 Fluentd 容器。当然可以直接使用 Helm 来进行一键安装，为了能够了解更多实现细节，我们这里还是采用手动方法来进行安装。</p><p>首先，我们通过 ConfigMap 对象来指定 Fluentd 配置文件，新建 fluentd-configmap.yaml 文件，文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fluentd-config</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">logging</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">system.conf:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">&lt;system&gt;</span></span><br><span class="line">      <span class="string">root_dir</span> <span class="string">/tmp/fluentd-buffers/</span></span><br><span class="line">    <span class="string">&lt;/system&gt;</span></span><br><span class="line">  <span class="string">containers.input.conf:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">&lt;source&gt;</span></span><br><span class="line">      <span class="string">@id</span> <span class="string">fluentd-containers.log</span></span><br><span class="line">      <span class="string">@type</span> <span class="string">tail</span></span><br><span class="line">      <span class="string">path</span> <span class="string">/var/log/containers/*.log</span></span><br><span class="line">      <span class="string">pos_file</span> <span class="string">/var/log/es-containers.log.pos</span></span><br><span class="line">      <span class="string">time_format</span> <span class="string">%Y-%m-%dT%H:%M:%S.%NZ</span></span><br><span class="line">      <span class="string">localtime</span></span><br><span class="line">      <span class="string">tag</span> <span class="string">raw.kubernetes.*</span></span><br><span class="line">      <span class="string">format</span> <span class="string">json</span></span><br><span class="line">      <span class="string">read_from_head</span> <span class="literal">true</span></span><br><span class="line">    <span class="string">&lt;/source&gt;</span></span><br><span class="line">    <span class="comment"># Detect exceptions in the log output and forward them as one log entry.</span></span><br><span class="line">    <span class="string">&lt;match</span> <span class="string">raw.kubernetes.**&gt;</span></span><br><span class="line">      <span class="string">@id</span> <span class="string">raw.kubernetes</span></span><br><span class="line">      <span class="string">@type</span> <span class="string">detect_exceptions</span></span><br><span class="line">      <span class="string">remove_tag_prefix</span> <span class="string">raw</span></span><br><span class="line">      <span class="string">message</span> <span class="string">log</span></span><br><span class="line">      <span class="string">stream</span> <span class="string">stream</span></span><br><span class="line">      <span class="string">multiline_flush_interval</span> <span class="number">5</span></span><br><span class="line">      <span class="string">max_bytes</span> <span class="number">500000</span></span><br><span class="line">      <span class="string">max_lines</span> <span class="number">1000</span></span><br><span class="line">    <span class="string">&lt;/match&gt;</span></span><br><span class="line">  <span class="string">system.input.conf:</span> <span class="string">|-</span></span><br><span class="line">    <span class="comment"># Logs from systemd-journal for interesting services.</span></span><br><span class="line">    <span class="string">&lt;source&gt;</span></span><br><span class="line">      <span class="string">@id</span> <span class="string">journald-docker</span></span><br><span class="line">      <span class="string">@type</span> <span class="string">systemd</span></span><br><span class="line">      <span class="string">filters</span> <span class="string">[&#123;</span> <span class="string">"_SYSTEMD_UNIT"</span><span class="string">:</span> <span class="string">"docker.service"</span> <span class="string">&#125;]</span></span><br><span class="line">      <span class="string">&lt;storage&gt;</span></span><br><span class="line">        <span class="string">@type</span> <span class="string">local</span></span><br><span class="line">        <span class="string">persistent</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">&lt;/storage&gt;</span></span><br><span class="line">      <span class="string">read_from_head</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">tag</span> <span class="string">docker</span></span><br><span class="line">    <span class="string">&lt;/source&gt;</span></span><br><span class="line">    <span class="string">&lt;source&gt;</span></span><br><span class="line">      <span class="string">@id</span> <span class="string">journald-kubelet</span></span><br><span class="line">      <span class="string">@type</span> <span class="string">systemd</span></span><br><span class="line">      <span class="string">filters</span> <span class="string">[&#123;</span> <span class="string">"_SYSTEMD_UNIT"</span><span class="string">:</span> <span class="string">"kubelet.service"</span> <span class="string">&#125;]</span></span><br><span class="line">      <span class="string">&lt;storage&gt;</span></span><br><span class="line">        <span class="string">@type</span> <span class="string">local</span></span><br><span class="line">        <span class="string">persistent</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">&lt;/storage&gt;</span></span><br><span class="line">      <span class="string">read_from_head</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">tag</span> <span class="string">kubelet</span></span><br><span class="line">    <span class="string">&lt;/source&gt;</span></span><br><span class="line">  <span class="string">forward.input.conf:</span> <span class="string">|-</span></span><br><span class="line">    <span class="comment"># Takes the messages sent over TCP</span></span><br><span class="line">    <span class="string">&lt;source&gt;</span></span><br><span class="line">      <span class="string">@type</span> <span class="string">forward</span></span><br><span class="line">    <span class="string">&lt;/source&gt;</span></span><br><span class="line">  <span class="string">output.conf:</span> <span class="string">|-</span></span><br><span class="line">    <span class="comment"># Enriches records with Kubernetes metadata</span></span><br><span class="line">    <span class="string">&lt;filter</span> <span class="string">kubernetes.**&gt;</span></span><br><span class="line">      <span class="string">@type</span> <span class="string">kubernetes_metadata</span></span><br><span class="line">    <span class="string">&lt;/filter&gt;</span></span><br><span class="line">    <span class="string">&lt;match</span> <span class="string">**&gt;</span></span><br><span class="line">      <span class="string">@id</span> <span class="string">elasticsearch</span></span><br><span class="line">      <span class="string">@type</span> <span class="string">elasticsearch</span></span><br><span class="line">      <span class="string">@log_level</span> <span class="string">info</span></span><br><span class="line">      <span class="string">include_tag_key</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">host</span> <span class="string">elasticsearch</span></span><br><span class="line">      <span class="string">port</span> <span class="number">9200</span></span><br><span class="line">      <span class="string">logstash_format</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">request_timeout</span>    <span class="number">30</span><span class="string">s</span></span><br><span class="line">      <span class="string">&lt;buffer&gt;</span></span><br><span class="line">        <span class="string">@type</span> <span class="string">file</span></span><br><span class="line">        <span class="string">path</span> <span class="string">/var/log/fluentd-buffers/kubernetes.system.buffer</span></span><br><span class="line">        <span class="string">flush_mode</span> <span class="string">interval</span></span><br><span class="line">        <span class="string">retry_type</span> <span class="string">exponential_backoff</span></span><br><span class="line">        <span class="string">flush_thread_count</span> <span class="number">2</span></span><br><span class="line">        <span class="string">flush_interval</span> <span class="number">5</span><span class="string">s</span></span><br><span class="line">        <span class="string">retry_forever</span></span><br><span class="line">        <span class="string">retry_max_interval</span> <span class="number">30</span></span><br><span class="line">        <span class="string">chunk_limit_size</span> <span class="number">2</span><span class="string">M</span></span><br><span class="line">        <span class="string">queue_limit_length</span> <span class="number">8</span></span><br><span class="line">        <span class="string">overflow_action</span> <span class="string">block</span></span><br><span class="line">      <span class="string">&lt;/buffer&gt;</span></span><br><span class="line">    <span class="string">&lt;/match&gt;</span></span><br></pre></td></tr></table></figure><p>上面配置文件中我们配置了 docker 容器日志目录以及 docker、kubelet 应用的日志的收集，收集到数据经过处理后发送到 elasticsearch:9200 服务。</p><p>然后新建一个 fluentd-daemonset.yaml 的文件，文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fluentd-es</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">logging</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line">    <span class="string">kubernetes.io/cluster-service:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fluentd-es</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line">    <span class="string">kubernetes.io/cluster-service:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="attr">- apiGroups:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">""</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"namespaces"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"pods"</span></span><br><span class="line"><span class="attr">  verbs:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"get"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"watch"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"list"</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fluentd-es</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line">    <span class="string">kubernetes.io/cluster-service:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fluentd-es</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">logging</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fluentd-es</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">""</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fluentd-es</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">logging</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line"><span class="attr">    version:</span> <span class="string">v2.0.4</span></span><br><span class="line">    <span class="string">kubernetes.io/cluster-service:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line"><span class="attr">      version:</span> <span class="string">v2.0.4</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line">        <span class="string">kubernetes.io/cluster-service:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v2.0.4</span></span><br><span class="line">      <span class="comment"># This annotation ensures that fluentd does not get evicted if the node</span></span><br><span class="line">      <span class="comment"># supports critical pod annotation based priority scheme.</span></span><br><span class="line">      <span class="comment"># Note that this does not guarantee admission on the nodes (#40573).</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">scheduler.alpha.kubernetes.io/critical-pod:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      serviceAccountName:</span> <span class="string">fluentd-es</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">fluentd-es</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">cnych/fluentd-elasticsearch:v2.0.4</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">FLUENTD_ARGS</span></span><br><span class="line"><span class="attr">          value:</span> <span class="bullet">--no-supervisor</span> <span class="bullet">-q</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">500</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">200</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/data/docker/containers</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">config-volume</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/etc/fluent/config.d</span></span><br><span class="line"><span class="attr">      nodeSelector:</span></span><br><span class="line">        <span class="string">beta.kubernetes.io/fluentd-ds-ready:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">      tolerations:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="attr">        operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">        effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">        hostPath:</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line"><span class="attr">        hostPath:</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/data/docker/containers</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">config-volume</span></span><br><span class="line"><span class="attr">        configMap:</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">fluentd-config</span></span><br></pre></td></tr></table></figure><p>我们将上面创建的 fluentd-config 这个 ConfigMap 对象通过 volumes 挂载到了 Fluentd 容器中，另外为了能够灵活控制哪些节点的日志可以被收集，所以我们这里还添加了一个 nodSelector 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="string">beta.kubernetes.io/fluentd-ds-ready:</span> <span class="string">"true"</span></span><br></pre></td></tr></table></figure><p>意思就是要想采集节点的日志，那么我们就需要给节点打上上面的标签，比如我们这里3个节点都打上了该标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes --show-labels</span></span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION   LABELS</span><br><span class="line">master    Ready     master    245d      v1.10.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/fluentd-ds-ready=true,beta.kubernetes.io/os=linux,kubernetes.io/hostname=master,node-role.kubernetes.io/master=</span><br><span class="line">node02    Ready     &lt;none&gt;    165d      v1.10.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/fluentd-ds-ready=true,beta.kubernetes.io/os=linux,com=youdianzhishi,course=k8s,kubernetes.io/hostname=node02</span><br><span class="line">node03    Ready     &lt;none&gt;    225d      v1.10.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/fluentd-ds-ready=true,beta.kubernetes.io/os=linux,jnlp=haimaxy,kubernetes.io/hostname=node03</span><br></pre></td></tr></table></figure><p>另外由于我们的集群使用的是 kubeadm 搭建的，默认情况下 master 节点有污点，所以要想也收集 master 节点的日志，则需要添加上容忍：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="attr">- key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="attr">  operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">  effect:</span> <span class="string">NoSchedule</span></span><br></pre></td></tr></table></figure><p>另外需要注意的地方是，我这里的测试环境更改了 docker 的根目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker info</span></span><br><span class="line">...</span><br><span class="line">Docker Root Dir: /data/docker</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以上面要获取 docker 的容器目录需要更改成<code>/data/docker/containers</code>，这个地方非常重要，当然如果你没有更改 docker 根目录则使用默认的<code>/var/lib/docker/containers</code>目录即可。</p><p>分别创建上面的 ConfigMap 对象和 DaemonSet：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f fluentd-configmap.yaml</span></span><br><span class="line">configmap "fluentd-config" created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f fluentd-daemonset.yaml</span></span><br><span class="line">serviceaccount "fluentd-es" created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io "fluentd-es" created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io "fluentd-es" created</span><br><span class="line">daemonset.apps "fluentd-es" created</span><br></pre></td></tr></table></figure><p>创建完成后，查看对应的 Pods 列表，检查是否部署成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -n logging</span></span><br><span class="line">NAME                      READY     STATUS    RESTARTS   AGE</span><br><span class="line">es-cluster-0              1/1       Running   0          1d</span><br><span class="line">es-cluster-1              1/1       Running   0          1d</span><br><span class="line">es-cluster-2              1/1       Running   0          1d</span><br><span class="line">fluentd-es-2z9jg          1/1       Running   1          35s</span><br><span class="line">fluentd-es-6dfdd          1/1       Running   0          35s</span><br><span class="line">fluentd-es-bfkg7          1/1       Running   0          35s</span><br><span class="line">kibana-7558d4dc4d-5mqdz   1/1       Running   0          1d</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果当前node没有打上<code>fluentd-ds-ready=true</code> lable的话，对应的pod <code>fluentd</code>不会被启动。</p><p>Fluentd 启动成功后，我们可以前往 Kibana 的 Dashboard 页面中，点击左侧的<code>Discover</code>，可以看到如下配置页面：</p><p><img src="/2019/11/06/%E5%9C%A8Kubernetes%E4%B8%8A%E6%90%AD%E5%BB%BAEFK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F/kSLsgE.jpg" alt="create index">create index</p><p>在这里可以配置我们需要的 Elasticsearch 索引，前面 Fluentd 配置文件中我们采集的日志使用的是 logstash 格式，这里只需要在文本框中输入<code>logstash-*</code>即可匹配到 Elasticsearch 集群中的所有日志数据，然后点击下一步，进入以下页面：</p><p><img src="/2019/11/06/%E5%9C%A8Kubernetes%E4%B8%8A%E6%90%AD%E5%BB%BAEFK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F/bc7n1S.jpg" alt="index config">index config</p><p>在该页面中配置使用哪个字段按时间过滤日志数据，在下拉列表中，选择<code>@timestamp</code>字段，然后点击<code>Create index pattern</code>，创建完成后，点击左侧导航菜单中的<code>Discover</code>，然后就可以看到一些直方图和最近采集到的日志数据了：</p><p><img src="/2019/11/06/%E5%9C%A8Kubernetes%E4%B8%8A%E6%90%AD%E5%BB%BAEFK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F/wHFvnu.jpg" alt="log data">log data</p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>现在我们来将上一节课的计数器应用部署到集群中，并在 Kibana 中来查找该日志数据。</p><p>新建 counter.yaml 文件，文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">counter</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">count</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    args:</span> <span class="string">[/bin/sh,</span> <span class="bullet">-c,</span></span><br><span class="line">            <span class="string">'i=0; while true; do echo "$i: $(date)"; i=$((i+1)); sleep 1; done'</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>该 Pod 只是简单将日志信息打印到 stdout，所以正常来说 Fluentd 会收集到这个日志数据，在 Kibana 中也就可以找到对应的日志数据了，使用 kubectl 工具创建该 Pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create -f counter.yaml</span></span><br></pre></td></tr></table></figure><p>Pod 创建并运行后，回到 Kibana Dashboard 页面，在上面的<code>Discover</code>页面搜索栏中输入<code>kubernetes.pod_name:counter</code>，就可以过滤 Pod 名为 counter 的日志数据：</p><p><img src="/2019/11/06/%E5%9C%A8Kubernetes%E4%B8%8A%E6%90%AD%E5%BB%BAEFK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F/HsYSF3.jpg" alt="counter log data">counter log data</p><p>我们也可以通过其他元数据来过滤日志数据，比如 您可以单击任何日志条目以查看其他元数据，如容器名称，Kubernetes 节点，命名空间等。</p><p>到这里，我们就在 Kubernetes 集群上成功部署了 EFK ，要了解如何使用 Kibana 进行日志数据分析，可以参考 Kibana 用户指南文档：<a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/kibana/current/index.html</a></p><p>当然对于在生产环境上使用 Elaticsearch 或者 Fluentd，还需要结合实际的环境做一系列的优化工作，本文中涉及到的资源清单文件都可以在<a href="https://github.com/cnych/kubernetes-learning/tree/master/efkdemo" target="_blank" rel="noopener">https://github.com/cnych/kubernetes-learning/tree/master/efkdemo</a>找到。</p><blockquote><p>参考文档: <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-an-elasticsearch-fluentd-and-kibana-efk-logging-stack-on-kubernetes" target="_blank" rel="noopener">How To Set Up an Elasticsearch, Fluentd and Kibana (EFK) Logging Stack on Kubernetes</a></p><p>参考链接：<a href="https://www.jianshu.com/p/1000ae80a493" target="_blank" rel="noopener">https://www.jianshu.com/p/1000ae80a493</a></p></blockquote><h2 id="部署logtrail"><a href="#部署logtrail" class="headerlink" title="部署logtrail"></a>部署logtrail</h2><p>下载kibana对应版本的logtrail <a href="https://github.com/sivasamyk/logtrail" target="_blank" rel="noopener">https://github.com/sivasamyk/logtrail</a></p><p>由于kibana镜像不带logtrail，安装插件后需要重启kibana，在容器下无法重启。因此需要基于kibana镜像重新生成一个带插件的新镜像。</p><p>以6.7.0版本为例，Dockerfile如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># elk https://hub.docker.com/r/sebp/elk</span><br><span class="line">#FROM sebp/elk:670</span><br><span class="line">FROM docker.elastic.co/kibana/kibana-oss:6.7.0</span><br><span class="line">#ADD 02-beats-input.conf /etc/logstash/conf.d/02-beats-input.conf</span><br><span class="line">#ADD 30-output.conf /etc/logstash/conf.d/30-output.conf</span><br><span class="line"># kibanasivasamyk/logtrail </span><br><span class="line">ADD ./logtrail-6.7.0-0.1.31.zip /opt/kibana/plugin/logtrail-6.7.0-0.1.31.zip</span><br><span class="line">#  kibana</span><br><span class="line"># WORKDIR $&#123;KIBANA_HOME&#125;</span><br><span class="line"># kibana</span><br><span class="line">RUN bin/kibana-plugin install file:///opt/kibana/plugin/logtrail-6.7.0-0.1.31.zip</span><br></pre></td></tr></table></figure><p>执行build命令</p><blockquote><p>docker build  –network=host -t docker.elastic.co/kibana/kibana-oss:kibana-logtrail .</p></blockquote><p>或者</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> docker.elastic.co/kibana/kibana-oss:<span class="number">6.2</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> kibana-plugin install https://github.com/sivasamyk/logtrail/releases/download/v0.1.27/logtrail-6.2.4-0.1.27.zip</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /config</span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv /usr/share/kibana/plugins/logtrail/logtrail.json /config/logtrail.json &amp;&amp; \</span></span><br><span class="line"><span class="bash">    ln -s /config/logtrail.json /usr/share/kibana/plugins/logtrail/logtrail.json</span></span><br><span class="line"><span class="keyword">USER</span> kibana</span><br></pre></td></tr></table></figure><p>使用configmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: logtrail-config</span><br><span class="line">data:</span><br><span class="line">  logtrail.json: |</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;version&quot; : 1,</span><br><span class="line">        &quot;index_patterns&quot; : [</span><br><span class="line">        &#123;      </span><br><span class="line">            &quot;es&quot;: &#123;</span><br><span class="line">                &quot;default_index&quot;: &quot;logstash-*&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;tail_interval_in_seconds&quot;: 10,</span><br><span class="line">            &quot;es_index_time_offset_in_seconds&quot;: 0,</span><br><span class="line">            &quot;display_timezone&quot;: &quot;local&quot;,</span><br><span class="line">            &quot;display_timestamp_format&quot;: &quot;MMM DD HH:mm:ss&quot;,</span><br><span class="line">            &quot;max_buckets&quot;: 500,</span><br><span class="line">            &quot;default_time_range_in_days&quot; : 0,</span><br><span class="line">            &quot;max_hosts&quot;: 100,</span><br><span class="line">            &quot;max_events_to_keep_in_viewer&quot;: 5000,</span><br><span class="line">            &quot;fields&quot; : &#123;</span><br><span class="line">                &quot;mapping&quot; : &#123;</span><br><span class="line">                    &quot;timestamp&quot; : &quot;@timestamp&quot;,</span><br><span class="line">                    &quot;hostname&quot; : &quot;kubernetes.host&quot;,</span><br><span class="line">                    &quot;program&quot;: &quot;kubernetes.pod_name&quot;,</span><br><span class="line">                    &quot;message&quot;: &quot;log&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;message_format&quot;: &quot;&#123;&#123;&#123;log&#125;&#125;&#125;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;color_mapping&quot; : &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125; </span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: kibana</span><br><span class="line">  labels:</span><br><span class="line">    component: kibana</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">     component: kibana</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        component: kibana</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kibana</span><br><span class="line">        image: sh4d1/kibana-logtrail:6.2.4 # or your image</span><br><span class="line">        volumeMounts:</span><br><span class="line">          - name: logtrail-config</span><br><span class="line">            mountPath: /config</span><br><span class="line">        env:</span><br><span class="line">        - name: CLUSTER_NAME</span><br><span class="line">          value: myesdb # the name of your ES cluster</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 1000m</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 5601</span><br><span class="line">          name: http</span><br><span class="line">      volumes:</span><br><span class="line">        - name: logtrail-config</span><br><span class="line">          configMap:</span><br><span class="line">            name: logtrail-config</span><br></pre></td></tr></table></figure><p>Then the important part is the <code>fields</code> section. It will display like:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp hostname program:message</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 中比较流行的日志收集解决方案是 &lt;code&gt;Elasticsearch&lt;/code&gt;、&lt;code&gt;Fluentd&lt;/code&gt; 和 &lt;code&gt;Kibana&lt;/code&gt;（EFK）技术栈，也是官方现在比较推荐的一种方案。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Elasticsearch&lt;/code&gt; 是一个实时的、分布式的可扩展的搜索引擎，允许进行全文、结构化搜索，它通常用于索引和搜索大量日志数据，也可用于搜索许多不同类型的文档。&lt;/p&gt;
    
    </summary>
    
    
      <category term="持续集成" scheme="http://geoffen.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="k8s" scheme="http://geoffen.github.io/tags/k8s/"/>
    
      <category term="EFK" scheme="http://geoffen.github.io/tags/EFK/"/>
    
  </entry>
  
  <entry>
    <title>【转】docker容器和镜像区别</title>
    <link href="http://geoffen.github.io/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/"/>
    <id>http://geoffen.github.io/2019/11/06/docker容器和镜像区别/</id>
    <published>2019-11-06T00:30:44.000Z</published>
    <updated>2019-11-07T10:24:47.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源 | <a href="http://sina.lt/gfmf" target="_blank" rel="noopener">http://sina.lt/gfmf</a></p></blockquote><p>这篇文章希望能够帮助读者深入理解Docker的命令，还有容器（container）和镜像（image）之间的区别，并深入探讨容器和运行中的容器之间的区别。 </p><p><a href="http://dockerone.com/uploads/article/20151103/d6ad9c257d160164480b25b278f4a2ad.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115301_427.png" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>当我对Docker技术还是一知半解的时候，我发现理解Docker的命令非常困难。于是，我花了几周的时间来学习Docker的工作原理，更确 切地说，是关于Docker统一文件系统（the union file system）的知识，然后回过头来再看Docker的命令，一切变得顺理成章，简单极了。 </p><a id="more"></a><p>题外话：就我个人而言，掌握一门技术并合理使用它的最好办法就是深入理解这项技术背后的工作原理。通常情况 下，一项新技术的诞生常常会伴随着媒体的大肆宣传和炒作，这使得用户很难看清技术的本质。更确切地说，新技术总是会发明一些新的术语或者隐喻词来帮助宣 传，这在初期是非常有帮助的，但是这给技术的原理蒙上了一层砂纸，不利于用户在后期掌握技术的真谛。 </p><p>Git就是一个很好的例子。我之前不能够很好的使用Git，于是我花了一段时间去学习Git的原理，直到这时，我才真正明白了Git的用法。我坚信只有真正理解Git内部原理的人才能够掌握这个工具。 </p><h3 id="Image-Definition"><a href="#Image-Definition" class="headerlink" title="Image Definition"></a>Image Definition</h3><p>镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。 </p><p><a href="http://dockerone.com/uploads/article/20151103/522c40256149bad2b471d1a97c2b6bb5.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115301_703.png" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是Docker内部的实现细节，并且能够 在主机（译者注：运行Docker的机器）的文件系统上访问到。统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。 我们可以在图片的右边看到这个视角的形式。 </p><p>你可以在你的主机文件系统上找到有关这些层的文件。需要注意的是，在一个运行中的容器内部，这些层是不可见的。在我的主机上，我发现它们存在于/var/lib/docker/aufs目录下。 </p><h1 id="sudo-tree-L-1-var-lib-docker"><a href="#sudo-tree-L-1-var-lib-docker" class="headerlink" title="sudo tree -L 1 /var/lib/docker/"></a>sudo tree -L 1 /var/lib/docker/</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/</span><br><span class="line">├── aufs</span><br><span class="line">├── containers</span><br><span class="line">├── graph</span><br><span class="line">├── init</span><br><span class="line">├── linkgraph.db</span><br><span class="line">├── repositories-aufs</span><br><span class="line">├── tmp</span><br><span class="line">├── trust</span><br><span class="line">└── volumes</span><br><span class="line">7 directories, 2 files</span><br></pre></td></tr></table></figure><h3 id="Container-Definition"><a href="#Container-Definition" class="headerlink" title="Container Definition"></a>Container Definition</h3><p>容器（container）的定义和镜像（image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 </p><p><a href="http://dockerone.com/uploads/article/20151103/b7fb9d924aa12099369c4793050fcfab.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115302_58.png" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>细心的读者可能会发现，容器的定义并没有提及容器是否在运行，没错，这是故意的。正是这个发现帮助我理解了很多困惑。 </p><p>要点：容器 = 镜像 + 可读层。并且容器的定义并没有提及是否要运行容器。 </p><p>接下来，我们将会讨论运行态容器。 </p><h3 id="Running-Container-Definition"><a href="#Running-Container-Definition" class="headerlink" title="Running Container Definition"></a>Running Container Definition</h3><p>一个运行态容器（running container）被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程。下面这张图片展示了一个运行中的容器。 </p><p><a href="http://dockerone.com/uploads/article/20151103/8022edeebeb313742bd615aa695bbad3.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115302_576.png" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>正是文件系统隔离技术使得Docker成为了一个前途无量的技术。一个容器中的进程可能会对文件进行修改、删除、创建，这些改变都将作用于可读写层（read-write layer）。下面这张图展示了这个行为。 </p><p><a href="http://dockerone.com/uploads/article/20151103/1dc88de5a114b68d05c37aab7e103597.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115302_268.png" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>我们可以通过运行以下命令来验证我们上面所说的： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu touch happiness.txt</span><br></pre></td></tr></table></figure><p>即便是这个ubuntu容器不再运行，我们依旧能够在主机的文件系统上找到这个新文件。 </p><h1 id="find-name-happiness-txt"><a href="#find-name-happiness-txt" class="headerlink" title="find / -name happiness.txt"></a>find / -name happiness.txt</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/aufs/diff/860a7b...889/happiness.txt</span><br></pre></td></tr></table></figure><h3 id="Image-Layer-Definition"><a href="#Image-Layer-Definition" class="headerlink" title="Image Layer Definition"></a>Image Layer Definition</h3><p>为了将零星的数据整合起来，我们提出了镜像层（image layer）这个概念。下面的这张图描述了一个镜像层，通过图片我们能够发现一个层并不仅仅包含文件系统的改变，它还能包含了其他重要信息。 </p><p><a href="http://dockerone.com/uploads/article/20151103/e42d56394306894244af5bc6d757bee1.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115302_80.png" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>元数据（metadata）就是关于这个层的额外信息，它不仅能够让Docker获取运行和构建时的信息，还包括父层的层次信息。需要注意，只读层和读写层都包含元数据。 </p><p><a href="http://dockerone.com/uploads/article/20151103/5cca590212e2a110be84cbdd3b6101ee.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115302_513.png" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>除此之外，每一层都包括了一个指向父层的指针。如果一个层没有这个指针，说明它处于最底层。 </p><p><a href="http://dockerone.com/uploads/article/20151103/1ead4d955aeb5d968219794489948fc2.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115303_299.png" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>Metadata Location:<br>我发现在我自己的主机上，镜像层（image layer）的元数据被保存在名为”json”的文件中，比如说： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/graph/e809f156dc985.../json</span><br></pre></td></tr></table></figure><p>e809f156dc985…就是这层的id </p><p>一个容器的元数据好像是被分成了很多文件，但或多或少能够在/var/lib/docker/containers/<id>目录下找到，<id>就是一个可读层的id。这个目录下的文件大多是运行时的数据，比如说网络，日志等等。 </id></id></p><h3 id="全局理解（Tying-It-All-Together）"><a href="#全局理解（Tying-It-All-Together）" class="headerlink" title="全局理解（Tying It All Together）"></a>全局理解（Tying It All Together）</h3><p>现在，让我们结合上面提到的实现细节来理解Docker的命令。 </p><h4 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create "></a>docker create <image-id></image-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/1397bbddca6651a3ae0316daa8d6d1cd.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115303_594.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker create 命令为指定的镜像（image）添加了一个可读写层，构成了一个新的容器。注意，这个容器并没有运行。 </p><p><a href="http://dockerone.com/uploads/article/20151103/bbe622329b399778b077617ae6468676.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115303_843.png" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><h4 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start "></a>docker start <container-id></container-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/3f08537e309b923d049fdde3d3a1f926.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115303_670.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>Docker start命令为容器文件系统创建了一个进程隔离空间。注意，每一个容器只能够有一个进程隔离空间。 </p><h4 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run "></a>docker run <image-id></image-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/4178f2b64f6a2eeb994866931417f263.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115303_318.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>看到这个命令，读者通常会有一个疑问：docker start 和 docker run命令有什么区别。 </p><p><a href="http://dockerone.com/uploads/article/20151103/ea18907dedcd8893b39ae1f9e3ad8a3e.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115304_352.png" alt="7.png"></a></p><p>从图片可以看出，docker run 命令先是利用镜像创建了一个容器，然后运行这个容器。这个命令非常的方便，并且隐藏了两个命令的细节，但从另一方面来看，这容易让用户产生误解。 </p><p>题外话：继续我们之前有关于Git的话题，我认为docker run命令类似于git pull命令。git pull命令就是git fetch 和 git merge两个命令的组合，同样的，docker run就是docker create和docker start两个命令的组合。 </p><h4 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h4><p><a href="http://dockerone.com/uploads/article/20151031/fafeb4eb072e64b54b9979930a6d8db7.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115304_250.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker ps 命令会列出所有运行中的容器。这隐藏了非运行态容器的存在，如果想要找出这些容器，我们需要使用下面这个命令。 </p><h4 id="docker-ps-–a"><a href="#docker-ps-–a" class="headerlink" title="docker ps –a"></a>docker ps –a</h4><p><a href="http://dockerone.com/uploads/article/20151031/120d394e57a03a5bb996b23e6e373cf1.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115304_237.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker ps –a命令会列出所有的容器，不管是运行的，还是停止的。 </p><h4 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h4><p><a href="http://dockerone.com/uploads/article/20151031/f8b34de7f7f325e2933aac5cc679e224.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115304_909.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker images命令会列出了所有顶层（top-level）镜像。实际上，在这里我们没有办法区分一个镜像和一个只读层，所以我们提出了top-level 镜像。只有创建容器时使用的镜像或者是直接pull下来的镜像能被称为顶层（top-level）镜像，并且每一个顶层镜像下面都隐藏了多个镜像层。 </p><h4 id="docker-images-–a"><a href="#docker-images-–a" class="headerlink" title="docker images –a"></a>docker images –a</h4><p><a href="http://dockerone.com/uploads/article/20151031/6b3d2d1cae5a26961dc554fc05783b22.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115305_620.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker images –a命令列出了所有的镜像，也可以说是列出了所有的可读层。如果你想要查看某一个image-id下的所有层，可以使用docker history来查看。 </p><h4 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop "></a>docker stop <container-id></container-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/081cf8fbe8ab4dea4130ce2f25eae071.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115306_454.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker stop命令会向运行中的容器发送一个SIGTERM的信号，然后停止所有的进程。 </p><h4 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill "></a>docker kill <container-id></container-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/8aeee0c4c1134ee9d0c2200e03defcf4.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115306_977.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker kill 命令向所有运行在容器中的进程发送了一个不友好的SIGKILL信号。 </p><h4 id="docker-pause"><a href="#docker-pause" class="headerlink" title="docker pause "></a>docker pause <container-id></container-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/2b34576a2187a972d4cc1cf9346658e2.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115306_230.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker stop和docker kill命令会发送UNIX的信号给运行中的进程，docker pause命令则不一样，它利用了cgroups的特性将运行中的进程空间暂停。具体的内部原理你可以在这里找到：<a href="https://www.kernel.org/doc/Documentation/cgroups/freezer-subsystem.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Doc … m.txt</a>，但是这种方式的不足之处在于发送一个SIGTSTP信号对于进程来说不够简单易懂，以至于不能够让所有进程暂停。 </p><h4 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm "></a>docker rm <container-id></container-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/bba4521356b43813a634a0859fa53743.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115306_974.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker rm命令会移除构成容器的可读写层。注意，这个命令只能对非运行态容器执行。 </p><h4 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi "></a>docker rmi <image-id></image-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/df0fadb17158696cdce49a8e30f8c4c4.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115307_574.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker rmi 命令会移除构成镜像的一个只读层。你只能够使用docker rmi来移除最顶层（top level layer）（也可以说是镜像），你也可以使用-f参数来强制删除中间的只读层。 </p><h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit "></a>docker commit <container-id></container-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/f642149d0144c83679dd228c93a91a37.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115307_730.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker commit命令将容器的可读写层转换为一个只读层，这样就把一个容器转换成了不可变的镜像。 </p><p><a href="http://dockerone.com/uploads/article/20151103/a206a291a8d4b9c968061b853f92ad4e.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115307_969.png" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><h4 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h4><p><a href="http://dockerone.com/uploads/article/20151031/d569d50a2c6cb4cdb07eb4cfc0712ab0.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115307_796.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker build命令非常有趣，它会反复的执行多个命令。 </p><p><a href="http://dockerone.com/uploads/article/20151103/17f6091cc228e14eb151cc8909b4ab00.png" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115308_396.png" alt="9.png"></a></p><p>我们从上图可以看到，build命令根据Dockerfile文件中的FROM指令获取到镜像，然后重复地1）run（create和start）、2）修改、3）commit。在循环中的每一步都会生成一个新的层，因此许多新的层会被创建。 </p><h4 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec "></a>docker exec <running-container-id></running-container-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/91b0fd6b6b3c0d372eafbe40221835a8.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115308_659.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker exec 命令会在运行中的容器执行一个新进程。 </p><h4 id="docker-inspect-or"><a href="#docker-inspect-or" class="headerlink" title="docker inspect  or "></a>docker inspect <container-id> or <image-id></image-id></container-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/eb03a3d750a4da43fc5825d8336314c1.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115308_430.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker inspect命令会提取出容器或者镜像最顶层的元数据。 </p><h4 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save "></a>docker save <image-id></image-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/db73c5aad485bbacb3e97d0a8ddcdea4.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115309_345.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker save命令会创建一个镜像的压缩文件，这个文件能够在另外一个主机的Docker上使用。和export命令不同，这个命令为每一个层都保存了它们的元数据。这个命令只能对镜像生效。 </p><h4 id="docker-export"><a href="#docker-export" class="headerlink" title="docker export "></a>docker export <container-id></container-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/a766de204b53f10d5f56c36955b6b0ee.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115309_215.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker export命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容（译者注：expoxt后 的容器再import到Docker中，通过docker images –tree命令只能看到一个镜像；而save后的镜像则不同，它能够看到这个镜像的历史镜像）。 </p><h4 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history "></a>docker history <image-id></image-id></h4><p><a href="http://dockerone.com/uploads/article/20151031/f20de692d890a55b84ee5540c62e054e.jpg" target="_blank" rel="noopener"><img src="/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115309_191.jpg" alt=" 10张图带你深入理解Docker容器和镜像"></a></p><p>docker history命令递归地输出指定镜像的历史镜像。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;来源 | &lt;a href=&quot;http://sina.lt/gfmf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://sina.lt/gfmf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;这篇文章希望能够帮助读者深入理解Docker的命令，还有容器（container）和镜像（image）之间的区别，并深入探讨容器和运行中的容器之间的区别。 &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://dockerone.com/uploads/article/20151103/d6ad9c257d160164480b25b278f4a2ad.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;/2019/11/06/docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E5%8C%BA%E5%88%AB/20151105115301_427.png&quot; alt=&quot; 10张图带你深入理解Docker容器和镜像&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;当我对Docker技术还是一知半解的时候，我发现理解Docker的命令非常困难。于是，我花了几周的时间来学习Docker的工作原理，更确 切地说，是关于Docker统一文件系统（the union file system）的知识，然后回过头来再看Docker的命令，一切变得顺理成章，简单极了。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="持续集成" scheme="http://geoffen.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="docker" scheme="http://geoffen.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Helm模板文件chart编写语法总结</title>
    <link href="http://geoffen.github.io/2019/11/02/Helm%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6chart%E7%BC%96%E5%86%99%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://geoffen.github.io/2019/11/02/Helm模板文件chart编写语法总结/</id>
    <published>2019-11-02T02:14:06.000Z</published>
    <updated>2019-11-07T10:24:47.347Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://whmzsu.github.io/helm-doc-zh-cn/" target="_blank" rel="noopener">helm-charts用户指南</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>快速创建一个chart模板,<code>helm create mychart</code>,执行命令后本地生成一个mychart目录.</p><h2 id="chart目录结构"><a href="#chart目录结构" class="headerlink" title="chart目录结构"></a>chart目录结构</h2><ul><li>Chart.yaml: 该chart的描述文件,包括ico地址,版本信息等</li><li>vakues.yaml: 给模板文件使用的变量</li><li>charts: 依赖其他包的charts文件</li><li>requirements.yaml: 依赖的charts</li><li>README.md: 开发人员自己阅读的文件</li><li>templates: 存放k8s模板文件目录<ul><li>NOTES.txt 说明文件,helm install之后展示给用户看的内容</li><li>deployment.yaml 创建k8s资源的yaml文件</li><li>_helpers.tpl: 下划线开头的文件,可以被其他模板引用.</li></ul></li></ul><a id="more"></a><p>一个最小的chart目录,只需要包含一个Chart.yaml,和templates目录下一个k8s资源文件.如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># mychart/Chart.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">appVersion: 2.9.0</span><br><span class="line">version: 1.1.1</span><br><span class="line"></span><br><span class="line"># mychart/templates/configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: mychart-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br></pre></td></tr></table></figure><h2 id="helm模板语法"><a href="#helm模板语法" class="headerlink" title="helm模板语法"></a>helm模板语法</h2><ol><li><p>模板引用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; .Release.Name &#125;&#125;</span><br></pre></td></tr></table></figure><p>通过双括号注入,小数点开头表示从最顶层命名空间引用.</p></li><li><p>helm内置对象</p><blockquote><p>Release, release相关属性<br>Chart, Chart.yaml文件中定义的内容<br>Values, values.yaml文件中定义的内容</p></blockquote></li><li><p>模板中使用管道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">    name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">data:</span><br><span class="line"> myvalue: &quot;Hello World&quot;</span><br><span class="line"> drink: &#123;&#123; .Values.favorite.drink | repeat 5 | quote &#125;&#125;</span><br><span class="line"> food: &#123;&#123; .Values.favorite.food | upper | quote &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>if语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if PIPELINE &#125;&#125;</span><br><span class="line"># Do something</span><br><span class="line">&#123;&#123; else if OTHER PIPELINE &#125;&#125;</span><br><span class="line"># Do something else</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line"># Default case</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>操作符, and/eq/or/not</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;/* include the body of this if statement when the variable .Values.fooString exists and is set to &quot;foo&quot; */&#125;&#125;</span><br><span class="line">&#123;&#123; if and .Values.fooString (eq .Values.fooString &quot;foo&quot;) &#125;&#125;</span><br><span class="line">    &#123;&#123; ... &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;/* do not include the body of this if statement because unset variables evaluate to false and .Values.setVariable was negated with the not function. */&#125;&#125;</span><br><span class="line">&#123;&#123; if or .Values.anUnsetVariable (not .Values.aSetVariable) &#125;&#125;</span><br><span class="line">   &#123;&#123; ... &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制语句块在渲染后生成模板会多出空行,需要使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- if ...&#125;&#125;</span><br></pre></td></tr></table></figure><p>的方式消除此空行.如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  &#123;&#123;- if eq .Values.favorite.drink &quot;coffee&quot;&#125;&#125;</span><br><span class="line">  mug: true</span><br><span class="line">  &#123;&#123;- end&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>引入相对命名空间,with命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  &#123;&#123;- with .Values.favorite &#125;&#125;</span><br><span class="line">  drink: &#123;&#123; .drink | default &quot;tea&quot; | quote &#125;&#125;</span><br><span class="line">  food: &#123;&#123; .food | upper | quote &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>range命令实现循环,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># values.yaml</span><br><span class="line">favorite:</span><br><span class="line">  drink: coffee</span><br><span class="line">  food: pizza</span><br><span class="line">pizzaToppings:</span><br><span class="line">  - mushrooms</span><br><span class="line">  - cheese</span><br><span class="line">  - peppers</span><br><span class="line">  - onions</span><br><span class="line"></span><br><span class="line">#configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  toppings: |-</span><br><span class="line">    &#123;&#123;- range .Values.pizzaToppings &#125;&#125;</span><br><span class="line">    - &#123;&#123; . &#125;&#125;</span><br><span class="line">    # .表示range的命令空间下的取值</span><br><span class="line">    &#123;&#123;- end &#125;&#125;</span><br><span class="line">    &#123;&#123;- range $key, $val := .Values.favorite &#125;&#125;</span><br><span class="line">    &#123;&#123; $key &#125;&#125;: &#123;&#123; $val | quote &#125;&#125;</span><br><span class="line">    &#123;&#123;- end&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>变量赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ApiVersion: v1</span><br><span class="line">Kind: ConfigMap</span><br><span class="line">Metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">Data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  # 由于下方的with语句引入相对命令空间,无法通过.Release引入,提前定义relname变量</span><br><span class="line">  &#123;&#123;- $relname := .Release.Name -&#125;&#125;</span><br><span class="line">  &#123;&#123;- with .Values.favorite &#125;&#125;</span><br><span class="line">  food: &#123;&#123; .food &#125;&#125;</span><br><span class="line">  release: &#123;&#123; $relname &#125;&#125;</span><br><span class="line">  # 或者可以使用$符号,引入全局命名空间</span><br><span class="line">  release: &#123;&#123; $.Release.Name &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>公共模板,define定义,template引入,在templates目录中默认下划线_开头的文件为公共模板(_helpers.tpl)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># _helpers.tpl文件</span><br><span class="line">&#123;&#123;- define &quot;mychart.labels&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    generator: helm</span><br><span class="line">    date: &#123;&#123; now | htmlDate &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br><span class="line"># configmap.yaml文件</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">  &#123;&#123;- template &quot;mychart.labels&quot; &#125;&#125;</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></li><li><p>template语句的升级版本include,template是语句无法在后面接管道符来对引入变量做定义,<br>include实现了此功能.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># _helpers.tpl文件</span><br><span class="line">&#123;&#123;- define &quot;mychart.app&quot; -&#125;&#125;</span><br><span class="line">app_name: &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line">app_version: &quot;&#123;&#123; .Chart.Version &#125;&#125;+&#123;&#123; .Release.Time.Seconds &#125;&#125;&quot;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line"></span><br><span class="line"># configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">  labels:</span><br><span class="line">    &#123;&#123;- include &quot;mychart.app&quot; . | nindent 4 &#125;&#125;</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  &#123;&#123;- range $key, $val := .Values.favorite &#125;&#125;</span><br><span class="line">  &#123;&#123; $key &#125;&#125;: &#123;&#123; $val | quote &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br><span class="line">  &#123;&#123;- include &quot;mychart.app&quot; . | nindent 2 &#125;&#125;</span><br><span class="line"></span><br><span class="line"># 如果使用template只能手动空格,不能使用管道后的nindent函数来做缩进</span><br></pre></td></tr></table></figure></li><li><p>一个坑</p><blockquote><p><code>helm install stable/drupal --set image=my-registry/drupal:0.1.0 --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt] --set livenessProbe.httpGet=null&lt;br/&gt;</code></p></blockquote></li></ol><p>livenessProbe在values.yaml中定义了httpGet,需要手动设置为null,然后设置exec的探针.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://whmzsu.github.io/helm-doc-zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;helm-charts用户指南&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;快速创建一个chart模板,&lt;code&gt;helm create mychart&lt;/code&gt;,执行命令后本地生成一个mychart目录.&lt;/p&gt;&lt;h2 id=&quot;chart目录结构&quot;&gt;&lt;a href=&quot;#chart目录结构&quot; class=&quot;headerlink&quot; title=&quot;chart目录结构&quot;&gt;&lt;/a&gt;chart目录结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Chart.yaml: 该chart的描述文件,包括ico地址,版本信息等&lt;/li&gt;
&lt;li&gt;vakues.yaml: 给模板文件使用的变量&lt;/li&gt;
&lt;li&gt;charts: 依赖其他包的charts文件&lt;/li&gt;
&lt;li&gt;requirements.yaml: 依赖的charts&lt;/li&gt;
&lt;li&gt;README.md: 开发人员自己阅读的文件&lt;/li&gt;
&lt;li&gt;templates: 存放k8s模板文件目录&lt;ul&gt;
&lt;li&gt;NOTES.txt 说明文件,helm install之后展示给用户看的内容&lt;/li&gt;
&lt;li&gt;deployment.yaml 创建k8s资源的yaml文件&lt;/li&gt;
&lt;li&gt;_helpers.tpl: 下划线开头的文件,可以被其他模板引用.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="持续集成" scheme="http://geoffen.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="helm" scheme="http://geoffen.github.io/tags/helm/"/>
    
      <category term="k8s" scheme="http://geoffen.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes排错指南</title>
    <link href="http://geoffen.github.io/2019/11/02/k8s-troubleshooting/"/>
    <id>http://geoffen.github.io/2019/11/02/k8s-troubleshooting/</id>
    <published>2019-11-02T00:12:50.000Z</published>
    <updated>2019-11-07T10:24:47.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://github.com/imroc/kubernetes-troubleshooting-guide" target="_blank" rel="noopener">https://github.com/imroc/kubernetes-troubleshooting-guide</a></p></blockquote><h2 id="分析-ExitCode-定位-Pod-异常退出原因"><a href="#分析-ExitCode-定位-Pod-异常退出原因" class="headerlink" title="分析 ExitCode 定位 Pod 异常退出原因"></a>分析 ExitCode 定位 Pod 异常退出原因</h2><p>使用 <code>kubectl describe pod &lt;pod name&gt;</code> 查看异常 pod 的状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Containers:</span><br><span class="line">  kubedns:</span><br><span class="line">    Container ID:  docker://5fb8adf9ee62afc6d3f6f3d9590041818750b392dff015d7091eaaf99cf1c945</span><br><span class="line">    Image:         ccr.ccs.tencentyun.com/library/kubedns-amd64:1.14.4</span><br><span class="line">    Image ID:      docker-pullable://ccr.ccs.tencentyun.com/library/kubedns-amd64@sha256:40790881bbe9ef4ae4ff7fe8b892498eecb7fe6dcc22661402f271e03f7de344</span><br><span class="line">    Ports:         10053/UDP, 10053/TCP, 10055/TCP</span><br><span class="line">    Host Ports:    0/UDP, 0/TCP, 0/TCP</span><br><span class="line">    Args:</span><br><span class="line">      --domain=cluster.local.</span><br><span class="line">      --dns-port=10053</span><br><span class="line">      --config-dir=/kube-dns-config</span><br><span class="line">      --v=2</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Tue, 27 Aug 2019 10:58:49 +0800</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       Error</span><br><span class="line">      Exit Code:    255</span><br><span class="line">      Started:      Tue, 27 Aug 2019 10:40:42 +0800</span><br><span class="line">      Finished:     Tue, 27 Aug 2019 10:58:27 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  1</span><br></pre></td></tr></table></figure><a id="more"></a><p>在容器列表里看 <code>Last State</code> 字段，其中 <code>ExitCode</code> 即程序上次退出时的状态码，如果不为 0，表示异常退出，我们可以分析下原因。</p><h3 id="退出状态码的区间"><a href="#退出状态码的区间" class="headerlink" title="退出状态码的区间"></a>退出状态码的区间</h3><ul><li>必须在 0-255 之间</li><li>0 表示正常退出</li><li>外界中断将程序退出的时候状态码区间在 129-255，(操作系统给程序发送中断信号，比如 <code>kill -9</code> 是 <code>SIGKILL</code>，<code>ctrl+c</code> 是 <code>SIGINT</code>)</li><li>一般程序自身原因导致的异常退出状态区间在 1-128 (这只是一般约定，程序如果一定要用129-255的状态码也是可以的)</li></ul><p>假如写代码指定的退出状态码时不在 0-255 之间，例如: <code>exit(-1)</code>，这时会自动做一个转换，最终呈现的状态码还是会在 0-255 之间。我们把状态码记为 <code>code</code></p><ul><li>当指定的退出时状态码为负数，那么转换公式如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">256 - (|code| % 256)</span><br></pre></td></tr></table></figure><ul><li>当指定的退出时状态码为正数，那么转换公式如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code % 256</span><br></pre></td></tr></table></figure><h3 id="常见异常状态码"><a href="#常见异常状态码" class="headerlink" title="常见异常状态码"></a>常见异常状态码</h3><ul><li><p>137 (被  <code>SIGKILL</code> 中断信号杀死)</p><ul><li><p>此状态码一般是因为 pod 中容器内存达到了它的资源限制(<code>resources.limits</code>)，一般是内存溢出(OOM)，CPU达到限制只需要不分时间片给程序就可以。因为限制资源是通过 linux 的 cgroup 实现的，所以 cgroup 会将此容器强制杀掉，类似于 <code>kill -9</code>，此时在 <code>describe pod</code> 中可以看到 Reason 是 <code>OOMKilled</code></p></li><li><p>还可能是宿主机本身资源不够用了(OOM)，内核会选取一些进程杀掉来释放内存</p></li><li><p>不管是 cgroup 限制杀掉进程还是因为节点机器本身资源不够导致进程死掉，都可以从系统日志中找到记录:</p><blockquote><p>ubuntu 的系统日志在 <code>/var/log/syslog</code>，centos 的系统日志在 <code>/var/log/messages</code>，都可以用 <code>journalctl -k</code> 来查看系统日志</p></blockquote></li><li><p>也可能是 livenessProbe (存活检查) 失败，kubelet 杀死的 pod</p></li><li><p>还可能是被恶意木马进程杀死</p></li></ul></li><li><p>1 和 255</p><ul><li>这种可能是一般错误，具体错误原因只能看容器日志，因为很多程序员写异常退出时习惯用 <code>exit(1)</code> 或 <code>exit(-1)</code>，-1 会根据转换规则转成 255</li></ul></li></ul><h3 id="状态码参考"><a href="#状态码参考" class="headerlink" title="状态码参考"></a>状态码参考</h3><p>这里罗列了一些状态码的含义：<a href="http://tldp.org/LDP/abs/html/exitcodes.html" target="_blank" rel="noopener">Appendix E. Exit Codes With Special Meanings</a></p><h3 id="Linux-标准中断信号"><a href="#Linux-标准中断信号" class="headerlink" title="Linux 标准中断信号"></a>Linux 标准中断信号</h3><p>Linux 程序被外界中断时会发送中断信号，程序退出时的状态码就是中断信号值加上 128 得到的，比如 <code>SIGKILL</code> 的中断信号值为 9，那么程序退出状态码就为 9+128=137。以下是标准信号值参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Signal     Value     Action   Comment</span><br><span class="line">──────────────────────────────────────────────────────────────────────</span><br><span class="line">SIGHUP        1       Term    Hangup detected on controlling terminal</span><br><span class="line">                                     or death of controlling process</span><br><span class="line">SIGINT        2       Term    Interrupt from keyboard</span><br><span class="line">SIGQUIT       3       Core    Quit from keyboard</span><br><span class="line">SIGILL        4       Core    Illegal Instruction</span><br><span class="line">SIGABRT       6       Core    Abort signal from abort(3)</span><br><span class="line">SIGFPE        8       Core    Floating-point exception</span><br><span class="line">SIGKILL       9       Term    Kill signal</span><br><span class="line">SIGSEGV      11       Core    Invalid memory reference</span><br><span class="line">SIGPIPE      13       Term    Broken pipe: write to pipe with no</span><br><span class="line">                                     readers; see pipe(7)</span><br><span class="line">SIGALRM      14       Term    Timer signal from alarm(2)</span><br><span class="line">SIGTERM      15       Term    Termination signal</span><br><span class="line">SIGUSR1   30,10,16    Term    User-defined signal 1</span><br><span class="line">SIGUSR2   31,12,17    Term    User-defined signal 2</span><br><span class="line">SIGCHLD   20,17,18    Ign     Child stopped or terminated</span><br><span class="line">SIGCONT   19,18,25    Cont    Continue if stopped</span><br><span class="line">SIGSTOP   17,19,23    Stop    Stop process</span><br><span class="line">SIGTSTP   18,20,24    Stop    Stop typed at terminal</span><br><span class="line">SIGTTIN   21,21,26    Stop    Terminal input for background process</span><br><span class="line">SIGTTOU   22,22,27    Stop    Terminal output for background process</span><br></pre></td></tr></table></figure><h3 id="C-C-退出状态码"><a href="#C-C-退出状态码" class="headerlink" title="C/C++ 退出状态码"></a>C/C++ 退出状态码</h3><p><code>/usr/include/sysexits.h</code> 试图将退出状态码标准化(仅限 C/C++):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#define EX_OK           0       /* successful termination */</span><br><span class="line"></span><br><span class="line">#define EX__BASE        64      /* base value for error messages */</span><br><span class="line"></span><br><span class="line">#define EX_USAGE        64      /* command line usage error */</span><br><span class="line">#define EX_DATAERR      65      /* data format error */</span><br><span class="line">#define EX_NOINPUT      66      /* cannot open input */</span><br><span class="line">#define EX_NOUSER       67      /* addressee unknown */</span><br><span class="line">#define EX_NOHOST       68      /* host name unknown */</span><br><span class="line">#define EX_UNAVAILABLE  69      /* service unavailable */</span><br><span class="line">#define EX_SOFTWARE     70      /* internal software error */</span><br><span class="line">#define EX_OSERR        71      /* system error (e.g., can&apos;t fork) */</span><br><span class="line">#define EX_OSFILE       72      /* critical OS file missing */</span><br><span class="line">#define EX_CANTCREAT    73      /* can&apos;t create (user) output file */</span><br><span class="line">#define EX_IOERR        74      /* input/output error */</span><br><span class="line">#define EX_TEMPFAIL     75      /* temp failure; user is invited to retry */</span><br><span class="line">#define EX_PROTOCOL     76      /* remote error in protocol */</span><br><span class="line">#define EX_NOPERM       77      /* permission denied */</span><br><span class="line">#define EX_CONFIG       78      /* configuration error */</span><br><span class="line"></span><br><span class="line">#define EX__MAX 78      /* maximum listed value */</span><br></pre></td></tr></table></figure><h2 id="使用-systemtap-定位疑难杂症"><a href="#使用-systemtap-定位疑难杂症" class="headerlink" title="使用 systemtap 定位疑难杂症"></a>使用 systemtap 定位疑难杂症</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>安装 systemtap:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y systemtap</span><br></pre></td></tr></table></figure><p>运行 <code>stap-prep</code> 检查还有什么需要安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ stap-prep</span><br><span class="line">Please install linux-headers-4.4.0-104-generic</span><br><span class="line">You need package linux-image-4.4.0-104-generic-dbgsym but it does not seem to be available</span><br><span class="line"> Ubuntu -dbgsym packages are typically in a separate repository</span><br><span class="line"> Follow https://wiki.ubuntu.com/DebuggingProgramCrash to add this repository</span><br><span class="line"></span><br><span class="line">apt install -y linux-headers-4.4.0-104-generic</span><br></pre></td></tr></table></figure><p>提示需要 dbgsym 包但当前已有软件源中并不包含，需要使用第三方软件源安装，下面是 dbgsym 安装方法(参考官方wiki: <a href="https://wiki.ubuntu.com/Kernel/Systemtap" target="_blank" rel="noopener">https://wiki.ubuntu.com/Kernel/Systemtap</a>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys C8CAB6595FDFF622</span><br><span class="line"></span><br><span class="line">codename=$(lsb_release -c | awk  &apos;&#123;print $2&#125;&apos;)</span><br><span class="line">sudo tee /etc/apt/sources.list.d/ddebs.list &lt;&lt; EOF</span><br><span class="line">deb http://ddebs.ubuntu.com/ $&#123;codename&#125;      main restricted universe multiverse</span><br><span class="line">deb http://ddebs.ubuntu.com/ $&#123;codename&#125;-security main restricted universe multiverse</span><br><span class="line">deb http://ddebs.ubuntu.com/ $&#123;codename&#125;-updates  main restricted universe multiverse</span><br><span class="line">deb http://ddebs.ubuntu.com/ $&#123;codename&#125;-proposed main restricted universe multiverse</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>配置好源后再运行下 <code>stap-prep</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ stap-prep</span><br><span class="line">Please install linux-headers-4.4.0-104-generic</span><br><span class="line">Please install linux-image-4.4.0-104-generic-dbgsym</span><br></pre></td></tr></table></figure><p>提示需要装这两个包，我们安装一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y linux-image-4.4.0-104-generic-dbgsym</span><br><span class="line">apt install -y linux-headers-4.4.0-104-generic</span><br></pre></td></tr></table></figure><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p>安装 systemtap:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y systemtap</span><br></pre></td></tr></table></figure><p>默认没装 <code>debuginfo</code>，我们需要装一下，添加软件源 <code>/etc/yum.repos.d/CentOS-Debug.repo</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[debuginfo]</span><br><span class="line">name=CentOS-$releasever - DebugInfo</span><br><span class="line">baseurl=http://debuginfo.centos.org/$releasever/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">protect=1</span><br><span class="line">priority=1</span><br></pre></td></tr></table></figure><p>执行 <code>stap-prep</code> (会安装 <code>kernel-debuginfo</code>)</p><p>最后检查确保 <code>kernel-debuginfo</code> 和 <code>kernel-devel</code> 均已安装并且版本跟当前内核版本相同，如果有多个版本，就删除跟当前内核版本不同的包(通过<code>uname -r</code>查看当前内核版本)。</p><p>重点检查是否有多个版本的 <code>kernel-devel</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qa | grep kernel-devel</span><br><span class="line">kernel-devel-3.10.0-327.el7.x86_64</span><br><span class="line">kernel-devel-3.10.0-514.26.2.el7.x86_64</span><br><span class="line">kernel-devel-3.10.0-862.9.1.el7.x86_64</span><br></pre></td></tr></table></figure><p>如果存在多个，保证只留跟当前内核版本相同的那个，假设当前内核版本是 <code>3.10.0-862.9.1.el7.x86_64</code>，那么使用 rpm 删除多余的版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e kernel-devel-3.10.0-327.el7.x86_64 kernel-devel-3.10.0-514.26.2.el7.x86_64</span><br></pre></td></tr></table></figure><h3 id="使用-systemtap-揪出杀死容器的真凶"><a href="#使用-systemtap-揪出杀死容器的真凶" class="headerlink" title="使用 systemtap 揪出杀死容器的真凶"></a>使用 systemtap 揪出杀死容器的真凶</h3><p>Pod 莫名其妙被杀死? 可以使用 systemtap 来监视进程的信号发送，原理是 systemtap 将脚本翻译成 C 代码然后调用 gcc 编译成 linux 内核模块，再通过 <code>modprobe</code> 加载到内核，根据脚本内容在内核做各种 hook，在这里我们就 hook 一下信号的发送，找出是谁 kill 掉了容器进程。</p><p>首先，找到被杀死的 pod 又自动重启的容器的当前 pid，describe 一下 pod:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">Container ID:  docker://5fb8adf9ee62afc6d3f6f3d9590041818750b392dff015d7091eaaf99cf1c945</span><br><span class="line">......</span><br><span class="line">Last State:     Terminated</span><br><span class="line">  Reason:       Error</span><br><span class="line">  Exit Code:    137</span><br><span class="line">  Started:      Thu, 05 Sep 2019 19:22:30 +0800</span><br><span class="line">  Finished:     Thu, 05 Sep 2019 19:33:44 +0800</span><br></pre></td></tr></table></figure><p>拿到容器 id 反查容器的主进程 pid:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect -f &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; 5fb8adf9ee62afc6d3f6f3d9590041818750b392dff015d7091eaaf99cf1c945</span><br><span class="line">7942</span><br></pre></td></tr></table></figure><p>通过 <code>Exit Code</code> 可以看出容器上次退出的状态码，如果进程是被外界中断信号杀死的，退出状态码将在 129-255 之间，137 表示进程是被 SIGKILL 信号杀死的，但我们从这里并不能看出是被谁杀死的。</p><p>如果问题可以复现，我们可以使用下面的 systemtap 脚本来监视容器是被谁杀死的(保存为<code>sg.stp</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">global target_pid = 7942</span><br><span class="line">probe signal.send&#123;</span><br><span class="line">  if (sig_pid == target_pid) &#123;</span><br><span class="line">    printf(&quot;%s(%d) send %s to %s(%d)\n&quot;, execname(), pid(), sig_name, pid_name, sig_pid);</span><br><span class="line">    printf(&quot;parent of sender: %s(%d)\n&quot;, pexecname(), ppid())</span><br><span class="line">    printf(&quot;task_ancestry:%s\n&quot;, task_ancestry(pid2task(pid()), 1));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>变量 <code>pid</code> 的值替换为查到的容器主进程 pid</li></ul><p>运行脚本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stap sg.stp</span><br></pre></td></tr></table></figure><p>当容器进程被杀死时，脚本捕捉到事件，执行输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkill(23549) send SIGKILL to server(7942)</span><br><span class="line">parent of sender: bash(23495)</span><br><span class="line">task_ancestry:swapper/0(0m0.000000000s)=&gt;systemd(0m0.080000000s)=&gt;vGhyM0(19491m2.579563677s)=&gt;sh(33473m38.074571885s)=&gt;bash(33473m38.077072025s)=&gt;bash(33473m38.081028267s)=&gt;bash(33475m4.817798337s)=&gt;pkill(33475m5.202486630s)</span><br></pre></td></tr></table></figure><p>通过观察 <code>task_ancestry</code> 可以看到杀死进程的所有父进程，在这里可以看到有个叫 <code>vGhyM0</code> 的奇怪进程名，通常是中了木马，需要安全专家介入继续排查。</p><h2 id="非root用户执行docker命令时提示permission-denied"><a href="#非root用户执行docker命令时提示permission-denied" class="headerlink" title="非root用户执行docker命令时提示permission denied"></a>非root用户执行docker命令时提示permission denied</h2><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>摘自docker mannual上的一段话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manage Docker as a non-root user</span><br><span class="line"></span><br><span class="line">The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The docker daemon always runs as the root user.</span><br><span class="line"></span><br><span class="line">If you don’t want to use sudo when you use the docker command, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket read/writable by the docker group.</span><br></pre></td></tr></table></figure><p>大概的意思就是：docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。</p><h3 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h3><p>使用sudo获取管理员权限，运行docker命令</p><h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h3><p>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker     #添加docker用户组</span><br><span class="line">sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中</span><br><span class="line">newgrp docker     #更新用户组</span><br><span class="line">docker ps    #测试docker命令是否可以使用sudo正常使用</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://github.com/imroc/kubernetes-troubleshooting-guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/imroc/kubernetes-troubleshooting-guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;分析-ExitCode-定位-Pod-异常退出原因&quot;&gt;&lt;a href=&quot;#分析-ExitCode-定位-Pod-异常退出原因&quot; class=&quot;headerlink&quot; title=&quot;分析 ExitCode 定位 Pod 异常退出原因&quot;&gt;&lt;/a&gt;分析 ExitCode 定位 Pod 异常退出原因&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;kubectl describe pod &amp;lt;pod name&amp;gt;&lt;/code&gt; 查看异常 pod 的状态:&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Containers:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  kubedns:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Container ID:  docker://5fb8adf9ee62afc6d3f6f3d9590041818750b392dff015d7091eaaf99cf1c945&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Image:         ccr.ccs.tencentyun.com/library/kubedns-amd64:1.14.4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Image ID:      docker-pullable://ccr.ccs.tencentyun.com/library/kubedns-amd64@sha256:40790881bbe9ef4ae4ff7fe8b892498eecb7fe6dcc22661402f271e03f7de344&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ports:         10053/UDP, 10053/TCP, 10055/TCP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Host Ports:    0/UDP, 0/TCP, 0/TCP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Args:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      --domain=cluster.local.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      --dns-port=10053&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      --config-dir=/kube-dns-config&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      --v=2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    State:          Running&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Started:      Tue, 27 Aug 2019 10:58:49 +0800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Last State:     Terminated&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Reason:       Error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Exit Code:    255&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Started:      Tue, 27 Aug 2019 10:40:42 +0800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Finished:     Tue, 27 Aug 2019 10:58:27 +0800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ready:          True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Restart Count:  1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="持续集成" scheme="http://geoffen.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="docker" scheme="http://geoffen.github.io/tags/docker/"/>
    
      <category term="k8s" scheme="http://geoffen.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo置顶问题</title>
    <link href="http://geoffen.github.io/2019/11/01/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://geoffen.github.io/2019/11/01/解决Hexo置顶问题/</id>
    <published>2019-11-01T08:55:34.000Z</published>
    <updated>2019-11-07T10:24:47.431Z</updated>
    
    <content type="html"><![CDATA[<p>为了防止每次更新、安装都要修改代码，现在可以直接从仓库里安装了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index --save</span><br><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。</p><a id="more"></a><hr><p>考虑到之前的博客有置顶文章，所以需要置顶功能。</p><p><code>Google</code>了一下解决方案，发现了本博客主题是支持置顶功能的，在需要置顶的<code>Front-matter</code>中加上<code>top: true</code>即可。试了一下，能置顶。。只是文章置顶在某一页而不是首页。。</p><p>期间看到了<code>Pacman</code>主题支持置顶，需要在<code>_config.yml</code>中配置好需要置顶的文章，略麻烦。</p><p>然后看到了<code>next</code>主题支持置顶，在博文<code>front-matter</code>中加上<code>sticky: Sticky</code>即可置顶，根据<code>Sticky</code>的大小来决定置顶顺序。</p><p>想实现<code>next</code>主题那样的功能，参考了一篇博文<a href="http://ziorix.com/2015/09/09/%E6%B7%BB%E5%8A%A0Hexo%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD%E7%9A%84%E6%93%8D%E8%9B%8B3%E5%B0%8F%E6%97%B6/" target="_blank" rel="noopener">添加Hexo置顶功能的操蛋3小时</a>，在<code>hexo-generator-index</code>中增加比较函数比较<code>top</code>值，我试了一下<code>Bug</code>还是有的，置顶文章后文章日期有些会乱掉（比较函数条件比较少）。</p><p>我自己写了一个比较函数，也有问题，后来查了一下<code>Javascript</code>的<code>sort</code>函数，其比较函数和<code>C++</code>的完全不同= =</p><p><code>C++</code>的比较函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;bool cmp(T a, T b) &#123;    return  a &lt; b; // 升序，降序的话就 b &gt; a&#125;</span><br></pre></td></tr></table></figure><p>而<code>Javascript</code>的比较函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp(var a, var b) &#123;    return  a - b; // 升序，降序的话就 b - a&#125;</span><br></pre></td></tr></table></figure><p>用了<code>C++</code>的比较函数，结果当然会出问题，期间都想重写<code>js</code>的排序函数了。。经过修改，已经能完美置顶了，只需要在<code>front-matter</code>中设置需要置顶文章的<code>top</code>值，将会根据<code>top</code>值大小来选择置顶顺序。（大的在前面）</p><p>以下是最终的<code>node_modules/hexo-generator-index/lib/generator.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var pagination = require(&apos;hexo-pagination&apos;);</span><br><span class="line">module.exports = function(locals)&#123;</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; // 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">  var paginationDir = config.pagination_dir || &apos;page&apos;;</span><br><span class="line">  return pagination(&apos;&apos;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&apos;index&apos;, &apos;archive&apos;],</span><br><span class="line">    format: paginationDir + &apos;/%d/&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了防止每次更新、安装都要修改代码，现在可以直接从仓库里安装了：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm uninstall hexo-generator-index --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install hexo-generator-index-pin-top --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然后在需要置顶的文章的&lt;code&gt;Front-matter&lt;/code&gt;中加上&lt;code&gt;top: true&lt;/code&gt;即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://geoffen.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://geoffen.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>K8S部署简介</title>
    <link href="http://geoffen.github.io/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/"/>
    <id>http://geoffen.github.io/2019/10/31/K8S部署简介/</id>
    <published>2019-10-31T12:01:22.000Z</published>
    <updated>2019-11-01T08:06:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当你在Module2创建了一个Deployment之后，Kuebernetes创建会创建一个<strong>Pod</strong>去托管你的应用实例。一个Pod是一种Kubernetes的抽象，这种抽象代表一组一个或者多个应用的容器（例如Docker或者rkt）,和一些这些容器间的共享资源。<br> 这些资源包括：</p><ul><li>共享存储，例如Volumes</li><li>网络，例如一个唯一的集群IP地址</li><li>关于运行中的每个容器的详细信息，例如容器image版本，容器运行端口</li></ul><a id="more"></a><p><strong>Pod</strong></p><p>一个Pod包括一个指定的应用的“逻辑主机”，能够包含不同的彼此紧密耦合的应用容器。例如，一个Pod也许既包括运行了Nodejs应用的容器，又包括用于提供由Node.js Web服务器发布的数据的不同容器。Pod中的容器共享IP地址和端口空间，他们经常被协同定位和协同调度，而且可以运行在相同Node的共享上下文。</p><p>Pods是kubernetes平台的最小单元。当我们在Kubernetes创建了一个部署的时候，Deployment创建内部带有容器的Pods(而不是直接创建容器)。每个Pod与调度它的Node都是强关联的，只有终止或者删除Pod才会销毁。一旦Node发生异常，会从集群上对的其他可用Nodes调取相同的Pod。</p><p>总结：</p><ul><li>Pods</li><li>Nodes</li><li>Kubectl主要命令</li></ul><blockquote><p>Pod是一个包含应用容器（Docker或者rkt）,内部共享存储（volumes），IP地址和它们的运行信息的集合。</p></blockquote><p><strong>Nodes</strong><br> 一个Pod通常运行在一个Node上。一个Node是一个在Kubernetes上的工作机器，既可以是虚拟机也可以是物理实体机，依赖于整个集群。每个Node都被Master管理着。一个Node可以有多个pod，而且Kubernetes主站可以做集群内部的跨Nodes的自动调度。主站的自动化调度考虑了每个节点的可用资源。</p><p>每个Kubernetes节点至少运行：</p><ul><li>Kubelet ，一个负责k8s的Master与Node之间通信的进程；它管理着Pods和运行在机器上的容器。</li><li>一个运行时容器，例如Docker，rkt，负责从源端拉取容器的image，解压容器，运行程序。</li></ul><blockquote><p>如果容器之间是紧耦合并且需要分享类似硬盘之类的资源的话，则只能将容器安排在一个Pod的。</p></blockquote><p><strong>kubectl</strong></p><p>kubectl问题的解决办法<br> 在单元二中，你使用了Kubectl命令行接口。第三单元中你将继续使用它取获取部署的应用的信息和他们的环境的信息。kubectl最常用的操作如下：</p><ul><li>kubectl get -列举资源</li><li>kubectl describe -展示资源的细节信息</li><li>kubectl logs -在pod中打印一个容器的日志</li><li>kubectl exec -在pod中执行一个命令</li></ul><p>当应用被部署的时候，你能够使用这些命令去找问题，去看他们当前的状态是什么，他们运行在哪里，以及他们的详细配置是什么。<br> 现在我们知道了更多集群组件和命令行的信息，让我们一起来探索的应用吧。</p><blockquote><p>一个node指的是一台k8s上的工作机，可以是VM，也可以是物理机，这取决于开发k8s集群是VM集群还是物理机集群。多个Pod可以运行在同一个Node。</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>一、什么是Pod</strong><br>kubernetes中的一切都可以理解为是一种资源对象，pod，rc，service，都可以理解是 一种资源对象。pod的组成示意图如下，由一个叫”pause“的根容器，加上一个或多个用户自定义的容器构造。pause的状态带便了这一组容器的状态，pod里多个业务容器共享pod的Ip和数据卷。在kubernetes环境下，pod是容器的载体，所有的容器都是在pod中被管理，一个或多个容器放在pod里作为一个单元方便管理。</p><p>pod是kubernetes可以部署和管理的最小单元，如果想要运行一个容器，先要为这个容器创建一个pod。同时一个pod也可以包含多个容器，之所以多个容器包含在一个pod里，往往是由于业务上的紧密耦合。【<strong>需要注意】</strong>这里说的场景都非必须把不同的容器放在同一个pod里，但是这样往往更便于管理，甚至后面会讲到的，紧密耦合的业务容器放置在同一个容器里通信效率更高。具体怎么使用还要看实际情况,综合权衡。</p><p>在Kubrenetes集群中Pod有如下两种使用方式：<br><strong>a）</strong>一个Pod中运行一个容器。这是最常见用法。在这种方式中，你可以把Pod想象成是单个容器的封装，kuberentes管理的是Pod而不是直接管理容器。<br><strong>b）</strong>在一个Pod中同时运行多个容器。当多个应用之间是紧耦合的关系时，可以将多个应用一起放在一个Pod中，同个Pod中的多个容器之间互相访问可以通过localhost来通信（可以把Pod理解成一个虚拟机，共享网络和存储卷）。也就是说一个Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个Pod中的容器可以互相协作成为一个service单位 (即一个容器共享文件），另一个“sidecar”容器来更新这些文件。Pod将这些容器的存储资源作为一个实体来管理。</p><p>就像每个应用容器，pod被认为是临时实体。在Pod的生命周期中，pod被创建后，被分配一个唯一的ID（UID），调度到节点上，并一致维持期望的状态直到被终结（根据重启策略）或者被删除。如果node死掉了，分配到了这个node上的pod，在经过一个超时时间后会被重新调度到其他node节点上。一个给定的pod（如UID定义的）不会被“重新调度”到新的节点上，而是被一个同样的pod取代，如果期望的话甚至可以是相同的名字，但是会有一个新的UID（查看replication controller获取详情）。</p><p><strong>kubernetes为什么使用pod作为最小单元，而不是container</strong><br>直接部署一个容器看起来更简单，但是这里也有更好的原因为什么在容器基础上抽象一层呢？根本原因是为了管理容器，kubernetes需要更多的信息，比如重启策略，它定义了容器终止后要采取的策略;或者是一个可用性探针，从应用程序的角度去探测是否一个进程还存活着。基于这些原因，kubernetes架构师决定使用一个新的实体，也就是pod，而不是重载容器的信息添加更多属性，用来在逻辑上包装一个或者多个容器的管理所需要的信息。</p><p><strong>kubernetes为什么允许一个pod里有多个容器</strong><br>pod里的容器运行在一个逻辑上的”主机”上，它们使用相同的网络名称空间 (即同一pod里的容器使用相同的ip和相同的端口段区间) 和相同的IPC名称空间。它们也可以共享存储卷。这些特性使它们可以更有效的通信，并且pod可以使你把紧密耦合的应用容器作为一个单元来管理。也就是说当多个应用之间是紧耦合关系时，可以将多个应用一起放在一个Pod中，同个Pod中的多个容器之间互相访问可以通过localhost来通信（可以把Pod理解成一个虚拟机，共享网络和存储卷）。</p><p>因此当一个应用如果需要多个运行在同一主机上的容器时，为什么不把它们放在同一个容器里呢?首先，这样何故违反了一个容器只负责一个应用的原则。这点非常重要，如果我们把多个应用放在同一个容器里，这将使解决问题变得非常麻烦，因为它们的日志记录混合在了一起，并且它们的生命周期也很难管理。因此一个应用使用多个容器将更简单，更透明，并且使应用依赖解偶。并且粒度更小的容器更便于不同的开发团队共享和复用。</p><p><strong>【需要注意】</strong>这里说到为了解偶把应用分别放在不同容器里，前面我们也强调为了便于管理管紧耦合的应用把它们的容器放在同一个pod里。一会<strong>强调耦合</strong>，一个<strong>强调解偶</strong>看似矛盾，实际上普遍存在，高内聚低耦合是我们的追求，然而一个应用的业务逻辑模块不可能完全完独立不存在耦合，这就需要我们从实际上来考量，做出决策。</p><p>因为，虽然可以使用一个pod来承载一个多层应用，但是更建议使用不同的pod来承载不同的层，因这这样你可以为每一个层单独扩容并且把它们分布到集群的不同节点上。</p><p><strong>Pod中如何管理多个容器</strong><br>Pod中可以同时运行多个进程（作为容器运行）协同工作，同一个Pod中的容器会自动的分配到同一个 node 上，同一个Pod中的容器共享资源、网络环境和依赖，它们总是被同时调度。需要注意：一个Pod中同时运行多个容器是一种比较高级的用法。只有当你的容器需要紧密配合协作的时候才考虑用这种模式。</p><p>Pod中共享的环境包括Linux的namespace，cgroup和其他可能的隔绝环境，这一点跟Docker容器一致。在Pod的环境中，每个容器中可能还有更小的子隔离环境。Pod中的容器共享IP地址和端口号，它们之间可以通过localhost互相发现。它们之间可以通过进程间通信，需要明白的是同一个Pod下的容器是通过lo网卡进行通信。例如SystemV信号或者POSIX共享内存。不同Pod之间的容器具有不同的IP地址，不能直接通过IPC通信。Pod中的容器也有访问共享volume的权限，这些volume会被定义成pod的一部分并挂载到应用容器的文件系统中。</p><p><strong>总而言之。Pod中可以共享两种资源：网络 和 存储</strong><br><strong>1.</strong> 网络：每个Pod都会被分配一个唯一的IP地址。Pod中的所有容器共享网络空间，包括IP地址和端口。Pod内部的容器可以使用localhost互相通信。Pod中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）。<br><strong>2.</strong> 存储：可以Pod指定多个共享的Volume。Pod中的所有容器都可以访问共享的volume。Volume也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失。</p><p><strong>容器的依赖关系和启动顺序</strong><br>当前,同一个pod里的所有容器都是并行启动并且没有办法确定哪一个容器必须早于哪一个容器启动。如果要想确保第一个容器早于第二个容器启动，那么就要使用到”init container”了。</p><p><strong>同一pod的容器间网络通信</strong><br>同一pod下的容器使用相同的网络名称空间,这就意味着他们可以通过”localhost”来进行通信,它们共享同一个Ip和相同的端口空间。</p><p><strong>同一个pod暴露多个容器</strong><br>通常pod里的容器监听不同的端口,想要被外部访问都需要暴露出去.你可以通过在一个服务里暴露多个端口或者使用不同的服务来暴露不同的端口来实现。</p><p><strong>二、如何使用Pod</strong><br>通常把Pod分为两类：<br><strong>-</strong>  自主式Pod ：这种Pod本身是不能自我修复的，当Pod被创建后（不论是由你直接创建还是被其他Controller），都会被Kuberentes调度到集群的Node上。直到Pod的进程终止、被删掉、因为缺少资源而被驱逐、或者Node故障之前这个Pod都会一直保持在那个Node上。Pod不会自愈。如果Pod运行的Node故障，或者是调度器本身故障，这个Pod就会被删除。同样的，如果Pod所在Node缺少资源或者Pod处于维护状态，Pod也会被驱逐。<br><strong>-</strong>  控制器管理的Pod：Kubernetes使用更高级的称为Controller的抽象层，来管理Pod实例。Controller可以创建和管理多个Pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个Node故障，Controller就能自动将该节点上的Pod调度到其他健康的Node上。虽然可以直接使用Pod，但是在Kubernetes中通常是使用Controller来管理Pod的。如下图：</p><p>每个Pod都有一个特殊的被称为”根容器”的Pause 容器。 Pause容器对应的镜像属于Kubernetes平台的一部分，除了Pause容器，每个Pod还包含一个或者多个紧密相关的用户业务容器。</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190822141807065-1338384811-1572435175011.png" alt="img"></p><p><strong>Kubernetes设计这样的Pod概念和特殊组成结构有什么用意呢？</strong><br><strong>原因一</strong>：在一组容器作为一个单元的情况下，难以对整体的容器简单地进行判断及有效地进行行动。比如一个容器死亡了，此时是算整体挂了么？那么引入与业务无关的Pause容器作为Pod的根容器，以它的状态代表着整个容器组的状态，这样就可以解决该问题。<br><strong>原因二</strong>：Pod里的多个业务容器共享Pause容器的IP，共享Pause容器挂载的Volume，这样简化了业务容器之间的通信问题，也解决了容器之间的文件共享问题。</p><p><strong>1. Pod的持久性和终止</strong><br><strong>-  Pod的持久性</strong><br>Pod在设计上就不是作为持久化实体的。在调度失败、节点故障、缺少资源或者节点维护的状态下都会死掉会被驱逐。通常，用户不需要手动直接创建Pod，而是应该使用controller（例如Deployments），即使是在创建单个Pod的情况下。Controller可以提供集群级别的自愈功能、复制和升级管理。</p><p><strong>-  Pod的终止</strong><br>因为Pod作为在集群的节点上运行的进程，所以在不再需要的时候能够优雅的终止掉是十分必要的（比起使用发送KILL信号这种暴力的方式）。用户需要能够放松删除请求，并且知道它们何时会被终止，是否被正确的删除。用户想终止程序时发送删除pod的请求，在pod可以被强制删除前会有一个宽限期，会发送一个TERM请求到每个容器的主进程。一旦超时，将向主进程发送KILL信号并从API server中删除。如果kubelet或者container manager在等待进程终止的过程中重启，在重启后仍然会重试完整的宽限期。</p><p>示例流程如下：</p><ul><li>用户发送删除pod的命令，默认宽限期是30秒；</li><li>在Pod超过该宽限期后API server就会更新Pod的状态为”dead”；</li><li>在客户端命令行上显示的Pod状态为”terminating”；</li><li>跟第三步同时，当kubelet发现pod被标记为”terminating”状态时，开始停止pod进程：</li></ul><ol><li>如果在pod中定义了preStop hook，在停止pod前会被调用。如果在宽限期过后，preStop hook依然在运行，第二步会再增加2秒的宽限期；</li><li>向Pod中的进程发送TERM信号；</li></ol><ul><li>跟第三步同时，该Pod将从该service的端点列表中删除，不再是replication controller的一部分。关闭的慢的pod将继续处理load balancer转发的流量；</li><li>过了宽限期后，将向Pod中依然运行的进程发送SIGKILL信号而杀掉进程。</li><li>Kublete会在API server中完成Pod的的删除，通过将优雅周期设置为0（立即删除）。Pod在API中消失，并且在客户端也不可见。</li></ul><p>删除宽限期默认是30秒。 kubectl delete命令支持 –grace-period=<seconds> 选项，允许用户设置自己的宽限期。如果设置为0将强制删除pod。在kubectl&gt;=1.5版本的命令中，你必须同时使用 –force 和 –grace-period=0 来强制删除pod。</seconds></p><p>Pod的强制删除是通过在集群和etcd中将其定义为删除状态。当执行强制删除命令时，API server不会等待该pod所运行在节点上的kubelet确认，就会立即将该pod从API server中移除，这时就可以创建跟原pod同名的pod了。这时，在节点上的pod会被立即设置为terminating状态，不过在被强制删除之前依然有一小段优雅删除周期。<strong>【需要注意：</strong>如果删除一个pod后，再次查看发现pod还在，这是因为在deployment.yaml文件中定义了副本数量！还需要删除deployment才行。即：”kubectl delete pod pod-name -n namespace” &amp;&amp; “kubectl delete deployment deployment-name -n namespace”】</p><p><strong>2.  Pause容器</strong><br>Pause容器，又叫Infra容器。我们检查node节点的时候会发现每个node节点上都运行了很多的pause容器，例如如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-node01 ~]# docker ps |grep pause</span><br><span class="line">0cbf85d4af9e    k8s.gcr.io/pause:3.1   &quot;/pause&quot;     7 days ago  Up 7 days   k8s_POD_myapp-848b5b879b-ksgnv_default_0af41a40-a771-11e8-84d2-000c2972dc1f_0</span><br><span class="line">d6e4d77960a7    k8s.gcr.io/pause:3.1   &quot;/pause&quot;     7 days ago  Up 7 days   k8s_POD_myapp-848b5b879b-5f69p_default_09bc0ba1-a771-11e8-84d2-000c2972dc1f_0</span><br><span class="line">5f7777c55d2a    k8s.gcr.io/pause:3.1   &quot;/pause&quot;     7 days ago  Up 7 days   k8s_POD_kube-flannel-ds-pgpr7_kube-system_23dc27e3-a5af-11e8-84d2-000c2972dc1f_1</span><br><span class="line">8e56ef2564c2    k8s.gcr.io/pause:3.1   &quot;/pause&quot;     7 days ago  Up 7 days   k8s_POD_client2_default_17dad486-a769-11e8-84d2-000c2972dc1f_1</span><br><span class="line">7815c0d69e99    k8s.gcr.io/pause:3.1   &quot;/pause&quot;     7 days ago  Up 7 days   k8s_POD_nginx-deploy-5b595999-872c7_default_7e9df9f3-a6b6-11e8-84d2-000c2972dc1f_2</span><br><span class="line">b4e806fa7083    k8s.gcr.io/pause:3.1   &quot;/pause&quot;     7 days ago  Up 7 days   k8s_POD_kube-proxy-vxckf_kube-system_23dc0141-a5af-11e8-84d2-000c2972dc1f_2</span><br></pre></td></tr></table></figure><p>kubernetes中的pause容器主要为每个业务容器提供以下功能：<br>-  在pod中担任Linux命名空间共享的基础；<br>-  启用pid命名空间，开启init进程；</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190807115119558-339829150-1572435175045.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">示例如下：</span><br><span class="line">[root@k8s-node01 ~]# docker run -d --name pause -p 8880:80 k8s.gcr.io/pause:3.1</span><br><span class="line"> </span><br><span class="line">[root@k8s-node01 ~]# docker run -d --name nginx -v `pwd`/nginx.conf:/etc/nginx/nginx.conf --net=container:pause --ipc=container:pause --pid=container:pause nginx</span><br><span class="line"> </span><br><span class="line">[root@k8s-node01 ~]#  docker run -d --name ghost --net=container:pause --ipc=container:pause --pid=container:pause ghost</span><br><span class="line"> </span><br><span class="line">现在访问http://****:8880/就可以看到ghost博客的界面了。</span><br><span class="line"> </span><br><span class="line">解析说明：</span><br><span class="line">pause容器将内部的80端口映射到宿主机的8880端口，pause容器在宿主机上设置好了网络namespace后，nginx容器加入到该网络namespace中，我们看到nginx容器启动的时候指定了</span><br><span class="line">--net=container:pause，ghost容器同样加入到了该网络namespace中，这样三个容器就共享了网络，互相之间就可以使用localhost直接通信，</span><br><span class="line">--ipc=contianer:pause --pid=container:pause就是三个容器处于同一个namespace中，init进程为pause</span><br><span class="line"> </span><br><span class="line">这时我们进入到ghost容器中查看进程情况。</span><br><span class="line">[root@k8s-node01 ~]# docker exec -it ghost /bin/bash</span><br><span class="line">root@d3057ceb54bc:/var/lib/ghost# ps axu</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.0   1012     4 ?        Ss   03:48   0:00 /pause</span><br><span class="line">root          6  0.0  0.0  32472   780 ?        Ss   03:53   0:00 nginx: master process nginx -g daemon off;</span><br><span class="line">systemd+     11  0.0  0.1  32932  1700 ?        S    03:53   0:00 nginx: worker process</span><br><span class="line">node         12  0.4  7.5 1259816 74868 ?       Ssl  04:00   0:07 node current/index.js</span><br><span class="line">root         77  0.6  0.1  20240  1896 pts/0    Ss   04:29   0:00 /bin/bash</span><br><span class="line">root         82  0.0  0.1  17496  1156 pts/0    R+   04:29   0:00 ps axu</span><br><span class="line"> </span><br><span class="line">在ghost容器中同时可以看到pause和nginx容器的进程，并且pause容器的PID是1。而在kubernetes中容器的PID=1的进程即为容器本身的业务进程。</span><br></pre></td></tr></table></figure><p><strong>3.  Init容器</strong><br>Pod 能够具有多个容器，应用运行在容器里面，但是它也可能有一个或多个<strong>先于</strong>应用容器启动的 Init 容器。init容器是一种专用的容器，在应用容器启动之前运行，可以包含普通容器映像中不存在的应用程序或安装脚本。init容器会优先启动，待里面的任务完成后容器就会退出。    init容器配置示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: init-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: workdir</span><br><span class="line">      mountPath: /usr/share/nginx/html</span><br><span class="line">  # These containers are run during pod initialization</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: install</span><br><span class="line">    image: busybox</span><br><span class="line">    command:</span><br><span class="line">    - wget</span><br><span class="line">    - &quot;-O&quot;</span><br><span class="line">    - &quot;/work-dir/index.html&quot;</span><br><span class="line">    - http://kubernetes.io</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: workdir</span><br><span class="line">      mountPath: &quot;/work-dir&quot;</span><br><span class="line">  dnsPolicy: Default</span><br><span class="line">  volumes:</span><br><span class="line">  - name: workdir</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>理解init容器</li></ol><ul><li>它们总是运行到完成。</li><li>每个都必须在下一个启动之前成功完成。</li><li>如果 Pod 的 Init 容器失败，Kubernetes 会不断地重启该 Pod，直到 Init 容器成功为止。然而，如果 Pod 对应的 restartPolicy 为 Never，它不会重新启动。</li><li>Init 容器支持应用容器的全部字段和特性，但不支持 Readiness Probe，因为它们必须在 Pod 就绪之前运行完成。</li><li>如果为一个 Pod 指定了多个 Init 容器，那些容器会按顺序一次运行一个。 每个 Init 容器必须运行成功，下一个才能够运行。</li><li>因为 Init 容器可能会被重启、重试或者重新执行，所以 Init 容器的代码应该是幂等的。 特别地，被写到 EmptyDirs 中文件的代码，应该对输出文件可能已经存在做好准备。</li><li>在 Pod 上使用 activeDeadlineSeconds，在容器上使用 livenessProbe，这样能够避免 Init 容器一直失败。 这就为 Init 容器活跃设置了一个期限。</li><li>在 Pod 中的每个 app 和 Init 容器的名称必须唯一；与任何其它容器共享同一个名称，会在验证时抛出错误。</li><li>对 Init 容器 spec 的修改，被限制在容器 image 字段中。 更改 Init 容器的 image 字段，等价于重启该 Pod。</li></ul><p>一个pod可以包含多个普通容器和多个init容器，在Pod中所有容器的名称必须唯一，init容器在普通容器启动前顺序执行，如果init容器失败，则认为pod失败，K8S会根据pod的重启策略来重启这个容器，直到成功。</p><p>Init容器需要在pod.spec中的initContainers数组中定义（与3pod.spec.containers数组相似）。init容器的状态在.status.initcontainerStatus字段中作为容器状态的数组返回（与status.containerStatus字段类似）。init容器支持普通容器的所有字段和功能，除了readinessprobe。Init 容器只能修改image 字段，修改image 字段等于重启 Pod，Pod 重启所有Init 容器必须重新执行。 </p><p>如果Pod的Init容器失败，Kubernetes会不断地重启该Pod，直到Init容器成功为止。然而如果Pod对应的restartPolicy为Never，则它不会重新启动。所以在Pod上使用activeDeadlineSeconds，在容器上使用livenessProbe，相当于为Init容器活跃设置了一个期限，能够避免Init容器一直失败。</p><p><strong>2.  Init容器与普通容器的不同之处</strong><br>Init 容器与普通的容器非常像，除了如下两点：<br>- Init 容器总是运行到成功完成为止。<br>- 每个 Init 容器都必须在下一个 Init 容器启动之前成功完成。</p><p>Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置。 然而，Init 容器对资源请求和限制的处理稍有不同， 而且 Init 容器不支持 Readiness Probe，因为它们必须在 Pod 就绪之前运行完成。如果为一个 Pod 指定了多个 Init 容器，那些容器会按顺序一次运行一个。 每个 Init 容器必须运行成功，下一个才能够运行。 当所有的 Init 容器运行完成时，Kubernetes 初始化 Pod 并像平常一样运行应用容器。</p><ol start="3"><li>Init 容器能做什么<br>因为 Init 容器具有与应用容器分离的单独镜像，它们的启动相关代码具有如下优势：</li></ol><ul><li>它们可以包含并运行实用工具，处于安全考虑，是不建议在应用容器镜像中包含这些实用工具的。</li><li>它们可以包含实用工具和定制化代码来安装，但不能出现在应用镜像中。例如创建镜像没必要FROM另一个镜像，只需要在安装中使用类似sed，awk、 python 或dig这样的工具。</li><li>应用镜像可以分离出创建和部署的角色，而没有必要联合它们构建一个单独的镜像。</li><li>它们使用 Linux Namespace，所以对应用容器具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用容器不能够访问。</li><li>它们在应用容器启动之前运行完成，然而应用容器并行运行，所以 Init 容器提供了一种简单的方式来阻塞或延迟应用容器的启动，直到满足了一组先决条件。</li></ul><p><strong>4.  静态pod</strong><br>静态Pod是由kubelet进行管理，仅存在于特定Node上的Pod。它们不能通过API Server进行管理，无法与ReplicationController、Deployment或DaemonSet进行关联，并且kubelet也无法对其健康检查。静态Pod总是由kubelet创建，并且总在kubelet所在的Node上运行。创建静态Pod的方式：<strong>使用配置文件方式</strong> 或 <strong>HTTP方式</strong>。一般常使用的是配置文件方式。</p><p>-  通过配置文件创建<br>配置文件只是特定目录中json或yaml格式的标准pod定义。它通过在kubelet守护进程中添加配置参数–pod-manifest-path=<the directory> 来运行静态Pod，kubelet经常会它定期扫描目录；例如，如何将一个简单web服务作为静态pod启动？</the></p><p>选择运行静态pod的节点服务器，不一定是node节点，只要有kubelet进程所在的节点都可以运行静态pod。可以在某个节点上创建一个放置一个Web服务器pod定义的描述文件文件夹，例如/etc/kubelet.d/static-web.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /etc/kubelet.d/</span><br><span class="line"># vim /etc/kubelet.d/static-web.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: static-web</span><br><span class="line">  labels:</span><br><span class="line">    role: myrole</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: web</span><br><span class="line">      image: nginx</span><br><span class="line">      ports:</span><br><span class="line">        - name: web</span><br><span class="line">          containerPort: 80</span><br><span class="line">          protocol: TCP&lt;br&gt;</span><br><span class="line">#ls /etc/kubelet.d/</span><br><span class="line">static-web.yaml</span><br></pre></td></tr></table></figure><p>通过使用–pod-manifest-path=/etc/kubelet.d/参数运行它，在节点上配置我的kubelet守护程序以使用此目录。比如这里kubelet启动参数位/etc/systemd/system/kubelet.service.d/10-kubelet.conf, 修改配置，然后将参数加入到现有参数配置项中(安装方式不尽相同，但是道理一样)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/systemd/system/kubelet.service.d/10-kubelet.conf</span><br><span class="line">······</span><br><span class="line">······</span><br><span class="line">Environment=&quot;KUBELET_EXTRA_ARGS=--cluster-dns=10.96.0.10 --cluster-domain=cluster.local --pod-manifest-path=/etc/kubelet.d/&quot;</span><br><span class="line">······</span><br><span class="line">······</span><br></pre></td></tr></table></figure><p>保存退出，reload一下systemd daeomon ,重启kubelet服务进程</p><p><code>#systemctl daemon-reload</code></p><p><code># systemctl restart kubelet</code></p><p>前面说了，当kubelet启动时，它会自动启动在指定的目录–pod-manifest-path=或–manifest-url=参数中定义的所有pod ，即我们的static-web。接着在该节点上检查是否创建成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get pods -o wide</span><br><span class="line">NAME                READY     STATUS    RESTARTS   AGE       IP            NODE   </span><br><span class="line">static-web-k8s-m1   1/1       Running   0          2m        10.244.2.32   k8s-m1</span><br></pre></td></tr></table></figure><p>上面也提到了，它不归任何部署方式来管理，即使我们尝试kubelet命令去删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># kubectl delete pod static-web-k8s-m1</span><br><span class="line">pod &quot;static-web-k8s-m1&quot; deleted</span><br><span class="line"> </span><br><span class="line"># kubectl get pods -o wide</span><br><span class="line">NAME                READY     STATUS    RESTARTS   AGE       IP        NODE      NOMINATED NODE</span><br><span class="line">static-web-k8s-m1   0/1       Pending   0          2s        &lt;none&gt;    k8s-m1    &lt;none&gt;</span><br></pre></td></tr></table></figure><p>可以看出静态pod通过这种方式是没法删除的</p><p>那我如何去删除或者说是动态的添加一个pod呢？这种机制已经知道，kubelet进程会定期扫描配置的目录（/etc/kubelet.d在我的示例）以进行更改，并在文件出现/消失在此目录中时添加/删除pod。</p><p><strong>5. Pod容器共享Volume</strong><br>同一个Pod中的多个容器可以共享Pod级别的存储卷Volume,Volume可以定义为各种类型，多个容器各自进行挂载，将Pod的Volume挂载为容器内部需要的目录。例如：Pod级别的Volume:”app-logs”,用于tomcat向其中写日志文件，busybox读日志文件。</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190806180355283-1507086359-1572435175020.png" alt="img"></p><p>pod-volumes-applogs.yaml文件的配置内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: volume-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: tomcat</span><br><span class="line">    image: tomcat</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: app-logs</span><br><span class="line">      mountPath: /usr/local/tomcat/logs</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [&quot;sh&quot;,&quot;-c&quot;,&quot;tailf /logs/catalina*.log&quot;]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: app-logs</span><br><span class="line">      mountPath: /logs</span><br><span class="line">  volumes:</span><br><span class="line">  - name: app-logs</span><br><span class="line">    emptuDir: &#123;&#125;</span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kubectl logs &lt;pod_name&gt; -c &lt;container_name&gt;</span><br><span class="line"># kubectl exec -it &lt;pod_name&gt; -c &lt;container_name&gt; – tail /usr/local/tomcat/logs/catalina.xx.log</span><br></pre></td></tr></table></figure><p><strong>6. Pod的配置管理</strong><br>Kubernetes v1.2的版本提供统一的集群配置管理方案 – ConfigMap：容器应用的配置管理</p><p>ConfigMap使用场景：<br>-  生成为容器内的环境变量。<br>-  设置容器启动命令的启动参数（需设置为环境变量）。<br>-  以Volume的形式挂载为容器内部的文件或目录。</p><p>ConfigMap以一个或多个key:value的形式保存在kubernetes系统中供应用使用，既可以表示一个变量的值（例如：apploglevel=info），也可以表示完整配置文件的内容（例如：server.xml=&lt;?xml…&gt;…）。可以通过yaml配置文件或者使用kubectl create configmap命令的方式创建ConfigMap。</p><p><strong>3.1）创建ConfigMap</strong><br>通过yaml文件方式<br>cm-appvars.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: cm-appvars</span><br><span class="line">data:</span><br><span class="line">  apploglevel: info</span><br><span class="line">  appdatadir: /var/data</span><br></pre></td></tr></table></figure><p>常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># kubectl create -f cm-appvars.yaml</span><br><span class="line"></span><br><span class="line"># kubectl get configmap</span><br><span class="line"></span><br><span class="line"># kubectl describe configmap cm-appvars</span><br><span class="line"></span><br><span class="line"># kubectl get configmap cm-appvars -o yaml</span><br></pre></td></tr></table></figure><p>通过kubectl命令行方式<br>通过kubectl create configmap创建，使用参数–from-file或–from-literal指定内容，可以在一行中指定多个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）通过–from-file参数从文件中进行创建，可以指定key的名称，也可以在一个命令行中创建包含多个key的ConfigMap。</span><br><span class="line"># kubectl create configmap NAME --from-file=[key=]source --from-file=[key=]source</span><br><span class="line"> </span><br><span class="line">2）通过–from-file参数从目录中进行创建，该目录下的每个配置文件名被设置为key，文件内容被设置为value。</span><br><span class="line"># kubectl create configmap NAME --from-file=config-files-dir</span><br><span class="line"> </span><br><span class="line">3）通过–from-literal从文本中进行创建，直接将指定的key=value创建为ConfigMap的内容。</span><br><span class="line"># kubectl create configmap NAME --from-literal=key1=value1 --from-literal=key2=value2</span><br></pre></td></tr></table></figure><p><strong>容器应用对ConfigMap的使用有两种方法：</strong><br>- 通过环境变量获取ConfigMap中的内容。<br>- 通过Volume挂载的方式将ConfigMap中的内容挂载为容器内部的文件或目录。</p><p>通过环境变量的方式<br>ConfigMap的yaml文件: cm-appvars.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: cm-appvars</span><br><span class="line">data:</span><br><span class="line">  apploglevel: info</span><br><span class="line">  appdatadir: /var/data</span><br></pre></td></tr></table></figure><p>Pod的yaml文件：cm-test-pod.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: cm-test-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: cm-test</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;env|grep APP&quot;]</span><br><span class="line">    env:</span><br><span class="line">    - name: APPLOGLEVEL</span><br><span class="line">      valueFrom:</span><br><span class="line">        configMapKeyRef:</span><br><span class="line">          name: cm-appvars</span><br><span class="line">          key: apploglevel</span><br><span class="line">    - name: APPDATADIR</span><br><span class="line">      valueFrom:</span><br><span class="line">        configMapKeyRef:</span><br><span class="line">          name: cm-appvars</span><br><span class="line">          key: appdatadir</span><br></pre></td></tr></table></figure><p>创建命令：<br># kubectl create -f cm-test-pod.yaml<br># kubectl get pods –show-all<br># kubectl logs cm-test-pod</p><p>使用ConfigMap的限制条件</p><ul><li>ConfigMap必须在Pod之前创建</li><li>ConfigMap也可以定义为属于某个Namespace。只有处于相同Namespace中的Pod可以引用它。</li><li>kubelet只支持可以被API Server管理的Pod使用ConfigMap。静态Pod无法引用。</li><li>在Pod对ConfigMap进行挂载操作时，容器内只能挂载为“目录”，无法挂载为文件。</li></ul><p><strong>7. Pod的生命周期</strong></p><p><strong>-  Pod的状态</strong><br>pod从创建到最后的创建成功会分别处于不同的阶段，下面是Pod的生命周期示意图，从图中可以看到Pod状态的变化：</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190807200525601-1625049545-1572435175028.png" alt="img"></p><p>挂起或等待中 (Pending)：API Server创建了Pod资源对象并已经存入了etcd中，但是它并未被调度完成，或者仍然处于从仓库下载镜像的过程中。这时候Pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。创建pod的请求已经被k8s接受，但是容器并没有启动成功，可能处在：写数据到etcd，调度，pull镜像，启动容器这四个阶段中的任何一个阶段，pending伴随的事件通常会有：ADDED, Modified这两个事件的产生。<br>运行中 (Running)：该 Pod 已经被调度到了一个node节点上，Pod 中所有的容器都已被kubelet创建完成。至少有一个容器正在运行，或者正处于启动或重启状态。<br>正常终止 (Succeeded)：pod中的所有的容器已经正常的自行退出，并且k8s永远不会自动重启这些容器，一般会是在部署job的时候会出现。<br>异常停止 (Failed)：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。<br>未知状态 (Unkonwn)：出于某种原因，无法获得Pod的状态，通常是由于与Pod主机通信时出错。</p><p><strong>-  Pod的创建过程</strong><br>Pod是Kubernetes的基础单元，了解其创建的过程，更有助于理解系统的运作。创建Pod的整个流程的时序图如下：</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190822142318956-312003948-1572435175036.png" alt="img"></p><p>① 用户通过kubectl客户端提交Pod Spec给API Server。<br>② API Server尝试将Pod对象的相关信息存储到etcd中，等待写入操作完成，API Server返回确认信息到客户端。<br>③ API Server开始反映etcd中的状态变化。<br>④ 所有的Kubernetes组件通过”watch”机制跟踪检查API Server上的相关信息变动。<br>⑤ kube-scheduler（调度器）通过其”watcher”检测到API Server创建了新的Pod对象但是没有绑定到任何工作节点。<br>⑥ kube-scheduler为Pod对象挑选一个工作节点并将结果信息更新到API Server。<br>⑦ 调度结果新消息由API Server更新到etcd，并且API Server也开始反馈该Pod对象的调度结果。<br>⑧ Pod被调度到目标工作节点上的kubelet尝试在当前节点上调用docker engine进行启动容器，并将容器的状态结果返回到API Server。<br>⑨ API Server将Pod信息存储到etcd系统中。<br>⑩ 在etcd确认写入操作完成，API Server将确认信息发送到相关的kubelet。</p><p>Pod常规的排查：<a href="https://feisky.gitbooks.io/kubernetes/troubleshooting/pod.html" target="_blank" rel="noopener">见这里</a></p><p>一个pod的完整创建，通常会伴随着各种事件的产生，kubernetes事件的种类总共只有4种：<br>Added EventType = “ADDED”<br>Modified EventType = “MODIFIED”<br>Deleted EventType = “DELETED”<br>Error EventType = “ERROR”</p><p>PodStatus 有一组PodConditions。 PodCondition中的ConditionStatus，它代表了当前pod是否处于某一个阶段（PodScheduled，Ready，Initialized，Unschedulable），”true” 表示处于，”false”表示不处于。PodCondition数组的每个元素都有一个类型字段和一个状态字段。</p><p>类型字段 PodConditionType  是一个字符串，可能的值是:<br>PodScheduled：pod正处于调度中，刚开始调度的时候，hostip还没绑定上，持续调度之后，有合适的节点就会绑定hostip，然后更新etcd数据<br>Ready: pod 已经可以开始服务，譬如被加到负载均衡里面<br>Initialized：所有pod 中的初始化容器已经完成了<br>Unschedulable：限制不能被调度，譬如现在资源不足</p><p>状态字段 ConditionStatus  是一个字符串，可能的值为True，False和Unknown</p><p>Pod的ERROR事件的情况大概有：<br>CrashLoopBackOff： 容器退出，kubelet正在将它重启<br>InvalidImageName： 无法解析镜像名称<br>ImageInspectError： 无法校验镜像<br>ErrImageNeverPull： 策略禁止拉取镜像<br>ImagePullBackOff： 正在重试拉取<br>RegistryUnavailable： 连接不到镜像中心<br>ErrImagePull： 通用的拉取镜像出错<br>CreateContainerConfigError： 不能创建kubelet使用的容器配置<br>CreateContainerError： 创建容器失败<br>m.internalLifecycle.PreStartContainer  执行hook报错<br>RunContainerError： 启动容器失败<br>PostStartHookError： 执行hook报错<br>ContainersNotInitialized： 容器没有初始化完毕<br>ContainersNotReady： 容器没有准备完毕<br>ContainerCreating：容器创建中<br>PodInitializing：pod 初始化中<br>DockerDaemonNotReady：docker还没有完全启动<br>NetworkPluginNotReady： 网络插件还没有完全启动</p><p><strong>-  Pod的重启策略</strong><br>PodSpec 中有一个 restartPolicy 字段，可能的值为 <strong>Always</strong>、<strong>OnFailure</strong> 和 <strong>Never</strong>。默认为 Always。 restartPolicy 适用于 Pod 中的所有容器。restartPolicy 仅指通过同一节点上的 kubelet 重新启动容器。失败的容器由 kubelet 以五分钟为上限的指数退避延迟（10秒，20秒，40秒…）重新启动，并在成功执行十分钟后重置。pod一旦绑定到一个节点，Pod 将永远不会重新绑定到另一个节点（除非删除这个pod，或pod所在的node节点发生故障或该node从集群中退出，则pod才会被调度到其他node节点上）。</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190807102156539-458120197-1572435175038.png" alt="img"></p><p><strong>说明：</strong> 可以管理Pod的控制器有Replication Controller，Job，DaemonSet，及kubelet（静态Pod）。<br>-  RC和DaemonSet：必须设置为Always，需要保证该容器持续运行。<br>-  Job：OnFailure或Never，确保容器执行完后不再重启。<br>-  kubelet：在Pod失效的时候重启它，不论RestartPolicy设置为什么值，并且不会对Pod进行健康检查。</p><p><strong>-  常见的状态转换场景</strong></p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190807102716040-1569177475-1572435175048.png" alt="img"></p><p><strong>8.  Pod健康检查 (存活性探测)</strong><br>在pod生命周期中可以做的一些事情。主容器启动前可以完成初始化容器，初始化容器可以有多个，他们是串行执行的，执行完成后就推出了，在主程序刚刚启动的时候可以指定一个post start 主程序启动开始后执行一些操作，在主程序结束前可以指定一个 pre stop 表示主程序结束前执行的一些操作。Pod启动后的健康状态可以由两类探针来检测：<strong>Liveness Probe（存活性探测） 和 Readiness Probe（就绪性探测）</strong>。如下图：</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190808105616189-1181682733-1572435175060.png" alt="img"></p><p><strong>-  Liveness Probe</strong><br><strong>1.</strong> 用于判断容器是否存活（running状态）。<br><strong>2.</strong> 如果LivenessProbe探针探测到容器非健康，则kubelet将杀掉该容器，并根据容器的重启策略做相应处理。<br><strong>3.</strong> 如果容器不包含LivenessProbe探针，则kubelet认为该探针的返回值永远为“success”。</p><p>livenessProbe：指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到其 重启策略 的影响。如果容器不提供存活探针，则默认状态为 Success。Kubelet使用liveness probe（存活探针）来确定何时重启容器。例如，当应用程序处于运行状态但无法做进一步操作，liveness探针将捕获到deadlock，重启处于该状态下的容器，使应用程序在存在bug的情况下依然能够继续运行下去（谁的程序还没几个bug呢）。</p><p><strong>-  Readiness Probe</strong><br><strong>1.</strong> 用于判断容器是否启动完成（read状态），可以接受请求。<br><strong>2.</strong> 如果ReadnessProbe探针检测失败，则Pod的状态将被修改。Endpoint Controller将从Service的Endpoint中删除包含该容器所在Pod的Endpoint。</p><p>readinessProbe：指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 Failure。如果容器不提供就绪探针，则默认状态为 Success。Kubelet使用readiness probe（就绪探针）来确定容器是否已经就绪可以接受流量。只有当Pod中的容器都处于就绪状态时kubelet才会认定该Pod处于就绪状态。该信号的作用是控制哪些Pod应该作为service的后端。如果Pod处于非就绪状态，那么它们将会被从service的load balancer中移除。</p><p><strong>Kubelet 可以选择是否执行在容器上运行的两种探针执行和做出反应，每次探测都将获得以下三种结果之一：</strong><br>成功：容器通过了诊断。<br>失败：容器未通过诊断。<br>未知：诊断失败，因此不会采取任何行动。</p><p><strong>探针是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的Handler。其存活性探测的方法有以下三种：</strong><br>- ExecAction：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。<br>- TCPSocketAction：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。<br>- HTTPGetAction：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的。</p><p><strong>-  定义LivenessProbe命令</strong><br>许多长时间运行的应用程序最终会转换到broken状态，除非重新启动，否则无法恢复。Kubernetes提供了Liveness Probe来检测和补救这种情况。<strong>LivenessProbe三种实现方式：</strong></p><p>1）ExecAction：在一个容器内部执行一个命令，如果该命令状态返回值为0，则表明容器健康。（即定义Exec liveness探针）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness-exec</span><br><span class="line">  name: liveness-exec</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness-exec-demo</span><br><span class="line">    image: busybox</span><br><span class="line">    args: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;touch /tmp/healthy;sleep 60;rm -rf /tmp/healthy;&quot;sleep 600]</span><br><span class="line">    livenessProbe:</span><br><span class="line">      exec:</span><br><span class="line">        command: [&quot;test&quot;,&quot;-e&quot;,&quot;/tmp/healthy&quot;]</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br></pre></td></tr></table></figure><p>上面的资源清单中定义了一个Pod 对象， 基于 busybox 镜像 启动 一个 运行“ touch/ tmp/ healthy； sleep 60； rm- rf/ tmp/ healthy； sleep 600” 命令 的 容器， 此 命令 在 容器 启动 时 创建/ tmp/ healthy 文件， 并于 60 秒 之后 将其 删除。 periodSeconds 规定kubelet要每隔5秒执行一次liveness probe， initialDelaySeconds 告诉kubelet在第一次执行probe之前要的等待5秒钟。存活性探针探针检测命令是在容器中执行 “test -e /tmp/healthy”命令检查/ tmp/healthy 文件的存在性。如果命令执行成功，将返回0，表示 成功 通过 测试，则kubelet就会认为该容器是活着的并且很健康。如果返回非0值，kubelet就会杀掉这个容器并重启它。</p><p>2）TCPSocketAction：通过容器IP地址和端口号执行TCP检查，如果能够建立TCP连接，则表明容器健康。这种方式使用TCP Socket，使用此配置，kubelet将尝试在指定端口上打开容器的套接字。 如果可以建立连接，容器被认为是健康的，如果不能就认为是失败的。（即定义TCP liveness探针）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness-tcp</span><br><span class="line">  name: liveness-tcp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness-tcp-demo</span><br><span class="line">    image: nginx:1.12-alpine</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">    livenessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: http</span><br></pre></td></tr></table></figure><p>上面的资源清单文件，向Pod IP的80/tcp端口发起连接请求，并根据连接建立的状态判断Pod存活状态。</p><p>3）HTTPGetAction：通过容器IP地址、端口号及路径调用HTTP Get方法，如果响应的状态码大于等于200且小于等于400，则认为容器健康。（即定义HTTP请求的liveness探针）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: liveness-http</span><br><span class="line">  name: liveness-http</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: liveness-http-demo</span><br><span class="line">    image: nginx:1.12-alpine</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 80</span><br><span class="line">    lifecycle:</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;echo healthy &gt; /usr/share/nginx/html/healthy&quot;]</span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: /healthy</span><br><span class="line">        port: http</span><br><span class="line">        scheme: HTTP</span><br><span class="line">    initialDelaySeconds: 3</span><br><span class="line">    periodSeconds: 3</span><br></pre></td></tr></table></figure><p>上面 清单 文件 中 定义 的 httpGet 测试 中， 请求 的 资源 路径 为“/ healthy”， 地址 默认 为 Pod IP， 端口 使用 了 容器 中 定义 的 端口 名称 HTTP， 这也 是 明确 为 容器 指明 要 暴露 的 端口 的 用途 之一。livenessProbe 指定kubelete需要每隔3秒执行一次liveness probe。initialDelaySeconds 指定kubelet在该执行第一次探测之前需要等待3秒钟。该探针将向容器中的server的默认http端口发送一个HTTP GET请求。如果server的/healthz路径的handler返回一个成功的返回码，kubelet就会认定该容器是活着的并且很健康。如果返回失败的返回码，kubelet将杀掉该容器并重启它。任何大于200小于400的返回码都会认定是成功的返回码。其他返回码都会被认为是失败的返回码。</p><p><strong>-  定义ReadinessProbe命令</strong><br>有时，应用程序暂时无法对外部流量提供服务。 例如，应用程序可能需要在启动期间加载大量数据或配置文件。 在这种情况下，你不想杀死应用程序，但你也不想发送请求。 Kubernetes提供了readiness probe来检测和减轻这些情况。 Pod中的容器可以报告自己还没有准备，不能处理Kubernetes服务发送过来的流量。Readiness probe的配置跟liveness probe很像。唯一的不同是使用 readinessProbe而不是livenessProbe。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    test: readiness-exec</span><br><span class="line">  name: readiness-exec</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: readiness-demo</span><br><span class="line">    image: busybox</span><br><span class="line">    args: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;touch /tmp/healthy;sleep 60;rm -rf /tmp/healthy;&quot;sleep 600]</span><br><span class="line">    readinessProbe:</span><br><span class="line">      exec:</span><br><span class="line">        command: [&quot;test&quot;,&quot;-e&quot;,&quot;/tmp/healthy&quot;]</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 5</span><br></pre></td></tr></table></figure><p>上面定义的是一个exec的Readiness探针，另外Readiness probe的HTTP和TCP的探测器配置跟liveness probe一样。Readiness和livenss probe可以并行用于同一容器。 使用两者可以确保流量无法到达未准备好的容器，并且容器在失败时重新启动。</p><p><strong>-  配置Probe</strong><br>Probe中有很多精确和详细的配置，通过它们你能准确的控制liveness和readiness检查：<br>initialDelaySeconds：容器启动后第一次执行探测是需要等待多少秒。即启动容器后首次进行健康检查的等待时间，单位为秒。<br>periodSeconds：执行探测的频率。默认是10秒，最小1秒。<br>timeoutSeconds：探测超时时间。默认1秒，最小1秒。即健康检查发送请求后等待响应的时间，如果超时响应kubelet则认为容器非健康，重启该容器，单位为秒。<br>successThreshold：探测失败后，最少连续探测成功多少次才被认定为成功。默认是1。对于liveness必须是1。最小值是1。<br>failureThreshold：探测成功后，最少连续探测失败多少次才被认定为失败。默认是3。最小值是1。</p><p>HTTP probe中可以给 httpGet设置其他配置项：<br>host：连接的主机名，默认连接到pod的IP。你可能想在http header中设置”Host”而不是使用IP。<br>scheme：连接使用的schema，默认HTTP。<br>path: 访问的HTTP server的path。<br>httpHeaders：自定义请求的header。HTTP运行重复的header。<br>port：访问的容器的端口名字或者端口号。端口号必须介于1和65525之间。</p><p>对于HTTP探测器，kubelet向指定的路径和端口发送HTTP请求以执行检查。 Kubelet将probe发送到容器的IP地址，除非地址被httpGet中的可选host字段覆盖。 在大多数情况下，不想设置主机字段。 有一种情况下可以设置它， 假设容器在127.0.0.1上侦听，并且Pod的hostNetwork字段为true。 然后，在httpGet下的host应该设置为127.0.0.1。 如果你的pod依赖于虚拟主机，这可能是更常见的情况，你不应该是用host，而是应该在httpHeaders中设置Host头。</p><ul><li>Liveness Probe和Readiness Probe使用场景</li><li>如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活探针; kubelet 将根据 Pod 的restartPolicy 自动执行正确的操作。</li><li>如果希望容器在探测失败时被杀死并重新启动，那么请指定一个存活探针，并指定restartPolicy 为 Always 或 OnFailure。</li><li>如果要仅在探测成功时才开始向 Pod 发送流量，请指定就绪探针。在这种情况下，就绪探针可能与存活探针相同，但是 spec 中的就绪探针的存在意味着 Pod 将在没有接收到任何流量的情况下启动，并且只有在探针探测成功后才开始接收流量。</li><li>如果你希望容器能够自行维护，您可以指定一个就绪探针，该探针检查与存活探针不同的端点。</li></ul><p><strong>请注意：</strong>如果你只想在 Pod 被删除时能够排除请求，则不一定需要使用就绪探针；在删除 Pod 时，Pod 会自动将自身置于未完成状态，无论就绪探针是否存在。当等待 Pod 中的容器停止时，Pod 仍处于未完成状态。</p><p><strong>9.  Pod调度</strong><br>在kubernetes集群中，Pod（container）是应用的载体，一般通过RC、Deployment、DaemonSet、Job等对象来完成Pod的调度与自愈功能。</p><p><strong>0.  Pod的生命</strong><br>一般来说，Pod 不会消失，直到人为销毁它们。这可能是一个人或控制器。这个规则的唯一例外是成功或失败的 phase 超过一段时间（由 master 确定）的Pod将过期并被自动销毁。有三种可用的控制器：<br>-  使用 Job 运行预期会终止的 Pod，例如批量计算。Job 仅适用于重启策略为 OnFailure 或 Never 的 Pod。<br>-  对预期不会终止的 Pod 使用 ReplicationController、ReplicaSet 和 Deployment ，例如 Web 服务器。 ReplicationController 仅适用于具有 restartPolicy 为 Always 的 Pod。<br>-  提供特定于机器的系统服务，使用 DaemonSet 为每台机器运行一个 Pod 。</p><p>所有这三种类型的控制器都包含一个 PodTemplate。建议创建适当的控制器，让它们来创建 Pod，而不是直接自己创建 Pod。这是因为单独的 Pod 在机器故障的情况下没有办法自动复原，而控制器却可以。如果节点死亡或与集群的其余部分断开连接，则 Kubernetes 将应用一个策略将丢失节点上的所有 Pod 的 phase 设置为 Failed。</p><p><strong>1.  RC、Deployment：全自动调度</strong><br>RC的功能即保持集群中始终运行着指定个数的Pod。在调度策略上主要有：<br>-   系统内置调度算法  [最优Node]<br>-   NodeSelector   [定向调度]<br>-   NodeAffinity  [亲和性调度]</p><p>-  NodeSelector  [定向调度]<br>kubernetes中kube-scheduler负责实现Pod的调度，内部系统通过一系列算法最终计算出最佳的目标节点。如果需要将Pod调度到指定Node上，则可以通过Node的标签（Label）和Pod的nodeSelector属性相匹配来达到目的。</p><p><strong>1.</strong> kubectl label nodes {node-name} {label-key}={label-value}<br><strong>2.</strong> nodeSelector:<br>{label-key}:{label-value}</p><p>如果给多个Node打了相同的标签，则scheduler会根据调度算法从这组Node中选择一个可用的Node来调度。<br>如果Pod的nodeSelector的标签在Node中没有对应的标签，则该Pod无法被调度成功。</p><p>Node标签的使用场景：<br>对集群中不同类型的Node打上不同的标签，可控制应用运行Node的范围。例如：role=frontend;role=backend;role=database。</p><p>-  NodeAffinity [亲和性调度]<br>NodeAffinity意为Node亲和性调度策略，NodeSelector为精确匹配，NodeAffinity为条件范围匹配，通过In（属于）、NotIn（不属于）、Exists（存在一个条件）、DoesNotExist（不存在）、Gt（大于）、Lt（小于）等操作符来选择Node，使调度更加灵活。</p><p><strong>1.</strong> RequiredDuringSchedulingRequiredDuringExecution：类似于NodeSelector，但在Node不满足条件时，系统将从该Node上移除之前调度上的Pod。<br><strong>2.</strong> RequiredDuringSchedulingIgnoredDuringExecution：与上一个类似，区别是在Node不满足条件时，系统不一定从该Node上移除之前调度上的Pod。<br><strong>3.</strong> PreferredDuringSchedulingIgnoredDuringExecution：指定在满足调度条件的Node中，哪些Node应更优先地进行调度。同时在Node不满足条件时，系统不一定从该Node上移除之前调度上的Pod。</p><p>如果同时设置了NodeSelector和NodeAffinity，则系统将需要同时满足两者的设置才能进行调度。</p><p><strong>2.  DaemonSet：特定场景调度</strong><br>DaemonSet是kubernetes1.2版本新增的一种资源对象，用于管理在集群中每个Node上仅运行一份Pod的副本实例。</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190807110231622-921561421-1572435175067.png" alt="img"></p><p>该用法适用的应用场景：<br><strong>1.</strong>  在每个Node上运行一个GlusterFS存储或者Ceph存储的daemon进程。<br><strong>2.</strong>  在每个Node上运行一个日志采集程序：fluentd或logstach。<br><strong>3.</strong>  在每个Node上运行一个健康程序，采集该Node的运行性能数据，例如：Prometheus Node Exportor、collectd、New Relic agent或Ganglia gmond等。</p><p>DaemonSet的Pod调度策略与RC类似，除了使用系统内置算法在每台Node上进行调度，也可以通过NodeSelector或NodeAffinity来指定满足条件的Node范围进行调度。</p><p><strong>3.  Job：批处理调度</strong><br>kubernetes从1.2版本开始支持批处理类型的应用，可以通过kubernetes Job资源对象来定义并启动一个批处理任务。批处理任务通常并行（或串行）启动多个计算进程去处理一批工作项（work item），处理完后，整个批处理任务结束。</p><p>批处理的三种模式：</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190807110527368-1482246320-1572435175056.png" alt="img"></p><p>批处理按任务实现方式不同分为以下几种模式：<br><strong>1.</strong> Job Template Expansion模式<br>一个Job对象对应一个待处理的Work item，有几个Work item就产生几个独立的Job，通过适用于Work item数量少，每个Work item要处理的数据量比较大的场景。例如有10个文件（Work item）,每个文件（Work item）为100G。<br><strong>2.</strong> Queue with Pod Per Work Item<br>采用一个任务队列存放Work item，一个Job对象作为消费者去完成这些Work item，其中Job会启动N个Pod，每个Pod对应一个Work item。<br><strong>3.</strong> Queue with Variable Pod Count<br>采用一个任务队列存放Work item，一个Job对象作为消费者去完成这些Work item，其中Job会启动N个Pod，每个Pod对应一个Work item。但Pod的数量是可变的。</p><p>Job的三种类型<br><strong>1.</strong> Non-parallel Jobs<br>通常一个Job只启动一个Pod,除非Pod异常才会重启该Pod,一旦此Pod正常结束，Job将结束。<br><strong>2.</strong> Parallel Jobs with a fixed completion count<br>并行Job会启动多个Pod，此时需要设定Job的.spec.completions参数为一个正数，当正常结束的Pod数量达到该值则Job结束。<br><strong>3.</strong> Parallel Jobs with a work queue<br>任务队列方式的并行Job需要一个独立的Queue，Work item都在一个Queue中存放，不能设置Job的.spec.completions参数。</p><p>此时Job的特性：</p><ul><li>每个Pod能独立判断和决定是否还有任务项需要处理;</li><li>如果某个Pod正常结束，则Job不会再启动新的Pod;</li><li>如果一个Pod成功结束，则此时应该不存在其他Pod还在干活的情况，它们应该都处于即将结束、退出的状态;</li><li>如果所有的Pod都结束了，且至少一个Pod成功结束，则整个Job算是成功结束;</li></ul><p><strong>10.  Pod伸缩</strong><br>kubernetes中RC是用来保持集群中始终运行指定数目的实例，通过RC的scale机制可以完成Pod的扩容和缩容（伸缩）。</p><p><strong>1.  手动伸缩（scale）</strong></p><p><code># kubectl scale rc redis-slave --replicas=3</code></p><p><strong>2.  自动伸缩（HPA）</strong><br>Horizontal Pod Autoscaler（HPA）控制器用于实现基于CPU使用率进行自动Pod伸缩的功能。HPA控制器基于Master的kube-controller-manager服务启动参数–horizontal-pod-autoscaler-sync-period定义是时长（默认30秒），周期性监控目标Pod的CPU使用率，并在满足条件时对ReplicationController或Deployment中的Pod副本数进行调整，以符合用户定义的平均Pod CPU使用率。Pod CPU使用率来源于heapster组件，因此需安装该组件。</p><p>HPA可以通过kubectl autoscale命令进行快速创建或者使用yaml配置文件进行创建。创建之前需已存在一个RC或Deployment对象，并且该RC或Deployment中的Pod必须定义resources.requests.cpu的资源请求值，以便heapster采集到该Pod的CPU。</p><p>-  通过kubectl autoscale创建。</p><p>例如php-apache-rc.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: php-apache</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: php-apache</span><br><span class="line">      labels:</span><br><span class="line">        app: php-apache</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: php-apache</span><br><span class="line">        image: gcr.io/google_containers/hpa-example</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 200m</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>创建php-apache的RC</p><p><code>kubectl create -f php-apache-rc.yaml</code></p><p>php-apache-svc.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: php-apache</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: php-apache</span><br></pre></td></tr></table></figure><p>创建php-apache的Service</p><p><code>kubectl create -f php-apache-svc.yaml</code></p><p>创建HPA控制器</p><p><code>kubectl autoscale rc php-apache --min=1 --max=10 --cpu-percent=50</code></p><p>-  通过yaml配置文件创建</p><p>hpa-php-apache.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: php-apache</span><br><span class="line">spec:</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: v1</span><br><span class="line">    kind: ReplicationController</span><br><span class="line">    name: php-apache</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  maxReplicas: 10</span><br><span class="line">  targetCPUUtilizationPercentage: 50</span><br></pre></td></tr></table></figure><p>创建hpa</p><p><code>kubectl create -f hpa-php-apache.yaml</code></p><p>查看hpa</p><p><code>kubectl get hpa</code></p><p><strong>11. Pod滚动升级和回滚</strong><br>Kubernetes是一个很好的容器应用集群管理工具，尤其是采用ReplicationController这种自动维护应用生命周期事件的对象后，将容器应用管理的技巧发挥得淋漓尽致。在容器应用管理的诸多特性中，有一个特性是最能体现Kubernetes强大的集群应用管理能力的，那就是滚动升级。</p><p>滚动升级的精髓在于升级过程中依然能够保持服务的连续性，使外界对于升级的过程是无感知的。整个过程中会有三个状态：全部旧实例，新旧实例皆有，全部新实例。旧实例个数逐渐减少，新实例个数逐渐增加，最终达到旧实例个数为0，新实例个数达到理想的目标值。</p><p><strong>1.  使用kubectl rolling-update命令完成RC的滚动升级 和 回滚</strong><br>kubernetes中的RC的滚动升级通过执行 kubectl rolling-update 命令完成，该命令创建一个新的RC（与旧的RC在同一个命名空间中），然后自动控制旧的RC中的Pod副本数逐渐减少为0，同时新的RC中的Pod副本数从0逐渐增加到目标值，来完成Pod的升级。 需要注意的是：新旧RC要再同一个命名空间内。但滚动升级中Pod副本数（包括新Pod和旧Pod）保持原预期值。</p><p>1.1  通过配置文件实现<br>redis-master-controller-v2.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-master-v2</span><br><span class="line">  labels:</span><br><span class="line">    name: redis-master</span><br><span class="line">    version: v2</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    name: redis-master</span><br><span class="line">    version: v2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: redis-master</span><br><span class="line">        version: v2</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: master</span><br><span class="line">        image: kubeguide/redis-master:2.0</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 6379</span><br></pre></td></tr></table></figure><p>注意事项：<br>-  RC的名字（name）不能与旧RC的名字相同<br>-  在selector中应至少有一个Label与旧的RC的Label不同，以标识其为新的RC。例如本例中新增了version的Label。</p><p>运行kubectl rolling-update</p><p><code>kubectl rolling-update redis-master -f redis-master-controller-v2.yaml</code></p><p>1.2  通过kubectl rolling-update命令实现</p><p><code>kubectl rolling-update redis-master --image=redis-master:2.0</code></p><p>与使用配置文件实现不同在于，该执行结果旧的RC被删除，新的RC仍使用旧的RC的名字。</p><p><strong>1.3  通过kubectl rolling-update加参数–rollback实现回滚操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rolling-update redis-master --image=kubeguide/redis-master:2.0 --rollback</span><br></pre></td></tr></table></figure><p>rollback原理很简单，kubernetes记录了各个版本的PodTemplate,把旧的PodTemplate覆盖新的Template即可。 </p><p><strong>2.  通过Deployment的滚动升级 和 回滚</strong><br>采用RS来管理Pod实例。如果当前集群中的Pod实例数少于目标值，RS会拉起新的Pod，反之，则根据策略删除多余的Pod。Deployment正是利用了这样的特性，通过控制两个RS里面的Pod，从而实现升级。滚动升级是一种平滑过渡式的升级，在升级过程中，服务仍然可用，这是kubernetes作为应用服务化管理的关键一步！！服务无处不在，并且按需使用。Kubernetes Deployment滚动更新机制不同于ReplicationController rolling update，Deployment rollout还提供了滚动进度查询，滚动历史记录，回滚等能力，无疑是使用Kubernetes进行应用滚动发布的首选。配置示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        images: nginx:1.7.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>2.1  通过kubectl set image命令为Deployment设置新的镜像名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1</span><br></pre></td></tr></table></figure><p>2.2  使用kubectl edit命令修改Deployment的配置<br>将spec.template.spec.containers[0].images 从nginx:1.7.9 更改为1.9.1;  保存退出后，kubernetes会自动升级镜像。</p><p>2.3  通过”kubectl rollout status”可以查看deployment的<strong>更新过程</strong></p><p>在Deployment的定义中，可以通过spec.strategy指定Pod更新的策略：<br>- Recreate(重建)： 设置spec.strategy.type=Recreate,表示Deployment在更新Pod时，会先杀掉所有正在运行的Pod,然后创建新的Pod.<br>- RollingUpdate(滚动更新)：以滚动更新的方式来逐个更新Pod,可以通过设置spec.strategy.rollingUpdate下的两个参数（maxUnavailable和maxSurge）来控制滚动更新的过程。</p><p>通常来说，不鼓励更新Deployment的标签选择器，因为这样会导致Deployment选择的Pod列表发生变化，也可能与其它控制器产生冲突。</p><p>Deployment滚动升级的过程大致为：</p><ul><li>查找新的RS和旧的RS，并计算出新的Revision（这是Revision的最大值）；</li><li>对新的RS进行扩容操作；</li><li>对旧的RS进行缩容操作；</li><li>完成之后，删掉旧的RS；</li><li>通过Deployment状态到etcd;</li></ul><p><strong>2.4  Deployment的回滚</strong><br>所有Deployment的发布历史记录都保留在系统中，如果要进行回滚：<br>-  用 kubectl rollout history 命令检查这个Deployment部署的历史记录<br>-  用 kubectl rollout undo deployment/nginx-deployment 撤销本次发布回滚到上一个部署版本<br>-  用 kubectl rollout undo deployment/nginx-deployment –to-revision=2 回滚到指定版本</p><p><strong>2.5  暂停和恢复Deployment的部署操作，以完成复杂的修改</strong><br>对应一次复杂的Deployment配置修改，为了避免频繁触发Deployment的更新操作，可以暂停Deployment的更新操作，然后进行配置修改，再回复Deployment.一次性触发完整的更新操作。使用命令：kubectl rollout pause deployment/nginx-deployment</p><p>Kubernetes滚动升级和回滚操作分享 （Deployment的rollout方式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">产品部署完成上线之后，经常遇到需要升级服务的要求（只考虑更新镜像），以往比较粗糙的操作流程大致如下：</span><br><span class="line">方式一：找到 master具体调度到的所有目标node，删除其对应的镜像文件</span><br><span class="line">方式二：修改 file.yaml中镜像拉取策略为Always</span><br><span class="line">  </span><br><span class="line">删掉旧pod，并重新创建</span><br><span class="line"># kubectl delete -f /path/file.yaml</span><br><span class="line"># kubectl create -f /path/file.yaml</span><br><span class="line"> </span><br><span class="line">但是这样有一个比较棘手的问题，就是如果升级失败的回滚策略。因此想到利用kubernetes自身的滚动升级的工具，部署及升级流程如下：</span><br><span class="line"> </span><br><span class="line">1）在初次创建的时候，尽量加入参数--record，这样k8s会记录下本次启动的脚本 。</span><br><span class="line"># kubectl create -f /path/file.yaml --record</span><br><span class="line"> </span><br><span class="line">2）执行查看发布的历史记录，会显示现在已经记录的脚本及其序号。</span><br><span class="line">查看历史记录</span><br><span class="line"># kubectl rollout history deployment deploy-apigw</span><br><span class="line"> </span><br><span class="line">3）升级命令执行后会输出&quot;xxx image updated&quot;</span><br><span class="line">升级镜像</span><br><span class="line"># kubectl set image deployment/deploy-name containerName=newIMG:version</span><br><span class="line"># kubectl set image controllerType/controllerInstanceName underInstanceContainerName=image:version</span><br><span class="line"> </span><br><span class="line">4）查看pod状态，如果失败需要回滚操作</span><br><span class="line">回滚到上一个操作版本</span><br><span class="line"># kubectl rollout undo deployment/deploy-name</span><br><span class="line"> </span><br><span class="line">回滚到指定版本，版本号由第二步查看获得</span><br><span class="line"># kubectl rollout undo deployment/deploy-name --to-revision=3</span><br><span class="line"> </span><br><span class="line">需要注意：执行rollout undo操作之后，版本号会移动，需要确认版本号无误再undo</span><br></pre></td></tr></table></figure><p><strong>3.  其它管理对象的更新策略</strong><br>3.1  DaemonSet的更新策略<br>- OnDelete: 默认配置。只有旧的Pod被用户手动删除后，才触发新建操作。<br>- RollingUpdate: 旧版本的Pod将被自动杀掉，然后自动创建新版本的DaemonSet Pod.</p><p>3.2  StatefulSet的更新策略<br>StatefulSet的更新策略正逐渐向Deployment和DaemonSet的更新策略看齐。</p><p><strong>12.  资源需求和资源限制</strong><br>在Docker的范畴内，我们知道可以对运行的容器进行请求或消耗的资源进行限制。而在Kubernetes中也有同样的机制，容器或Pod可以进行申请和消耗的计算资源就是CPU和内存，这也是目前仅有的受支持的两种类型。相比较而言，CPU属于可压缩资源，即资源额度可按需收缩；而内存则是不可压缩型资源，对其执行收缩操作可能会导致某种程度的问题。</p><p>资源的隔离目前是属于容器级别，CPU和内存资源的配置需要Pod中的容器spec字段下进行定义。其具体字段，可以使用”requests”进行定义请求的确保资源可用量。也就是说容器的运行可能用不到这样的资源量，但是必须确保有这么多的资源供给。而”limits”是用于限制资源可用的最大值，属于硬限制。</p><p>在Kubernetes中，1个单位的CPU相当于虚拟机的1颗虚拟CPU（vCPU）或者是物理机上一个超线程的CPU，它支持分数计量方式，一个核心（1core）相当于1000个微核心（millicores），因此500m相当于是0.5个核心，即二分之一个核心。内存的计量方式也是一样的，默认的单位是字节，也可以使用E、P、T、G、M和K作为单位后缀，或者是Ei、Pi、Ti、Gi、Mi、Ki等形式单位后缀。</p><p><strong>-  容器的资源需求，资源限制</strong><br><strong>requests：需求</strong>，最低保障；<br><strong>limits：限制</strong>，硬限制；</p><p><strong>-  CPU</strong><br>1 颗逻辑 CPU<br>1=1000，millicores (微核心)<br>500m=0.5CPU</p><p><strong>-  资源需求</strong><br>自主式pod要求为stress容器确保128M的内存及五分之一个cpu核心资源可用，它运行stress-ng镜像启动一个进程进行内存性能压力测试，满载测试时它也会尽可能多地占用cpu资源，另外再启动一个专用的cpu压力测试进程。stress-ng是一个多功能系统压力测试工具，master/worker模型，master为主进程，负责生成和控制子进程，worker是负责执行各类特定测试的子进程。</p><p>集群中的每个节点都拥有定量的cpu和内存资源，调度pod时，仅那些被请求资源的余量可容纳当前调度的pod的请求量的节点才可作为目标节点。也就是说，kubernetes的调度器会根据容器的requests属性中定义的资源需求量来判定仅哪些节点可接受运行相关的pod资源，而对于一个节点的资源来说，每运行一个pod对象，其requestes中定义的请求量都要被预留，直到被所有pod对象瓜分完毕为止。</p><p>资源需求配置示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: &quot;128Mi&quot;</span><br><span class="line">        cpu: &quot;200m&quot;</span><br></pre></td></tr></table></figure><p>上面的配置清单中，nginx请求的CPU资源大小为200m，这意味着一个CPU核心足以满足nginx以最快的方式运行，其中对内存的期望可用大小为128Mi，实际运行时不一定会用到这么多的资源。考虑到内存的资源类型，在超出指定大小运行时存在会被OOM killer杀死的可能性，于是该请求值属于理想中使用的内存上限。</p><p><strong>-  资源限制</strong><br>容器的资源需求仅能达到为其保证可用的最少资源量的目的，它并不会限制容器的可用资源上限，因此对因应用程序自身存在bug等多种原因而导致的系统资源被长期占用的情况则无计可施，这就需要通过limits属性定义资源的最大可用量。资源分配时，可压缩型资源cpu的控制阈可自由调节，容器进程无法获得超出其cpu配额的可用时间。不过，如果进程申请分配超出其limits属性定义的硬限制的内存资源时，它将被OOM killer杀死。不过，随后可能会被其控制进程所重启。例如，容器进程的pod对象会被杀死并重启（重启策略为always或onfailure时），或者是容器进程的子进程被其父进程所重启。也就是说，CPU是属于可压缩资源，可进行自由地调节。内存属于硬限制性资源，当进程申请分配超过limit属性定义的内存大小时，该Pod将被OOM killer杀死。</p><p>与requests不同的是，limits并不会影响pod的调度结果，也就是说，一个节点上的所有pod对象的limits数量之和可以大于节点所拥有的资源量，即支持资源的过载使用。不过，这么一来一旦资源耗尽，尤其是内存资源耗尽，则必然会有容器因OOMKilled而终止。另外，kubernetes仅会确保pod能够获得他们请求的cpu时间额度，他们能否获得额外的cpu时间，则取决于其他正在运行的作业对cpu资源的占用情况。例如，对于总数为1000m的cpu来说，容器a请求使用200m，容器b请求使用500m，在不超出它们各自的最大限额的前提下，余下的300m在双方都需要时会以2:5的方式进行配置。</p><p>资源限制配置示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# vim memleak-pod.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: memleak-pod</span><br><span class="line">  labels:</span><br><span class="line">    app: memleak</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: simmemleak</span><br><span class="line">    image: saadali/simmemleak</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: &quot;64Mi&quot;</span><br><span class="line">        cpu: &quot;1&quot;</span><br><span class="line">      limits:</span><br><span class="line">        memory: &quot;64Mi&quot;</span><br><span class="line">        cpu: &quot;1&quot;</span><br><span class="line"> </span><br><span class="line">[root@k8s-master ~]# kubectl apply -f memleak-pod.yaml</span><br><span class="line">pod/memleak-pod created</span><br><span class="line">[root@k8s-master ~]# kubectl get pods -l app=memleak</span><br><span class="line">NAME          READY     STATUS      RESTARTS   AGE</span><br><span class="line">memleak-pod   0/1       OOMKilled   2          12s</span><br><span class="line">[root@k8s-master ~]# kubectl get pods -l app=memleak</span><br><span class="line">NAME          READY     STATUS             RESTARTS   AGE</span><br><span class="line">memleak-pod   0/1       CrashLoopBackOff   2          28s</span><br></pre></td></tr></table></figure><p>Pod资源默认的重启策略为Always，在上面例子中memleak因为内存限制而终止会立即重启，此时该Pod会被OOM killer杀死，在多次重复因为内存资源耗尽重启会触发Kunernetes系统的重启延迟，每次重启的时间会不断拉长，后面看到的Pod的状态通常为”CrashLoopBackOff”。</p><p><strong>-  容器的可见资源</strong><br>对于容器中运行top等命令观察资源可用量信息时，即便定义了requests和limits属性，虽然其可用资源受限于此两个属性的定义，但容器中可见资源量依然是节点级别可用总量。</p><p><strong>-  Pod的服务质量类别（QoS）</strong><br>这里还需要明确的是，kubernetes允许节点资源对limits的过载使用，这意味着节点无法同时满足其上的所有pod对象以资源满载的方式运行。在一个Kubernetes集群上，运行的Pod众多，那么当node节点都无法满足多个Pod对象的资源使用时 (节点内存资源紧缺时)，应该按照什么样的顺序去终止这些Pod对象呢？kubernetes无法自行对此做出决策，它需要借助于pod对象的优先级来判定终止Pod的优先问题。根据pod对象的requests和limits属性，kubernetes将pod对象归类到<strong>BestEffort</strong>、<strong>Burstable</strong>和<strong>Guaranteed</strong>三个服务质量类别：<br>Guaranteed：每个容器都为cpu资源设置了具有相同值的requests和limits属性，以及每个容器都为内存资源设置了具有相同值的requests和limits属性的pod资源会自动归属于此类别，这类pod资源具有最高优先级.<br>Burstable：至少有一个容器设置了cpu或内存资源的requests属性，但不满足Guaranteed类别要求的pod资源将自动归属此类别，它们具有中等优先级。<br>BestEffort：未为任何一个容器设置requests和limits属性的pod资源将自动归属于此类别，它们的优先级为最低级别。</p><p>内存资源紧缺时，BestEfford类别的容器将首当其冲地终止，因为系统不为其提供任何级别的资源保证，但换来的好处是：它们能够在可用时做到尽可能多地占用资源。若已然不存在BestEfford类别的容器，则接下来是有着中等优先级的Burstable类别的pod被终止。Guaranteed类别的容器拥有最高优先级，它们不会被杀死，除非其内存资源需求超限，或者OOM时没有其他更低优先级的pod资源存在。</p><p>每个运行状态的容器都有其OOM得分，得分越高越会被优先杀死。OOM得分主要根据两个维度进行计算：由QoS类别继承而来的默认分值和容器的可用内存资源比例。同等类别的pod资源的默认分值相同。同等级别优先级的pod资源在OOM时，与自身requests属性相比，其内存占用比例最大的pod对象将被首先杀死。需要特别说明的是，OOM是内存耗尽时的处理机制，它们与可压缩型资源cpu无关，因此cpu资源的需求无法得到保证时，pod仅仅是暂时获取不到相应的资源而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看 Qos</span><br><span class="line">[root@k8s-master01 ~]# kubectl describe pod/prometheus-858989bcfb-ml5gk -n kube-system|grep &quot;QoS Class&quot;</span><br><span class="line">QoS Class:       Burstable</span><br></pre></td></tr></table></figure><p><strong>13.  Pod持久存储方式</strong><br>volume是kubernetes Pod中多个容器访问的共享目录。volume被定义在pod上，被这个pod的多个容器挂载到相同或不同的路径下。volume的生命周期与pod的生命周期相同，pod内的容器停止和重启时一般不会影响volume中的数据。所以一般volume被用于持久化pod产生的数据。Kubernetes提供了众多的volume类型，包括emptyDir、hostPath、nfs、glusterfs、cephfs、ceph rbd等。</p><p><strong>1.  emptyDir</strong><br>emptyDir类型的volume在pod分配到node上时被创建，kubernetes会在node上自动分配 一个目录，因此无需指定宿主机node上对应的目录文件。这个目录的初始内容为空，当Pod从node上移除时，emptyDir中的数据会被永久删除。emptyDir Volume主要用于某些应用程序无需永久保存的临时目录，多个容器的共享目录等。下面是pod挂载emptyDir的示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pd</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: gcr.io/google_containers/test-webserver</span><br><span class="line">    name: test-container</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /cache</span><br><span class="line">      name: cache-volume</span><br><span class="line">  volumes:</span><br><span class="line">  - name: cache-volume</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>2.  hostPath</strong><br>hostPath Volume为pod挂载宿主机上的目录或文件，使得容器可以使用宿主机的高速文件系统进行存储。缺点是，在k8s中，pod都是动态在各node节点上调度。当一个pod在当前node节点上启动并通过hostPath存储了文件到本地以后，下次调度到另一个节点上启动时，就无法使用在之前节点上存储的文件。下面是pod挂载hostPath的示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pd</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: gcr.io/google_containers/test-webserver</span><br><span class="line">    name: test-container</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /test-pd</span><br><span class="line">      name: test-volume</span><br><span class="line">  volumes:</span><br><span class="line">  - name: test-volume</span><br><span class="line">    hostPath:</span><br><span class="line">      # directory location on host</span><br><span class="line">      path: /data</span><br></pre></td></tr></table></figure><p><strong>3.  pod持久存储</strong><br><strong>方式一： pod直接挂载nfs-server</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - name: nfs</span><br><span class="line">    nfs:</span><br><span class="line">      server: 192.168.1.1</span><br><span class="line">      path:&quot;/&quot;</span><br></pre></td></tr></table></figure><p>静态提供：管理员手动创建多个PV，供PVC使用。<br>动态提供：动态创建PVC特定的PV，并绑定。</p><p><strong>方式二： 手动创建PV</strong><br>Persistent Volume(持久化卷)简称PV，是一个Kubernetes资源对象，我们可以单独创建一个PV，它不和Pod直接发生关系，而是通过Persistent Volume Claim，简称PVC来实现动态绑定, 我们会在Pod定义里指定创建好的PVC, 然后PVC会根据Pod的要求去自动绑定合适的PV给Pod使用。</p><p><strong>持久化卷下PV和PVC概念</strong><br>Persistent Volume（PV）是由管理员设置的存储，它是群集的一部分。就像节点是集群中的资源一样，PV 也是集群中的资源。 PV 是 Volume 之类的卷插件，但具有独立于使用 PV 的 Pod 的生命周期。此 API 对象包含存储实现的细节，即 NFS、iSCSI 或特定于云供应商的存储系统。</p><p>PersistentVolumeClaim（PVC）是用户存储的请求。它与 Pod 相似，Pod 消耗节点资源，PVC 消耗 PV 资源。Pod 可以请求特定级别的资源（CPU 和内存）。PVC声明可以请求特定的大小和访问模式（例如，可以以读/写一次或只读多次模式挂载）。</p><p><strong>它和普通Volume的区别是什么呢？</strong><br>普通Volume和使用它的Pod之间是一种静态绑定关系，在定义Pod的文件里，同时定义了它使用的Volume。Volume是Pod的附属品，我们无法单独创建一个Volume，因为它不是一个独立的Kubernetes资源对象。</p><p>配置示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pv.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv003</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  nfs:</span><br><span class="line">    path: /somepath</span><br><span class="line">    server: 192.168.1.1</span><br></pre></td></tr></table></figure><p>查看PV</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get pv</span><br><span class="line">NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                             STORAGECLASS     REASON    AGE</span><br><span class="line">nfs-pv-heketi                              300Mi      ROX           Retain          Bound     default/nfs-pvc-heketi                                       7d</span><br><span class="line">pvc-02b8a30d-8e28-11e7-a07a-025622f1d9fa   50Gi       RWX           Retain          Bound     kube-public/jenkins-pvc           heketi-storage             5d</span><br></pre></td></tr></table></figure><p>PV可以设置三种回收策略：保留（Retain），回收（Recycle）和删除（Delete）。<br>保留策略：允许人工处理保留的数据。<br>删除策略：将删除pv和外部关联的存储资源，需要插件支持。<br>回收策略：将执行清除操作，之后可以被新的pvc使用，需要插件支持。</p><p>PV的状态:<br>Available ：资源尚未被claim使用<br>Bound ：已经绑定到某个pvc上<br>Released ： 对应的pvc被删除,但是资源还没有被集群回收<br>Failed ： 自动回收失败</p><p>PV访问权限<br>ReadWriteOnce ： 被单个节点mount为读写rw模式<br>ReadOnlyMany ： 被多个节点mount为只读ro模式<br>ReadWriteMany ： 被多个节点mount为读写rw模式</p><p>配置示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pv的配置定义</span><br><span class="line"># pvc.yaml</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: myclaim</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 5Gi</span><br><span class="line"> </span><br><span class="line">pod配置文件中应用pv</span><br><span class="line"># mypod.yaml</span><br><span class="line">volumes:</span><br><span class="line">  - name: mypod</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: myclaim</span><br></pre></td></tr></table></figure><p><strong>kubernetes 快速批量创建 PV &amp; PVC 脚本</strong><br>-  快速批量创建nfs pv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for` `i ``in` `&#123;3..6&#125;; ``do</span><br><span class="line">cat` `&lt;&lt;EOF` `| kubectl apply -f -</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  ``name: pv00$&#123;i&#125;</span><br><span class="line">spec:</span><br><span class="line">  ``capacity:</span><br><span class="line">    ``storage: 100Gi</span><br><span class="line">  ``accessModes:</span><br><span class="line">    ``- ReadWriteOnce  #这里根据需要配置ReadWriteOnce或者ReadWriteMany</span><br><span class="line">  ``persistentVolumeReclaimPolicy: Recycle</span><br><span class="line">  ``nfs:</span><br><span class="line">    ``path: /volume1/harbor/nfs$&#123;i&#125;</span><br><span class="line">    ``server: 192.168.2.4</span><br><span class="line">EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>​     </p><p>-  快速批量创建nfs pvc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;3..6&#125;; do</span><br><span class="line">cat &lt;&lt;EOF | kubectl delete -f -</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata: </span><br><span class="line">  name: pvc00$&#123;i&#125;-claim</span><br><span class="line">spec: </span><br><span class="line">  accessModes:  </span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  resources:   </span><br><span class="line">    requests:     </span><br><span class="line">      storage: 100Gi</span><br><span class="line">EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>14.  Pod水平自动扩展（HPA）</strong><br>Kubernetes有一个强大的功能，它能在运行的服务上进行编码并配置弹性伸缩。如果没有弹性伸缩功能，就很难适应部署的扩展和满足SLAs。这一功能称为Horizontal Pod Autoscaler (HPA)，这是kubernetes的一个很重要的资源对象。HPA是Kubernetes中弹性伸缩API组下的一个API资源。当前稳定的版本是autoscaling/v1，它只提供了对CPU自动缩放的支持。</p><p>Horizontal Pod Autoscaling，即pod的水平自动扩展。自动扩展主要分为两种，其一为水平扩展，针对于实例数目的增减；其二为垂直扩展，即单个实例可以使用的资源的增减。HPA属于水平自动扩展。HPA的操作对象是RC、RS或Deployment对应的Pod，根据观察到的CPU等实际使用量与用户的期望值进行比对，做出是否需要增减实例数量的决策。</p><p><strong>1.  为什么使用HPA</strong><br>使用HPA，可以根据资源的使用情况或者自定义的指标，实现部署的自动扩展和缩减，让部署的规模接近于实际服务的负载。HPA可以为您的服务带来两个直接的帮助：<br>- 在需要计算和内存资源时提供资源，在不需要时释放它们<br>- 按需增加/降低性能以实现SLA</p><p><strong>2.  HPA原理</strong><br>它根据Pod当前系统的负载来自动水平扩容，如果系统负载超过预定值，就开始增加Pod的个数，如果低于某个值，就自动减少Pod的个数。目前Kubernetes的HPA只能根据CPU等资源使用情况去度量系统的负载。HPA会根据监测到的CPU/内存利用率（资源指标），或基于第三方指标应用程序（如Prometheus等）提供的自定义指标，自动调整副本控制器、部署或者副本集合的pods数量（定义最小和最大pods数）。HPA是一种控制回路，它的周期由Kubernetes的controller manager 的–horizontal-pod-autoscaler-sync-period标志控制（默认值是30s）。</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190808181956206-983371113-1572435175067.png" alt="img"></p><p>在一般情况下HPA是由kubectl来提供支持的。可以使用kubectl进行创建、管理和删除：<br><strong>创建HPA</strong><br>- 带有manifest: “kubectl create -f <hpa_manifest>“<br>- 没有manifest(只支持CPU)：”kubectl autoscale deployment hello-world –min=2 –man=5 –-cpu-percent=50”</hpa_manifest></p><p><strong>获取hpa信息</strong><br>- 基本信息: “kubectl get hpa hello-world”<br>- 细节描述: “kubectl describe hpa hello-world”</p><p><strong>删除hpa</strong><br># kubectl delete hpa hello-world</p><p>下面是一个HPA manifest定义的例子：</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/907596-20190808184025296-452606415-1572435175071.png" alt="img"></p><p>这里使用了autoscaling/v2beta1版本，用到了cpu和内存指标<br>控制hello-world项目部署的自动缩放<br>定义了副本的最小值1<br>定义了副本的最大值10<br>当满足时调整大小：<br>- CPU使用率超过50%<br>- 内存使用超过100Mi</p><p><strong>3.  HPA条件</strong><br>HPA通过定期（定期轮询的时间通过–horizontal-pod-autoscaler-sync-period选项来设置，默认的时间为30秒）通过Status.PodSelector来查询pods的状态，获得pod的CPU使用率。然后，通过现有pods的CPU使用率的平均值（计算方式是最近的pod使用量（最近一分钟的平均值，从heapster中获得）除以设定的每个Pod的CPU使用率限额）跟目标使用率进行比较，并且在扩容时，还要遵循预先设定的副本数限制：MinReplicas &lt;= Replicas &lt;= MaxReplicas。</p><p>计算扩容后Pod的个数：sum(最近一分钟内某个Pod的CPU使用率的平均值)/CPU使用上限的整数+1</p><ol start="4"><li>HPA流程</li></ol><ul><li>创建HPA资源，设定目标CPU使用率限额，以及最大、最小实例数</li><li>收集一组中（PodSelector）每个Pod最近一分钟内的CPU使用率，并计算平均值</li><li>读取HPA中设定的CPU使用限额</li><li>计算：平均值之和/限额，求出目标调整的实例个数</li><li>目标调整的实例数不能超过1中设定的最大、最小实例数，如果没有超过，则扩容；超过，则扩容至最大的实例个数</li><li>回到2，不断循环</li></ul><p><strong>5.  HPA例外</strong><br>考虑到自动扩展的决策可能需要一段时间才会生效，甚至在短时间内会引入一些噪声。例如当pod所需要的CPU负荷过大，从而运行一个新的pod进行分流，在创建过程中，系统的CPU使用量可能会有一个攀升的过程。所以，在每一次作出决策后的一段时间内，将不再进行扩展决策。对于ScaleUp (纵向扩展)而言，这个时间段为3分钟，Scaledown为5分钟。</p><p>HPA允许一定范围内的CPU使用量的不稳定，只有 avg(CurrentPodsConsumption) / Target 小于90%或者大于110%时才会触发扩容或缩容，避免频繁扩容、缩容造成颠簸。</p><p><strong>【扩展】</strong><br>Scale Up (纵向扩展) ：主要是利用现有的存储系统，通过不断增加存储容量来满足数据增长的需求。但是这种方式只增加了容量，而带宽和计算能力并没有相应的增加。所以，整个存储系统很快就会达到性能瓶颈，需要继续扩展。</p><p>Scale-out (横向扩展)：通常是以节点为单位，每个节点往往将包含容量、处理能力和I / O带宽。一个节点被添加到存储系统，系统中的三种资源将同时升级。这种方式容量增长和性能扩展(即增加额外的控制器)是同时进行。而且，Scale-out架构的存储系统在扩展之后，从用户的视角看起来仍然是一个单一的系统，这一点与我们将多个相互独立的存储系统简单的叠加在一个机柜中是完全不同的。所以scale out方式使得存储系统升级工作大大简化，用户能够真正实现按需购买，降低TCO。</p><p><strong>6.  为什么HPA选择相对比率</strong><br>为了简便，选用了相对比率（90%的CPU资源）而不是0.6个CPU core来描述扩容、缩容条件。如果选择使用绝对度量，用户需要保证目标（限额）要比请求使用的低，否则，过载的Pod未必能够消耗那么多，从而自动扩容永远不会被触发：假设设置CPU为1个核，那么这个pod只能使用1个核，可能Pod在过载的情况下也不能完全利用这个核，所以扩容不会发生。在修改申请资源时，还有同时调整扩容的条件，比如将1个core变为1.2core，那么扩容条件应该同步改为1.2core，这样的话，就真是太麻烦了，与自动扩容的目标相悖。</p><p><strong>7.  安装需求</strong><br>在HPA可以在Kubernetes集群上使用之前，有一些元素需要在系统中安装和配置。检查确定Kubernetes集群服务正在运行并且至少包含了这些标志:<br>kube-api：requestheader-client-ca-file<br>kubelet：read-only-port 在端口10255<br>kube-controller：可选，只在需要和默认值不同时使用<br>horizontal-pod-autoscaler-downscale-delay：”5m0s”<br>horizontal-pod-autoscaler-upscale-delay：”3m0s”<br>horizontal-pod-autoscaler-sync-period： “30s”</p><p>HPA的实例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">1）创建Deployment</span><br><span class="line">[root@k8s-master01 ~]# cat &lt;&lt; EOF &gt; lykops-hpa-deploy.yaml</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: lykops-hpa-deploy</span><br><span class="line">  labels:</span><br><span class="line">    software: apache</span><br><span class="line">    project: lykops</span><br><span class="line">    app: hpa</span><br><span class="line">    version: v1     </span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: lykops-hpa-deploy</span><br><span class="line">      software: apache</span><br><span class="line">      project: lykops</span><br><span class="line">      app: hpa</span><br><span class="line">      version: v1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: lykops-hpa-deploy</span><br><span class="line">        software: apache</span><br><span class="line">        project: lykops</span><br><span class="line">        app: hpa</span><br><span class="line">        version: v1</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: lykops-hpa-deploy</span><br><span class="line">        image: web:apache</span><br><span class="line">        command: [ &quot;sh&quot;, &quot;/etc/run.sh&quot; ]</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: http</span><br><span class="line">          protocol: TCP</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 0.001</span><br><span class="line">            memory: 4Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 0.01</span><br><span class="line">            memory: 16Mi</span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line">创建这个实例</span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f lykops-hpa-deploy.yaml --record</span><br><span class="line"> </span><br><span class="line">2）创建service</span><br><span class="line">[root@k8s-master01 ~]#</span><br><span class="line">cat &lt;&lt; EOF &gt; lykops-hpa-deploy-svc.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: lykops-hpa-svc</span><br><span class="line">  labels:</span><br><span class="line">    software: apache</span><br><span class="line">    project: lykops</span><br><span class="line">    app: hpa</span><br><span class="line">    version: v1</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    software: apache</span><br><span class="line">    project: lykops</span><br><span class="line">    app: hpa</span><br><span class="line">    version: v1</span><br><span class="line">    name: lykops-hpa-deploy</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line">创建这个service</span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f lykops-hpa-deploy-svc.yaml</span><br><span class="line"> </span><br><span class="line">3）创建HPA</span><br><span class="line">[root@k8s-master01 ~]# cat &lt;&lt; EOF &gt; lykops-hpa.yaml</span><br><span class="line">apiVersion: autoscaling/v1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: lykops-hpa</span><br><span class="line">  labels:</span><br><span class="line">    software: apache</span><br><span class="line">    project: lykops</span><br><span class="line">    app: hpa</span><br><span class="line">    version: v1</span><br><span class="line">spec:</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    apiVersion: v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: lykops-hpa-deploy</span><br><span class="line">    #这里只能为这三项</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  maxReplicas: 10</span><br><span class="line">  targetCPUUtilizationPercentage: 5</span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line">创建这个HPA</span><br><span class="line">[root@k8s-master01 ~]# kubectl create -f lykops-hpa.yaml</span><br><span class="line"> </span><br><span class="line">4）测试</span><br><span class="line">多台机器不断访问service的clusterIP地址，然后可以看出是否增加pod数了</span><br></pre></td></tr></table></figure><h2 id="kubectl命令"><a href="#kubectl命令" class="headerlink" title="kubectl命令"></a>kubectl命令</h2><h3 id="1-查看类命令"><a href="#1-查看类命令" class="headerlink" title="1. 查看类命令"></a>1. 查看类命令</h3><p>获取节点相应服务的信息</p><blockquote><p>kubectl get nodes</p></blockquote><p>如果需要按selector名来查找相应的pod信息， 可以通过以下命令查看：</p><blockquote><p>kubectl get pod –selector name=tomcat</p></blockquote><p>查看K8S集群信息</p><blockquote><p>kubectl cluster-info</p></blockquote><p>查看各组件信息</p><blockquote><p>kubectl -s <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a> get componentstatuses</p></blockquote><p>查看pods所在的运行节点</p><blockquote><p>kubectl get pods -o wide</p></blockquote><p>如果需要通过某个命名空间查找节点信息， 可以通过以下命令查看：</p><blockquote><p>kubectl get pods -o wide -n kube-system</p><ul><li>-o wide 选项表示展示更多的Pod节点信息</li><li>-n &lt;命名空间&gt; 表示查询该命名空间下的Pod节点信息</li></ul></blockquote><p>如果需要查找所有命名空间下的所有Pod信息， 可以通过以下命令：</p><blockquote><p>kubectl get pods –all-namespaces<br>或<br>kubectl get pods -o wide –all-namespaces #列出更多的详细信息</p></blockquote><p>查看pods定义的详细信息</p><blockquote><p>kubectl get pods -o yaml</p></blockquote><p>查看运行的pod的环境变量</p><blockquote><p>kubectl exec &lt;pod名称&gt; env</p></blockquote><p>查看指定pod的日志</p><blockquote><p>kubectl logs -f pods/&lt;pod名称&gt; -n kube-system</p></blockquote><p>查看集群节点信息</p><blockquote><p>kubectl get nodes</p></blockquote><p>如果需要查看集群名称为<code>zone</code>下的集群节点信息, 可以使用以下命令：</p><blockquote><p>kubectl get nodes -l zone</p></blockquote><p>查看某个命名空间(如kube-system)下的所有service</p><blockquote><p>kubectl get services kubernetes-dashboard -n kube-system</p></blockquote><p>查看某个命名空间(如kube-system)下的所有发布信息</p><blockquote><p>kubectl get deployment kubernetes-dashboard -n kube-system</p></blockquote><p>查看资源信息</p><ul><li>根据service名查看资源信息</li></ul><blockquote><ul><li>kubectl describe service/kubernetes-dashboard –namespace=”kube-system”</li></ul></blockquote><ul><li>根据pod名称查看资源信息</li></ul><blockquote><ul><li>kubectl describe pods/kubernetes-dashboard-349859023-g6q8c –namespace=”kube-system”</li><li>kubectl describe pod nginx-772ai</li></ul></blockquote><h3 id="2-操作类命令"><a href="#2-操作类命令" class="headerlink" title="2. 操作类命令"></a>2. 操作类命令</h3><p>创建资源</p><blockquote><p>kubectl create -f &lt;文件名.yaml&gt;</p></blockquote><p>重建资源</p><blockquote><p>kubectl replace -f &lt;文件名  [–force]</p></blockquote><p>删除资源</p><blockquote><ul><li>强制删除某个文件名命名节点 <code>kubectl delete -f &lt;文件名&gt;</code></li><li>删除某个Pod命令节点 <code>kubectl delete pod &lt;pod名&gt;</code></li><li>删除某个Replication Controller命名节点 <code>kubectl delete rc &lt;rc名&gt;</code></li><li>删除某个服务命名节点 <code>kubectl delete service &lt;service名&gt;</code></li><li>删除所有Pod节点 <code>kubectl delete pod --all</code></li></ul></blockquote><p>动态伸缩操作</p><ul><li>为Replcation Controller名称为<code>nginx</code>动态扩展5个服务节点</li></ul><blockquote><p>kubectl scale rc nginx –replicas=5</p></blockquote><ul><li>为<code>redis-slave</code>部署5 个服务节点</li></ul><blockquote><p>kubectl scale deployment redis-slave –replicas=5</p></blockquote><ul><li>为<code>redis-slave-deployment.yaml</code>部署脚本下的服务扩展2个节点</li></ul><blockquote><p>kubectl scale –replicas=2 -f redis-slave-deployment.yaml</p></blockquote><p>进入Pod节点容器内进行操作</p><blockquote><p>kubectl exec -it redis-master-1033017107-q47hh /bin/bash</p></blockquote><p>滚动升级</p><ul><li>配置文件滚动升级</li></ul><blockquote><p>kubectl rolling-update redis-master -f redis-master-controller-v2.yaml</p></blockquote><ul><li>命令升级</li></ul><blockquote><p>kubectl rolling-update redis-master –image=redis-master:2.0</p></blockquote><ul><li>Pod版本回滚</li></ul><blockquote><p>kubectl rolling-update redis-master –image=redis-master:1.0 –rollback</p></blockquote><h3 id="3-更多操作命令"><a href="#3-更多操作命令" class="headerlink" title="3. 更多操作命令"></a>3. 更多操作命令</h3><p><a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener">Kubernetes</a></p><h2 id="Kubernetes-Service"><a href="#Kubernetes-Service" class="headerlink" title="Kubernetes Service"></a>Kubernetes Service</h2><p>在K8S集群中，Pod有用独立的IP，也具有独立的生命周期。一旦某个Node节点发生故障，ReplicationController会将该节点上的Pod迁移到集群中其他Node节点上。对于有多个Pod，为前端应用提供相同的服务，这时前端其实不关心调用的后台具体哪个Pod，这时就要用到Service。</p><blockquote><p>A Service in Kubernetes is an abstraction which defines a logical set of Pods and a policy by which to access them.</p></blockquote><p>Kubernetes中的Service是集群中一组Pod以及访问策略的抽象。可以通过YAML、JSON定义，目标Pods通常通过LabelSelector定义。通过<code>type</code>字段，服务定义了应用暴露的几种方式：</p><ul><li>ClusterIP，默认的方式，通过集群IP来对外提供服务，这种方式只能在集群内部访问。</li><li>NodePort，利用NAT技术在Node的指定端口上提供对外服务。外部应用通过<em>:</em>的方式访问。</li><li>LoadBalancer，利用外部的负载均衡设施进行服务的访问。</li><li>ExternalName，这是1.7版本之后 kube-dns 提供的功能。</li></ul><p>服务提供了在一组Pods之间分配流量的功能，同时也是因为服务这个抽象层的存在，Kubernetes才能够在不影响应用的情况下进行扩缩容。通常Service通过label和selector来确定可操作的对象。label可以在对象创建时指定，也可以在运行时修改。</p><h3 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get services</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   44s</span><br></pre></td></tr></table></figure><h3 id="对外部暴露服务"><a href="#对外部暴露服务" class="headerlink" title="对外部暴露服务"></a>对外部暴露服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080</span><br><span class="line">service &quot;kubernetes-bootcamp&quot; exposed</span><br><span class="line">$ kubectl get servicesNAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE</span><br><span class="line">kubernetes            ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP     2m</span><br><span class="line">kubernetes-bootcamp   NodePort    10.99.175.225   &lt;none&gt;        8080:32172/TCP   5s</span><br></pre></td></tr></table></figure><h3 id="查看服务详细信息"><a href="#查看服务详细信息" class="headerlink" title="查看服务详细信息"></a>查看服务详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe service/kubernetes-bootcamp</span><br><span class="line">Name:                     kubernetes-bootcamp</span><br><span class="line">Namespace:                default</span><br><span class="line">Labels:                   run=kubernetes-bootcamp</span><br><span class="line">Annotations:              &lt;none&gt;</span><br><span class="line">Selector:                 run=kubernetes-bootcamp</span><br><span class="line">Type:                     NodePort</span><br><span class="line">IP:                       10.99.175.225</span><br><span class="line">Port:                     &lt;unset&gt;  8080/TCP</span><br><span class="line">TargetPort:               8080/TCP</span><br><span class="line">NodePort:                 &lt;unset&gt;  32172/TCP</span><br><span class="line">Endpoints:                172.18.0.2:8080</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br></pre></td></tr></table></figure><p>这个例子中Node没有外部IP，所以显示为空。利用内部IP测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 172.17.0.11:32172</span><br><span class="line">Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-5c69669756-hmc69 | v=1</span><br></pre></td></tr></table></figure><h3 id="通过标签查询Pod和Service"><a href="#通过标签查询Pod和Service" class="headerlink" title="通过标签查询Pod和Service"></a>通过标签查询Pod和Service</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -l run=kubernetes-bootcamp</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-5c69669756-hmc69   1/1       Running   0          8m</span><br><span class="line">$ kubectl get services -l = run=kubernetes-bootcamp</span><br><span class="line">error: name cannot be provided when a selector is specified</span><br><span class="line">$ kubectl get services -l run=kubernetes-bootcamp</span><br><span class="line">NAME                  TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">kubernetes-bootcamp   NodePort   10.99.175.225   &lt;none&gt;        8080:32172/TCP   6m</span><br></pre></td></tr></table></figure><h3 id="新增标签"><a href="#新增标签" class="headerlink" title="新增标签"></a>新增标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label pod $POD_NAME app=v1</span><br><span class="line">pod &quot;kubernetes-bootcamp-5c69669756-hmc69&quot; labeled</span><br><span class="line">$ kubectl describe pods $POD_NAME</span><br><span class="line">Name:           kubernetes-bootcamp-5c69669756-hmc69</span><br><span class="line">Namespace:      default</span><br><span class="line">Node:           minikube/172.17.0.11</span><br><span class="line">Start Time:     Tue, 17 Jul 2018 05:20:35 +0000</span><br><span class="line">Labels:         app=v1</span><br><span class="line">                pod-template-hash=1725225312</span><br><span class="line">                run=kubernetes-bootcamp</span><br><span class="line">$ kubectl get pods -l app=v1</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-5c69669756-hmc69   1/1       Running   0          11m</span><br></pre></td></tr></table></figure><h3 id="删除服务"><a href="#删除服务" class="headerlink" title="删除服务"></a>删除服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get services</span><br><span class="line">NAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE</span><br><span class="line">kubernetes            ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP     12m</span><br><span class="line">kubernetes-bootcamp   NodePort    10.99.175.225   &lt;none&gt;        8080:32172/TCP   10m</span><br><span class="line">$ kubectl delete service -l run=kubernetes-bootcamp</span><br><span class="line">service &quot;kubernetes-bootcamp&quot; deleted</span><br><span class="line">$ kubectl get services</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   12m</span><br></pre></td></tr></table></figure><h2 id="helm"><a href="#helm" class="headerlink" title="helm"></a>helm</h2><p>Helm 是 Kubernetes 生态系统中的一个软件包管理工具。本文将介绍 Helm 中的相关概念和基本工作原理，并通过一个具体的示例学习如何使用 Helm 打包、分发、安装、升级及回退 Kubernetes 应用。</p><h3 id="Kubernetes-应用部署的挑战"><a href="#Kubernetes-应用部署的挑战" class="headerlink" title="Kubernetes 应用部署的挑战"></a>Kubernetes 应用部署的挑战</h3><p>Kubernetes 是一个提供了基于容器的应用集群管理解决方案，Kubernetes 为容器化应用提供了部署运行、资源调度、服务发现和动态伸缩等一系列完整功能。</p><p>Kubernetes 的核心设计理念是: 用户定义要部署的应用程序的规则，而 Kubernetes 则负责按照定义的规则部署并运行应用程序。如果应用程序出现问题导致偏离了定义的规格，Kubernetes 负责对其进行自动修正。例如：定义的应用规则要求部署两个实例（Pod），其中一个实例异常终止了，Kubernetes 会检查到并重新启动一个新的实例。</p><p>用户通过使用 Kubernetes API 对象来描述应用程序规则，包括 Pod、Service、Volume、Namespace、ReplicaSet、Deployment、Job等等。一般这些资源对象的定义需要写入一系列的 YAML 文件中，然后通过 Kubernetes 命令行工具 Kubectl 调 Kubernetes API 进行部署。</p><p>以一个典型的三层应用 Wordpress 为例，该应用程序就涉及到多个 Kubernetes API 对象，而要描述这些 Kubernetes API 对象就可能要同时维护多个 YAML 文件。</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/helm01-1572568214793.png" alt="img"></p><p>从上图可以看到，在进行 Kubernetes 软件部署时，我们面临下述几个问题：</p><ul><li>如何管理、编辑和更新这些这些分散的 Kubernetes 应用配置文件。</li><li>如何把一套相关的配置文件作为一个应用进行管理。</li><li>如何分发和重用 Kubernetes 的应用配置。</li></ul><p>Helm 的出现就是为了很好地解决上面这些问题。</p><h3 id="Helm-是什么？"><a href="#Helm-是什么？" class="headerlink" title="Helm 是什么？"></a>Helm 是什么？</h3><p>Helm 是 <a href="https://deis.com/" target="_blank" rel="noopener">Deis</a> 开发的一个用于 Kubernetes 应用的包管理工具，主要用来管理 Charts。有点类似于 Ubuntu 中的 APT 或 CentOS 中的 YUM。</p><p>Helm Chart 是用来封装 Kubernetes 原生应用程序的一系列 YAML 文件。可以在你部署应用的时候自定义应用程序的一些 Metadata，以便于应用程序的分发。</p><p>对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。</p><p>对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。</p><h3 id="Helm-组件及相关术语"><a href="#Helm-组件及相关术语" class="headerlink" title="Helm 组件及相关术语"></a>Helm 组件及相关术语</h3><ul><li>Helm</li></ul><p>Helm 是一个命令行下的客户端工具。主要用于 Kubernetes 应用程序 Chart 的创建、打包、发布以及创建和管理本地和远程的 Chart 仓库。</p><ul><li>Tiller</li></ul><p>Tiller 是 Helm 的服务端，部署在 Kubernetes 集群中。Tiller 用于接收 Helm 的请求，并根据 Chart 生成 Kubernetes 的部署文件（ Helm 称为 Release ），然后提交给 Kubernetes 创建应用。Tiller 还提供了 Release 的升级、删除、回滚等一系列功能。</p><ul><li>Chart</li></ul><p>Helm 的软件包，采用 TAR 格式。类似于 APT 的 DEB 包或者 YUM 的 RPM 包，其包含了一组定义 Kubernetes 资源相关的 YAML 文件。</p><ul><li>Repoistory</li></ul><p>Helm 的软件仓库，Repository 本质上是一个 Web 服务器，该服务器保存了一系列的 Chart 软件包以供用户下载，并且提供了一个该 Repository 的 Chart 包的清单文件以供查询。Helm 可以同时管理多个不同的 Repository。</p><ul><li>Release</li></ul><p>使用 <code>helm install</code> 命令在 Kubernetes 集群中部署的 Chart 称为 Release。</p><blockquote><p>注：需要注意的是：Helm 中提到的 Release 和我们通常概念中的版本有所不同，这里的 Release 可以理解为 Helm 使用 Chart 包部署的一个应用实例。</p></blockquote><h3 id="Helm-工作原理"><a href="#Helm-工作原理" class="headerlink" title="Helm 工作原理"></a>Helm 工作原理</h3><p>这张图描述了 Helm 的几个关键组件 Helm（客户端）、Tiller（服务器）、Repository（Chart 软件仓库）、Chart（软件包）之间的关系。</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/helm02-1572568214827.png" alt="img"></p><p><strong>Chart Install 过程</strong></p><ul><li>Helm 从指定的目录或者 TAR 文件中解析出 Chart 结构信息。</li><li>Helm 将指定的 Chart 结构和 Values 信息通过 gRPC 传递给 Tiller。</li><li>Tiller 根据 Chart 和 Values 生成一个 Release。</li><li>Tiller 将 Release 发送给 Kubernetes 用于生成 Release。</li></ul><p><strong>Chart Update 过程</strong></p><ul><li>Helm 从指定的目录或者 TAR 文件中解析出 Chart 结构信息。</li><li>Helm 将需要更新的 Release 的名称、Chart 结构和 Values 信息传递给 Tiller。</li><li>Tiller 生成 Release 并更新指定名称的 Release 的 History。</li><li>Tiller 将 Release 发送给 Kubernetes 用于更新 Release。</li></ul><p><strong>Chart Rollback 过程</strong></p><ul><li>Helm 将要回滚的 Release 的名称传递给 Tiller。</li><li>Tiller 根据 Release 的名称查找 History。</li><li>Tiller 从 History 中获取上一个 Release。</li><li>Tiller 将上一个 Release 发送给 Kubernetes 用于替换当前 Release。</li></ul><p><strong>Chart 处理依赖说明</strong></p><p>Tiller 在处理 Chart 时，直接将 Chart 以及其依赖的所有 Charts 合并为一个 Release，同时传递给 Kubernetes。因此 Tiller 并不负责管理依赖之间的启动顺序。Chart 中的应用需要能够自行处理依赖关系。</p><h3 id="部署-Helm"><a href="#部署-Helm" class="headerlink" title="部署 Helm"></a>部署 Helm</h3><h4 id="安装-Helm-客户端"><a href="#安装-Helm-客户端" class="headerlink" title="安装 Helm 客户端"></a>安装 Helm 客户端</h4><p>Helm 的安装方式很多，这里采用二进制的方式安装。更多安装方法可以参考 Helm 的<a href="https://docs.helm.sh/using_helm/#installing-helm" target="_blank" rel="noopener">官方帮助文档</a>。</p><ul><li>使用官方提供的脚本一键安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get &gt; get_helm.sh</span><br><span class="line">$ chmod 700 get_helm.sh</span><br><span class="line">$ ./get_helm.sh</span><br></pre></td></tr></table></figure><ul><li>手动下载安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 下载 Helm </span><br><span class="line">$ wget https://storage.googleapis.com/kubernetes-helm/helm-v2.9.1-linux-amd64.tar.gz</span><br><span class="line"># 解压 Helm</span><br><span class="line">$ tar -zxvf helm-v2.9.1-linux-amd64.tar.gz</span><br><span class="line"># 复制客户端执行文件到 bin 目录下</span><br><span class="line">$ cp linux-amd64/helm /usr/local/bin/</span><br></pre></td></tr></table></figure><blockquote><p>注：<a href="http://storage.googleapis.com/" target="_blank" rel="noopener">storage.googleapis.com</a> 默认是不能访问的，该问题请自行解决。</p></blockquote><h4 id="安装-Helm-服务器端-Tiller"><a href="#安装-Helm-服务器端-Tiller" class="headerlink" title="安装 Helm 服务器端 Tiller"></a>安装 Helm 服务器端 Tiller</h4><p>Tiller 是以 Deployment 方式部署在 Kubernetes 集群中的，只需使用以下指令便可简单的完成安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm init</span><br></pre></td></tr></table></figure><p>由于 Helm 默认会去 <a href="http://storage.googleapis.com/" target="_blank" rel="noopener">storage.googleapis.com</a> 拉取镜像，如果你当前执行的机器不能访问该域名的话可以使用以下命令来安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用阿里云镜像安装并把默认仓库设置为阿里云上的镜像仓库</span><br><span class="line">$ helm init --upgrade --tiller-image registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.9.1 --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span><br></pre></td></tr></table></figure><h5 id="给-Tiller-授权"><a href="#给-Tiller-授权" class="headerlink" title="给 Tiller 授权"></a>给 Tiller 授权</h5><p>因为 Helm 的服务端 Tiller 是一个部署在 Kubernetes 中 Kube-System Namespace 下 的 Deployment，它会去连接 Kube-Api 在 Kubernetes 里创建和删除应用。</p><p>而从 Kubernetes 1.6 版本开始，API Server 启用了 RBAC 授权。目前的 Tiller 部署时默认没有定义授权的 ServiceAccount，这会导致访问 API Server 时被拒绝。所以我们需要明确为 Tiller 部署添加授权。</p><ul><li>创建 Kubernetes 的服务帐号和绑定角色</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deployment --all-namespaces</span><br><span class="line">NAMESPACE     NAME                   DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kube-system   tiller-deploy          1         1         1            1           1h</span><br><span class="line">$ kubectl create serviceaccount --namespace kube-system tiller</span><br><span class="line">$ kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller</span><br></pre></td></tr></table></figure><ul><li>为 Tiller 设置帐号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 使用 kubectl patch 更新 API 对象</span><br><span class="line">$ kubectl patch deploy --namespace kube-system tiller-deploy -p &apos;&#123;&quot;spec&quot;:&#123;&quot;template&quot;:&#123;&quot;spec&quot;:&#123;&quot;serviceAccount&quot;:&quot;tiller&quot;&#125;&#125;&#125;&#125;&apos;</span><br><span class="line">deployment.extensions &quot;tiller-deploy&quot; patched</span><br></pre></td></tr></table></figure><ul><li>查看是否授权成功</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy --namespace kube-system   tiller-deploy  --output yaml|grep  serviceAccount</span><br><span class="line">serviceAccount: tiller</span><br><span class="line">serviceAccountName: tiller</span><br></pre></td></tr></table></figure><h5 id="验证-Tiller-是否安装成功"><a href="#验证-Tiller-是否安装成功" class="headerlink" title="验证 Tiller 是否安装成功"></a>验证 Tiller 是否安装成功</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-system get pods|grep tiller</span><br><span class="line">tiller-deploy-6d68f5c78f-nql2z          1/1       Running   0          5m</span><br><span class="line"></span><br><span class="line">$ helm version</span><br><span class="line">Client: &amp;version.Version&#123;SemVer:&quot;v2.9.1&quot;, GitCommit:&quot;20adb27c7c5868466912eebdf6664e7390ebe710&quot;, GitTreeState:&quot;clean&quot;&#125;</span><br><span class="line">Server: &amp;version.Version&#123;SemVer:&quot;v2.9.1&quot;, GitCommit:&quot;20adb27c7c5868466912eebdf6664e7390ebe710&quot;, GitTreeState:&quot;clean&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="卸载-Helm-服务器端-Tiller"><a href="#卸载-Helm-服务器端-Tiller" class="headerlink" title="卸载 Helm 服务器端 Tiller"></a>卸载 Helm 服务器端 Tiller</h4><p>如果你需要在 Kubernetes 中卸载已部署的 Tiller，可使用以下命令完成卸载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm reset</span><br></pre></td></tr></table></figure><h3 id="构建一个-Helm-Chart"><a href="#构建一个-Helm-Chart" class="headerlink" title="构建一个 Helm Chart"></a>构建一个 Helm Chart</h3><p>下面我们通过一个完整的示例来学习如何使用 Helm 创建、打包、分发、安装、升级及回退Kubernetes应用。</p><h4 id="创建一个名为-mychart-的-Chart"><a href="#创建一个名为-mychart-的-Chart" class="headerlink" title="创建一个名为 mychart 的 Chart"></a>创建一个名为 mychart 的 Chart</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm create mychart</span><br></pre></td></tr></table></figure><p>该命令创建了一个 mychart 目录，该目录结构如下所示。这里我们主要关注目录中的 Chart.yaml、values.yaml、NOTES.txt 和 Templates 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tree mychart/</span><br><span class="line">mychart/</span><br><span class="line">├── charts</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── templates</span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── _helpers.tpl</span><br><span class="line">│   ├── ingress.yaml</span><br><span class="line">│   ├── NOTES.txt</span><br><span class="line">│   └── service.yaml</span><br><span class="line">└── values.yaml</span><br><span class="line"></span><br><span class="line">2 directories, 7 files</span><br></pre></td></tr></table></figure><ul><li>Chart.yaml 用于描述这个 Chart的相关信息，包括名字、描述信息以及版本等。</li><li>values.yaml 用于存储 templates 目录中模板文件中用到变量的值。</li><li>NOTES.txt 用于介绍 Chart 部署后的一些信息，例如：如何使用这个 Chart、列出缺省的设置等。</li><li>Templates 目录下是 YAML 文件的模板，该模板文件遵循 Go template 语法。</li></ul><p>Templates 目录下 YAML 文件模板的值默认都是在 values.yaml 里定义的，比如在 deployment.yaml 中定义的容器镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: &quot;&#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag &#125;&#125;&quot;</span><br></pre></td></tr></table></figure><p>其中的 <code>.Values.image.repository</code> 的值就是在 values.yaml 里定义的 nginx，<code>.Values.image.tag</code> 的值就是 stable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat mychart/values.yaml|grep repository</span><br><span class="line">repository: nginx</span><br><span class="line"></span><br><span class="line">$ cat mychart/values.yaml|grep tag</span><br><span class="line">tag: stable</span><br></pre></td></tr></table></figure><p>以上两个变量值是在 <code>create chart</code> 的时候就自动生成的默认值，你可以根据实际情况进行修改。</p><blockquote><p>如果你需要了解更多关于 Go 模板的相关信息，可以查看 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 的一个关于 <a href="https://gohugo.io/templates/go-templates/" target="_blank" rel="noopener">Go 模板</a> 的介绍。</p></blockquote><h4 id="编写应用的介绍信息"><a href="#编写应用的介绍信息" class="headerlink" title="编写应用的介绍信息"></a>编写应用的介绍信息</h4><p>打开 Chart.yaml, 填写你部署的应用的详细信息，以 mychart 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat mychart/Chart.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">appVersion: &quot;1.0&quot;</span><br><span class="line">description: A Helm chart for Kubernetes</span><br><span class="line">name: mychart</span><br><span class="line">version: 0.1.0</span><br></pre></td></tr></table></figure><h4 id="编写应用具体部署信息"><a href="#编写应用具体部署信息" class="headerlink" title="编写应用具体部署信息"></a>编写应用具体部署信息</h4><p>编辑 values.yaml，它默认会在 Kubernetes 部署一个 Nginx。下面是 mychart 应用的 values.yaml 文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ cat mychart/values.yaml</span><br><span class="line"># Default values for mychart.</span><br><span class="line"># This is a YAML-formatted file.</span><br><span class="line"># Declare variables to be passed into your templates.</span><br><span class="line"></span><br><span class="line">replicaCount: 1</span><br><span class="line"></span><br><span class="line">image:</span><br><span class="line">  repository: nginx</span><br><span class="line">  tag: stable</span><br><span class="line">  pullPolicy: IfNotPresent</span><br><span class="line"></span><br><span class="line">service:</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">ingress:</span><br><span class="line">  enabled: false</span><br><span class="line">  annotations: &#123;&#125;</span><br><span class="line">    # kubernetes.io/ingress.class: nginx</span><br><span class="line">    # kubernetes.io/tls-acme: &quot;true&quot;</span><br><span class="line">  path: /</span><br><span class="line">  hosts:</span><br><span class="line">    - chart-example.local</span><br><span class="line">  tls: []</span><br><span class="line">  #  - secretName: chart-example-tls</span><br><span class="line">  #    hosts:</span><br><span class="line">  #      - chart-example.local</span><br><span class="line"></span><br><span class="line">resources: &#123;&#125;</span><br><span class="line">  # We usually recommend not to specify default resources and to leave this as a conscious</span><br><span class="line">  # choice for the user. This also increases chances charts run on environments with little</span><br><span class="line">  # resources, such as Minikube. If you do want to specify resources, uncomment the following</span><br><span class="line">  # lines, adjust them as necessary, and remove the curly braces after &apos;resources:&apos;.</span><br><span class="line">  # limits:</span><br><span class="line">  #  cpu: 100m</span><br><span class="line">  #  memory: 128Mi</span><br><span class="line">  # requests:</span><br><span class="line">  #  cpu: 100m</span><br><span class="line">  #  memory: 128Mi</span><br><span class="line"></span><br><span class="line">nodeSelector: &#123;&#125;</span><br><span class="line"></span><br><span class="line">tolerations: []</span><br><span class="line"></span><br><span class="line">affinity: &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="检查依赖和模板配置是否正确"><a href="#检查依赖和模板配置是否正确" class="headerlink" title="检查依赖和模板配置是否正确"></a>检查依赖和模板配置是否正确</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ helm lint mychart/</span><br><span class="line">==&gt; Linting .</span><br><span class="line">[INFO] Chart.yaml: icon is recommended</span><br><span class="line"></span><br><span class="line">1 chart(s) linted, no failures</span><br></pre></td></tr></table></figure><p>如果文件格式错误，可以根据提示进行修改。</p><h4 id="将应用打包"><a href="#将应用打包" class="headerlink" title="将应用打包"></a>将应用打包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm package mychart</span><br><span class="line">Successfully packaged chart and saved it to: /home/k8s/mychart-0.1.0.tgz</span><br></pre></td></tr></table></figure><p>mychart 目录会被打包为一个 mychart-0.1.0.tgz 格式的压缩包，该压缩包会被放到当前目录下，并同时被保存到了 Helm 的本地缺省仓库目录中。</p><p>如果你想看到更详细的输出，可以加上 <code>--debug</code> 参数来查看打包的输出，输出内容应该类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm package mychart --debug</span><br><span class="line">Successfully packaged chart and saved it to: /home/k8s/mychart-0.1.0.tgz</span><br><span class="line">[debug] Successfully saved /home/k8s/mychart-0.1.0.tgz to /home/k8s/.helm/repository/local</span><br></pre></td></tr></table></figure><h4 id="将应用发布到-Repository"><a href="#将应用发布到-Repository" class="headerlink" title="将应用发布到 Repository"></a>将应用发布到 Repository</h4><p>虽然我们已经打包了 Chart 并发布到了 Helm 的本地目录中，但通过 <code>helm search</code> 命令查找，并不能找不到刚才生成的 mychart包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm search mychart</span><br><span class="line">No results found</span><br></pre></td></tr></table></figure><p>这是因为 Repository 目录中的 Chart 包还没有被 Helm 管理。通过 <code>helm repo list</code> 命令可以看到目前 Helm 中已配置的 Repository 的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo list</span><br><span class="line">NAME    URL</span><br><span class="line">stable  https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span><br></pre></td></tr></table></figure><blockquote><p>注：新版本中执行 helm init 命令后默认会配置一个名为 local 的本地仓库。</p></blockquote><p>我们可以在本地启动一个 Repository Server，并将其加入到 Helm Repo 列表中。Helm Repository 必须以 Web 服务的方式提供，这里我们就使用 <code>helm serve</code> 命令启动一个 Repository Server，该 Server 缺省使用 <code>$HOME/.helm/repository/local</code> 目录作为 Chart 存储，并在 8879 端口上提供服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm serve &amp;</span><br><span class="line">Now serving you on 127.0.0.1:8879</span><br></pre></td></tr></table></figure><p>默认情况下该服务只监听 127.0.0.1，如果你要绑定到其它网络接口，可使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm serve --address 192.168.100.211:8879 &amp;</span><br></pre></td></tr></table></figure><p>如果你想使用指定目录来做为 Helm Repository 的存储目录，可以加上 <code>--repo-path</code> 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm serve --address 192.168.100.211:8879 --repo-path /data/helm/repository/ --url http://192.168.100.211:8879/charts/</span><br></pre></td></tr></table></figure><p>通过 <code>helm repo index</code> 命令将 Chart 的 Metadata 记录更新在 index.yaml 文件中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 更新 Helm Repository 的索引文件</span><br><span class="line">$ cd /home/k8s/.helm/repository/local</span><br><span class="line">$ helm repo index --url=http://192.168.100.211:8879 .</span><br></pre></td></tr></table></figure><p>完成启动本地 Helm Repository Server 后，就可以将本地 Repository 加入 Helm 的 Repo 列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add local http://127.0.0.1:8879</span><br><span class="line">&quot;local&quot; has been added to your repositories</span><br></pre></td></tr></table></figure><p>现在再次查找 mychart 包，就可以搜索到了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo update</span><br><span class="line">$ helm search mychart</span><br><span class="line">NAME         CHART VERSIONAPP VERSIONDESCRIPTION</span><br><span class="line">local/mychart0.1.0        1.0        A Helm chart for Kubernetes</span><br></pre></td></tr></table></figure><h4 id="在-Kubernetes-中部署应用"><a href="#在-Kubernetes-中部署应用" class="headerlink" title="在 Kubernetes 中部署应用"></a>在 Kubernetes 中部署应用</h4><h5 id="部署一个应用"><a href="#部署一个应用" class="headerlink" title="部署一个应用"></a>部署一个应用</h5><p>Chart 被发布到仓储后，就可以通过 <code>helm install</code> 命令部署该 Chart。</p><ul><li>检查配置和模板是否有效</li></ul><p>当使用 <code>helm install</code> 命令部署应用时，实际上就是将 templates 目录下的模板文件渲染成 Kubernetes 能够识别的 YAML 格式。</p><p>在部署前我们可以使用 <code>helm install --dry-run --debug &lt;chart_dir&gt; --name &lt;release_name&gt;</code>命令来验证 Chart 的配置。该输出中包含了模板的变量配置与最终渲染的 YAML 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">$ helm install --dry-run --debug local/mychart --name mike-test</span><br><span class="line">[debug] Created tunnel using local port: &apos;46649&apos;</span><br><span class="line"></span><br><span class="line">[debug] SERVER: &quot;127.0.0.1:46649&quot;</span><br><span class="line"></span><br><span class="line">[debug] Original chart version: &quot;&quot;</span><br><span class="line">[debug] Fetched local/mychart to /home/k8s/.helm/cache/archive/mychart-0.1.0.tgz</span><br><span class="line"></span><br><span class="line">[debug] CHART PATH: /home/k8s/.helm/cache/archive/mychart-0.1.0.tgz</span><br><span class="line"></span><br><span class="line">NAME:   mike-test</span><br><span class="line">REVISION: 1</span><br><span class="line">RELEASED: Mon Jul 23 10:39:49 2018</span><br><span class="line">CHART: mychart-0.1.0</span><br><span class="line">USER-SUPPLIED VALUES:</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">COMPUTED VALUES:</span><br><span class="line">affinity: &#123;&#125;</span><br><span class="line">image:</span><br><span class="line">  pullPolicy: IfNotPresent</span><br><span class="line">  repository: nginx</span><br><span class="line">  tag: stable</span><br><span class="line">ingress:</span><br><span class="line">  annotations: &#123;&#125;</span><br><span class="line">  enabled: false</span><br><span class="line">  hosts:</span><br><span class="line">  - chart-example.local</span><br><span class="line">  path: /</span><br><span class="line">  tls: []</span><br><span class="line">nodeSelector: &#123;&#125;</span><br><span class="line">replicaCount: 1</span><br><span class="line">resources: &#123;&#125;</span><br><span class="line">service:</span><br><span class="line">  port: 80</span><br><span class="line">  type: ClusterIP</span><br><span class="line">tolerations: []</span><br><span class="line"></span><br><span class="line">HOOKS:</span><br><span class="line">MANIFEST:</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># Source: mychart/templates/service.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: mike-test-mychart</span><br><span class="line">  labels:</span><br><span class="line">    app: mychart</span><br><span class="line">    chart: mychart-0.1.0</span><br><span class="line">    release: mike-test</span><br><span class="line">    heritage: Tiller</span><br><span class="line">spec:</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  ports:</span><br><span class="line">    - port: 80</span><br><span class="line">      targetPort: http</span><br><span class="line">      protocol: TCP</span><br><span class="line">      name: http</span><br><span class="line">  selector:</span><br><span class="line">    app: mychart</span><br><span class="line">    release: mike-test</span><br><span class="line">---</span><br><span class="line"># Source: mychart/templates/deployment.yaml</span><br><span class="line">apiVersion: apps/v1beta2</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: mike-test-mychart</span><br><span class="line">  labels:</span><br><span class="line">    app: mychart</span><br><span class="line">    chart: mychart-0.1.0</span><br><span class="line">    release: mike-test</span><br><span class="line">    heritage: Tiller</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: mychart</span><br><span class="line">      release: mike-test</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: mychart</span><br><span class="line">        release: mike-test</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: mychart</span><br><span class="line">          image: &quot;nginx:stable&quot;</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: 80</span><br><span class="line">              protocol: TCP</span><br><span class="line">          livenessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /</span><br><span class="line">              port: http</span><br><span class="line">          readinessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /</span><br><span class="line">              port: http</span><br><span class="line">          resources:</span><br><span class="line">            &#123;&#125;</span><br></pre></td></tr></table></figure><p>验证完成没有问题后，我们就可以使用以下命令将其部署到 Kubernetes 上了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 部署时需指定 Chart 名及 Release（部署的实例）名。</span><br><span class="line">$ helm install local/mychart --name mike-test</span><br><span class="line">NAME:   mike-test</span><br><span class="line">LAST DEPLOYED: Mon Jul 23 10:41:20 2018</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: DEPLOYED</span><br><span class="line"></span><br><span class="line">RESOURCES:</span><br><span class="line">==&gt; v1/Service</span><br><span class="line">NAME               TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)  AGE</span><br><span class="line">mike-test-mychart  ClusterIP  10.254.120.177  &lt;none&gt;       80/TCP   1s</span><br><span class="line"></span><br><span class="line">==&gt; v1beta2/Deployment</span><br><span class="line">NAME               DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE</span><br><span class="line">mike-test-mychart  1        0        0           0          0s</span><br><span class="line"></span><br><span class="line">==&gt; v1/Pod(related)</span><br><span class="line">NAME                                READY  STATUS   RESTARTS  AGE</span><br><span class="line">mike-test-mychart-6d56f8c8c9-d685v  0/1    Pending  0         0s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">1. Get the application URL by running these commands:</span><br><span class="line">  export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=mychart,release=mike-test&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line">  echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;</span><br><span class="line">  kubectl port-forward $POD_NAME 8080:80</span><br></pre></td></tr></table></figure><blockquote><p>注：helm install 默认会用到 socat，需要在所有节点上安装 socat 软件包。</p></blockquote><p>完成部署后，现在 Nginx 就已经部署到 Kubernetes 集群上。在本地主机上执行提示中的命令后，就可在本机访问到该 Nginx 实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=mychart,release=mike-test&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line">$ echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;</span><br><span class="line">$ kubectl port-forward $POD_NAME 8080:80</span><br></pre></td></tr></table></figure><p>在本地访问 Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:8080</span><br><span class="line">.....</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>使用下面的命令列出的所有已部署的 Release 以及其对应的 Chart。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm list</span><br><span class="line">NAME     REVISIONUPDATED                 STATUS  CHART        NAMESPACE</span><br><span class="line">mike-test1       Mon Jul 23 10:41:20 2018DEPLOYEDmychart-0.1.0default</span><br></pre></td></tr></table></figure><p>你还可以使用 <code>helm status</code> 查询一个特定的 Release 的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ helm status mike-test</span><br><span class="line">LAST DEPLOYED: Mon Jul 23 10:41:20 2018</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: DEPLOYED</span><br><span class="line"></span><br><span class="line">RESOURCES:</span><br><span class="line">==&gt; v1/Pod(related)</span><br><span class="line">NAME                                READY  STATUS   RESTARTS  AGE</span><br><span class="line">mike-test-mychart-6d56f8c8c9-d685v  1/1    Running  0         1m</span><br><span class="line"></span><br><span class="line">==&gt; v1/Service</span><br><span class="line">NAME               TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)  AGE</span><br><span class="line">mike-test-mychart  ClusterIP  10.254.120.177  &lt;none&gt;       80/TCP   1m</span><br><span class="line"></span><br><span class="line">==&gt; v1beta2/Deployment</span><br><span class="line">NAME               DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE</span><br><span class="line">mike-test-mychart  1        1        1           1          1m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">1. Get the application URL by running these commands:</span><br><span class="line">  export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=mychart,release=mike-test&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line">  echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;</span><br><span class="line">  kubectl port-forward $POD_NAME 8080:80</span><br></pre></td></tr></table></figure><h5 id="升级和回退一个应用"><a href="#升级和回退一个应用" class="headerlink" title="升级和回退一个应用"></a>升级和回退一个应用</h5><p>从上面 <code>helm list</code> 输出的结果中我们可以看到有一个 Revision（更改历史）字段，该字段用于表示某一个 Release 被更新的次数，我们可以用该特性对已部署的 Release 进行回滚。</p><ul><li>修改 Chart.yaml 文件</li></ul><p>将版本号从 0.1.0 修改为 0.2.0, 然后使用 <code>helm package</code> 命令打包并发布到本地仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat mychart/Chart.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">appVersion: &quot;1.0&quot;</span><br><span class="line">description: A Helm chart for Kubernetes</span><br><span class="line">name: mychart</span><br><span class="line">version: 0.2.0</span><br><span class="line"></span><br><span class="line">$ helm package mychart</span><br><span class="line">Successfully packaged chart and saved it to: /home/k8s/mychart-0.2.0.tgz</span><br></pre></td></tr></table></figure><ul><li>查询本地仓库中的 Chart 信息</li></ul><p>我们可以看到在本地仓库中 mychart 有两个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ helm search mychart -l</span><br><span class="line">NAME         CHART VERSIONAPP VERSIONDESCRIPTION</span><br><span class="line">local/mychart0.2.0        1.0        A Helm chart for Kubernetes</span><br><span class="line">local/mychart0.1.0        1.0        A Helm chart for Kubernetes</span><br></pre></td></tr></table></figure><ul><li>升级一个应用</li></ul><p>现在用 <code>helm upgrade</code> 命令将已部署的 mike-test 升级到新版本。你可以通过 <code>--version</code> 参数指定需要升级的版本号，如果没有指定版本号，则缺省使用最新版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ helm upgrade mike-test local/mychart</span><br><span class="line">Release &quot;mike-test&quot; has been upgraded. Happy Helming!</span><br><span class="line">LAST DEPLOYED: Mon Jul 23 10:50:25 2018</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: DEPLOYED</span><br><span class="line"></span><br><span class="line">RESOURCES:</span><br><span class="line">==&gt; v1/Pod(related)</span><br><span class="line">NAME                                READY  STATUS   RESTARTS  AGE</span><br><span class="line">mike-test-mychart-6d56f8c8c9-d685v  1/1    Running  0         9m</span><br><span class="line"></span><br><span class="line">==&gt; v1/Service</span><br><span class="line">NAME               TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)  AGE</span><br><span class="line">mike-test-mychart  ClusterIP  10.254.120.177  &lt;none&gt;       80/TCP   9m</span><br><span class="line"></span><br><span class="line">==&gt; v1beta2/Deployment</span><br><span class="line">NAME               DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE</span><br><span class="line">mike-test-mychart  1        1        1           1          9m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">1. Get the application URL by running these commands:</span><br><span class="line">  export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=mychart,release=mike-test&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line">  echo &quot;Visit http://127.0.0.1:8080 to use your application&quot;</span><br><span class="line">  kubectl port-forward $POD_NAME 8080:80</span><br></pre></td></tr></table></figure><p>完成后，可以看到已部署的 mike-test 被升级到 0.2.0 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm list</span><br><span class="line">NAME     REVISIONUPDATED                 STATUS  CHART        NAMESPACE</span><br><span class="line">mike-test2       Mon Jul 23 10:50:25 2018DEPLOYEDmychart-0.2.0default</span><br></pre></td></tr></table></figure><ul><li>回退一个应用</li></ul><p>如果更新后的程序由于某些原因运行有问题，需要回退到旧版本的应用。首先我们可以使用 <code>helm history</code> 命令查看一个 Release 的所有变更记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ helm history mike-test</span><br><span class="line">REVISIONUPDATED                 STATUS    CHART        DESCRIPTION</span><br><span class="line">1       Mon Jul 23 10:41:20 2018SUPERSEDEDmychart-0.1.0Install complete</span><br><span class="line">2       Mon Jul 23 10:50:25 2018DEPLOYED  mychart-0.2.0Upgrade complete</span><br></pre></td></tr></table></figure><p>其次，我们可以使用下面的命令对指定的应用进行回退。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm rollback mike-test 1</span><br><span class="line">Rollback was a success! Happy Helming!</span><br></pre></td></tr></table></figure><blockquote><p>注：其中的参数 1 是 helm history 查看到 Release 的历史记录中 REVISION 对应的值。</p></blockquote><p>最后，我们使用 <code>helm list</code> 和 <code>helm history</code> 命令都可以看到 mychart 的版本已经回退到 0.1.0 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ helm list</span><br><span class="line">NAME     REVISIONUPDATED                 STATUS  CHART        NAMESPACE</span><br><span class="line">mike-test3       Mon Jul 23 10:53:42 2018DEPLOYEDmychart-0.1.0default</span><br><span class="line"></span><br><span class="line">$ helm history mike-test</span><br><span class="line">REVISIONUPDATED                 STATUS    CHART        DESCRIPTION</span><br><span class="line">1       Mon Jul 23 10:41:20 2018SUPERSEDEDmychart-0.1.0Install complete</span><br><span class="line">2       Mon Jul 23 10:50:25 2018SUPERSEDEDmychart-0.2.0Upgrade complete</span><br><span class="line">3       Mon Jul 23 10:53:42 2018DEPLOYED  mychart-0.1.0Rollback to 1</span><br></pre></td></tr></table></figure><h5 id="删除一个应用"><a href="#删除一个应用" class="headerlink" title="删除一个应用"></a>删除一个应用</h5><p>如果需要删除一个已部署的 Release，可以利用 <code>helm delete</code> 命令来完成删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm delete mike-test</span><br><span class="line">release &quot;mike-test&quot; deleted</span><br></pre></td></tr></table></figure><p>确认应用是否删除，该应用已被标记为 DELETED 状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm ls -a mike-test</span><br><span class="line">NAME     REVISIONUPDATED                 STATUS CHART        NAMESPACE</span><br><span class="line">mike-test3       Mon Jul 23 10:53:42 2018DELETEDmychart-0.1.0default</span><br></pre></td></tr></table></figure><p>也可以使用 <code>--deleted</code> 参数来列出已经删除的 Release</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm ls --deleted</span><br><span class="line">NAME     REVISIONUPDATED                 STATUS CHART        NAMESPACE</span><br><span class="line">mike-test3       Mon Jul 23 10:53:42 2018DELETEDmychart-0.1.0default</span><br></pre></td></tr></table></figure><p>从上面的结果也可以看出，默认情况下已经删除的 Release 只是将状态标识为 DELETED 了 ，但该 Release 的历史信息还是继续被保存的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ helm hist mike-test</span><br><span class="line">REVISIONUPDATED                 STATUS    CHART        DESCRIPTION</span><br><span class="line">1       Mon Jul 23 10:41:20 2018SUPERSEDEDmychart-0.1.0Install complete</span><br><span class="line">2       Mon Jul 23 10:50:25 2018SUPERSEDEDmychart-0.2.0Upgrade complete</span><br><span class="line">3       Mon Jul 23 10:53:42 2018DELETED   mychart-0.1.0Deletion complete</span><br></pre></td></tr></table></figure><p>如果要移除指定 Release 所有相关的 Kubernetes 资源和 Release 的历史记录，可以用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm delete --purge mike-test</span><br><span class="line">release &quot;mike-test&quot; deleted</span><br></pre></td></tr></table></figure><p>再次查看已删除的 Release，已经无法找到相关信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ helm hist mike-test</span><br><span class="line">Error: release: &quot;mike-test&quot; not found</span><br><span class="line"></span><br><span class="line"># helm ls 命令也已均无查询记录。</span><br><span class="line">$ helm ls --deleted</span><br><span class="line">$ helm ls -a mike-test</span><br></pre></td></tr></table></figure><h3 id="Helm-部署应用实例"><a href="#Helm-部署应用实例" class="headerlink" title="Helm 部署应用实例"></a>Helm 部署应用实例</h3><h4 id="部署-Wordpress"><a href="#部署-Wordpress" class="headerlink" title="部署 Wordpress"></a>部署 Wordpress</h4><p>这里以一个典型的三层应用 Wordpress 为例，包括 MySQL、PHP 和 Apache。</p><p>由于测试环境没有可用的 PersistentVolume（持久卷，简称 PV），这里暂时将其关闭。关于 Persistent Volumes 的相关信息我们会在后续的相关文章进行讲解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ helm install --name wordpress-test --set &quot;persistence.enabled=false,mariadb.persistence.enabled=false,serviceType=NodePort&quot;  stable/wordpress</span><br><span class="line"></span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: DEPLOYED</span><br><span class="line"></span><br><span class="line">RESOURCES:</span><br><span class="line">==&gt; v1beta1/Deployment</span><br><span class="line">NAME                      DESIRED  CURRENT  UP-TO-DATE  AVAILABLE  AGE</span><br><span class="line">wordpress-test-mariadb    1        1        1           1          26m</span><br><span class="line">wordpress-test-wordpress  1        1        1           1          26m</span><br><span class="line"></span><br><span class="line">==&gt; v1/Pod(related)</span><br><span class="line">NAME                                       READY  STATUS   RESTARTS  AGE</span><br><span class="line">wordpress-test-mariadb-84b866bf95-n26ff    1/1    Running  1         26m</span><br><span class="line">wordpress-test-wordpress-5ff8c64b6c-sgtvv  1/1    Running  6         26m</span><br><span class="line"></span><br><span class="line">==&gt; v1/Secret</span><br><span class="line">NAME                      TYPE    DATA  AGE</span><br><span class="line">wordpress-test-mariadb    Opaque  2     26m</span><br><span class="line">wordpress-test-wordpress  Opaque  2     26m</span><br><span class="line"></span><br><span class="line">==&gt; v1/ConfigMap</span><br><span class="line">NAME                          DATA  AGE</span><br><span class="line">wordpress-test-mariadb        1     26m</span><br><span class="line">wordpress-test-mariadb-tests  1     26m</span><br><span class="line"></span><br><span class="line">==&gt; v1/Service</span><br><span class="line">NAME                      TYPE       CLUSTER-IP     EXTERNAL-IP  PORT(S)                   AGE</span><br><span class="line">wordpress-test-mariadb    ClusterIP  10.254.99.67   &lt;none&gt;       3306/TCP                  26m</span><br><span class="line">wordpress-test-wordpress  NodePort   10.254.175.16  &lt;none&gt;       80:8563/TCP,443:8839/TCP  26m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">1. Get the WordPress URL:</span><br><span class="line"></span><br><span class="line">  Or running:</span><br><span class="line"></span><br><span class="line">  export NODE_PORT=$(kubectl get --namespace default -o jsonpath=&quot;&#123;.spec.ports[0].nodePort&#125;&quot; services wordpress-test-wordpress)</span><br><span class="line">  export NODE_IP=$(kubectl get nodes --namespace default -o jsonpath=&quot;&#123;.items[0].status.addresses[0].address&#125;&quot;)</span><br><span class="line">  echo http://$NODE_IP:$NODE_PORT/admin</span><br><span class="line"></span><br><span class="line">2. Login with the following credentials to see your blog</span><br><span class="line"></span><br><span class="line">  echo Username: user</span><br><span class="line">  echo Password: $(kubectl get secret --namespace default wordpress-test-wordpress -o jsonpath=&quot;&#123;.data.wordpress-password&#125;&quot; | base64 --decode)</span><br></pre></td></tr></table></figure><h4 id="访问-Wordpress"><a href="#访问-Wordpress" class="headerlink" title="访问 Wordpress"></a>访问 Wordpress</h4><p>部署完成后，我们可以通过上面的提示信息生成相应的访问地址和用户名、密码等相关信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 生成 Wordpress 管理后台地址</span><br><span class="line">$ export NODE_PORT=$(kubectl get --namespace default -o jsonpath=&quot;&#123;.spec.ports[0].nodePort&#125;&quot; services wordpress-test-wordpress)</span><br><span class="line">$ export NODE_IP=$(kubectl get nodes --namespace default -o jsonpath=&quot;&#123;.items[0].status.addresses[0].address&#125;&quot;)</span><br><span class="line">$ echo http://$NODE_IP:$NODE_PORT/admin</span><br><span class="line">http://192.168.100.211:8433/admin</span><br><span class="line"></span><br><span class="line"># 生成 Wordpress 管理帐号和密码</span><br><span class="line">$ echo Username: user</span><br><span class="line">Username: user</span><br><span class="line">$ echo Password: $(kubectl get secret --namespace default wordpress-test-wordpress -o jsonpath=&quot;&#123;.data.wordpress-password&#125;&quot; | base64 --decode)</span><br><span class="line">Password: 9jEXJgnVAY</span><br></pre></td></tr></table></figure><p>给一张访问效果图吧：</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/helm03.png" alt="img"></p><h3 id="Helm-其它使用技巧"><a href="#Helm-其它使用技巧" class="headerlink" title="Helm 其它使用技巧"></a>Helm 其它使用技巧</h3><ul><li>如何设置 helm 命令自动补全？</li></ul><p>为了方便 <code>helm</code> 命令的使用，Helm 提供了自动补全功能，如果使用 ZSH 请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source &lt;(helm completion zsh)</span><br></pre></td></tr></table></figure><p>如果使用 BASH 请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source &lt;(helm completion bash)</span><br></pre></td></tr></table></figure><ul><li>如何使用第三方的 Chart 存储库？</li></ul><p>随着 Helm 越来越普及，除了使用预置官方存储库，三方仓库也越来越多了（前提是网络是可达的）。你可以使用如下命令格式添加三方 Chart 存储库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add 存储库名 存储库URL</span><br><span class="line">$ helm repo update</span><br></pre></td></tr></table></figure><p>一些三方存储库资源:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Prometheus Operator</span><br><span class="line">https://github.com/coreos/prometheus-operator/tree/master/helm</span><br><span class="line"></span><br><span class="line"># Bitnami Library for Kubernetes</span><br><span class="line">https://github.com/bitnami/charts</span><br><span class="line"></span><br><span class="line"># Openstack-Helm</span><br><span class="line">https://github.com/att-comdev/openstack-helm</span><br><span class="line">https://github.com/sapcc/openstack-helm</span><br><span class="line"></span><br><span class="line"># Tick-Charts</span><br><span class="line">https://github.com/jackzampolin/tick-charts</span><br></pre></td></tr></table></figure><ul><li>Helm 如何结合 CI/CD ？</li></ul><p>采用 Helm 可以把零散的 Kubernetes 应用配置文件作为一个 Chart 管理，Chart 源码可以和源代码一起放到 Git 库中管理。通过把 Chart 参数化，可以在测试环境和生产环境采用不同的 Chart 参数配置。</p><p>下图是采用了 Helm 的一个 CI/CD 流程</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/helm04-1572568214885.png" alt="img"></p><ul><li>Helm 如何管理多环境下 (Test、Staging、Production) 的业务配置？</li></ul><p>Chart 是支持参数替换的，可以把业务配置相关的参数设置为模板变量。使用 <code>helm install</code> 命令部署的时候指定一个参数值文件，这样就可以把业务参数从 Chart 中剥离了。例如： <code>helm install --values=values-production.yaml wordpress</code>。</p><ul><li>Helm 如何解决服务依赖？</li></ul><p>在 Chart 里可以通过 requirements.yaml 声明对其它 Chart 的依赖关系。如下面声明表明 Chart 依赖 Apache 和 MySQL 这两个第三方 Chart。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">- name: mariadb</span><br><span class="line">  version: 2.1.1</span><br><span class="line">  repository: https://kubernetes-charts.storage.googleapis.com/</span><br><span class="line">  condition: mariadb.enabled</span><br><span class="line">  tags:</span><br><span class="line">    - wordpress-database</span><br><span class="line">- name: apache</span><br><span class="line">    version: 1.4.0</span><br><span class="line">    repository: https://kubernetes-charts.storage.googleapis.com/</span><br></pre></td></tr></table></figure><ul><li>如何让 Helm 连接到指定 Kubernetes 集群？</li></ul><p>Helm 默认使用和 kubectl 命令相同的配置访问 Kubernetes 集群，其配置默认在 <code>~/.kube/config</code> 中。</p><ul><li>如何在部署时指定命名空间？</li></ul><p><code>helm install</code> 默认情况下是部署在 default 这个命名空间的。如果想部署到指定的命令空间，可以加上 <code>--namespace</code> 参数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm install local/mychart --name mike-test --namespace mynamespace</span><br></pre></td></tr></table></figure><ul><li>如何查看已部署应用的详细信息？</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm get wordpress-test</span><br></pre></td></tr></table></figure><p>默认情况下会显示最新的版本的相关信息，如果想要查看指定发布版本的信息可加上 <code>--revision</code> 参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm get  --revision 1  wordpress-test</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://t.cn/RgEE0dm" target="_blank" rel="noopener">http://t.cn/RgEE0dm</a><br><a href="http://t.cn/RgE3MyP" target="_blank" rel="noopener">http://t.cn/RgE3MyP</a><br><a href="http://t.cn/RgpiUAz" target="_blank" rel="noopener">http://t.cn/RgpiUAz</a></p><p><a href="https://github.com/helm/charts" target="_blank" rel="noopener">helm/charts</a></p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="正确删除一个Pod"><a href="#正确删除一个Pod" class="headerlink" title="正确删除一个Pod"></a>正确删除一个Pod</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;1、先删除pod</span><br><span class="line">&gt;2、再删除对应的deployment</span><br><span class="line">&gt;否则只是删除pod是不管用的，还会看到pod，因为deployment.yaml文件中定义了副本数量</span><br></pre></td></tr></table></figure></blockquote><h3 id="K8S命令补全"><a href="#K8S命令补全" class="headerlink" title="K8S命令补全"></a>K8S命令补全</h3><blockquote><ol><li>yum -y install  bash-completion</li><li>chmod +x /usr/share/bash-completion/bash_completion</li><li>/usr/share/bash-completion/bash_completion</li><li>source /usr/share/bash-completion/bash_completion</li><li>source &lt;(kubectl completion bash)</li></ol></blockquote><h3 id="Kubernetes-问题定位技巧：容器内抓包"><a href="#Kubernetes-问题定位技巧：容器内抓包" class="headerlink" title="Kubernetes 问题定位技巧：容器内抓包"></a>Kubernetes 问题定位技巧：容器内抓包</h3><p>在使用 kubernetes 跑应用的时候，可能会遇到一些网络问题，比较常见的是服务端无响应(超时)或回包内容不正常，如果没找出各种配置上有问题，这时我们需要确认数据包到底有没有最终被路由到容器里，或者报文到达容器的内容和出容器的内容符不符合预期，通过分析报文可以进一步缩小问题范围。那么如何在容器内抓包呢？本文提供实用的脚本一键进入容器网络命名空间(netns)，使用宿主机上的tcpdump进行抓包。</p><h4 id="使用脚本一键进入-pod-netns-抓包"><a href="#使用脚本一键进入-pod-netns-抓包" class="headerlink" title="使用脚本一键进入 pod netns 抓包"></a>使用脚本一键进入 pod netns 抓包</h4><ul><li>发现某个服务不通，最好将其副本数调为1，并找到这个副本 pod 所在节点和 pod 名称</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure><ul><li>登录 pod 所在节点，将如下脚本粘贴到 shell (注册函数到当前登录的 shell，我们后面用)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">e</span></span>() &#123;</span><br><span class="line">    <span class="built_in">set</span> -eu</span><br><span class="line">    ns=<span class="variable">$&#123;2-"default"&#125;</span></span><br><span class="line">    pod=`kubectl -n <span class="variable">$ns</span> describe pod <span class="variable">$1</span> | grep -A10 <span class="string">"^Containers:"</span> | grep -Eo <span class="string">'docker://.*$'</span> | head -n 1 | sed <span class="string">'s/docker:\/\/\(.*\)$/\1/'</span>`</span><br><span class="line">    pid=`docker inspect -f &#123;&#123;.State.Pid&#125;&#125; <span class="variable">$pod</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"entering pod netns for <span class="variable">$ns</span>/<span class="variable">$1</span>"</span></span><br><span class="line">    cmd=<span class="string">"nsenter -n --target <span class="variable">$pid</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$cmd</span></span><br><span class="line">    <span class="variable">$cmd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一键进入 pod 所在的 netns，格式：<code>e POD_NAME NAMESPACE</code>，示例：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e istio-galley-58c7c7c646-m6568 istio-system</span><br><span class="line">e proxy-5546768954-9rxg6 <span class="comment"># 省略 NAMESPACE 默认为 default</span></span><br></pre></td></tr></table></figure><ul><li>这时已经进入 pod 的 netns，可以执行宿主机上的 <code>ip a</code> 或 <code>ifconfig</code> 来查看容器的网卡，执行 <code>netstat -tunlp</code> 查看当前容器监听了哪些端口，再通过 <code>tcpdump</code> 抓包：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -w test.pcap port 80</span><br></pre></td></tr></table></figure><ul><li><code>ctrl-c</code> 停止抓包，再用 <code>scp</code> 或 <code>sz</code> 将抓下来的包下载到本地使用 <code>wireshark</code> 分析，提供一些常用的 <code>wireshark</code> 过滤语法：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 telnet 连上并发送一些测试文本，比如 "lbtest"，</span></span><br><span class="line"><span class="comment"># 用下面语句可以看发送的测试报文有没有到容器</span></span><br><span class="line">tcp contains <span class="string">"lbtest"</span></span><br><span class="line"><span class="comment"># 如果容器提供的是http服务，可以使用 curl 发送一些测试路径的请求，</span></span><br><span class="line"><span class="comment"># 通过下面语句过滤 uri 看报文有没有都容器</span></span><br><span class="line">http.request.uri==<span class="string">"/mytest"</span></span><br></pre></td></tr></table></figure><h4 id="脚本原理"><a href="#脚本原理" class="headerlink" title="脚本原理"></a>脚本原理</h4><p>我们解释下步骤二中用到的脚本的原理 - 查看指定 pod 运行的容器 ID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod&gt; -n mservice</span><br></pre></td></tr></table></figure><ul><li>获得容器进程的 pid</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;.State.Pid&#125;&#125; &lt;container&gt;</span><br></pre></td></tr></table></figure><ul><li>进入该容器的 network namespace</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsenter -n --target &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>依赖宿主机的命名：<code>kubectl</code>, <code>docker</code>, <code>nsenter</code>, <code>grep</code>, <code>head</code>, <code>sed</code></p><h3 id="Kubernetes的三种外部访问方式：NodePort、LoadBalancer和Ingress"><a href="#Kubernetes的三种外部访问方式：NodePort、LoadBalancer和Ingress" class="headerlink" title="Kubernetes的三种外部访问方式：NodePort、LoadBalancer和Ingress"></a>Kubernetes的三种外部访问方式：NodePort、LoadBalancer和Ingress</h3><p><strong>注意</strong>：这里说的每一点都基于Google Kubernetes Engine。如果你用 minikube 或其它工具，以预置型模式（om prem）运行在其它云上，对应的操作可能有点区别。我不会太深入技术细节，如果你有兴趣了解更多，官方文档[1]是一个非常棒的资源。</p><h4 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h4><p>ClusterIP 服务是 Kubernetes 的默认服务。它给你一个集群内的服务，集群内的其它应用都可以访问该服务。集群外部无法访问它。</p><p>ClusterIP 服务的 YAML 文件类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1kind: Servicemetadata:   name: my-internal-serviceselector:     app: my-appspec: type: ClusterIP ports:   - name: http   port: 80   targetPort: 80   protocol: TCP</span><br></pre></td></tr></table></figure><p>如果 从Internet 没法访问 ClusterIP 服务，那么我们为什么要讨论它呢？那是因为我们可以通过 Kubernetes 的 proxy 模式来访问该服务！</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/1.jpg" alt="img">K8S部署简介ernetes proxy 模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl proxy --port=8080</span><br></pre></td></tr></table></figure><p>这样你可以通过Kubernetes API，使用如下模式来访问这个服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/v1/proxy/namespaces//services/:/</span><br></pre></td></tr></table></figure><p>要访问我们上面定义的服务，你可以使用如下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/v1/proxy/namespaces/default/services/my-internal-service:http/</span><br></pre></td></tr></table></figure><p><strong>何时使用这种方式？</strong></p><p>有一些场景下，你得使用 Kubernetes 的 proxy 模式来访问你的服务：</p><ul><li>由于某些原因，你需要调试你的服务，或者需要直接通过笔记本电脑去访问它们。</li><li>容许内部通信，展示内部仪表盘等。</li></ul><p>这种方式要求我们运行 kubectl 作为一个未认证的用户，因此我们不能用这种方式把服务暴露到 internet 或者在生产环境使用。</p><h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><p>NodePort 服务是引导外部流量到你的服务的最原始方式。NodePort，正如这个名字所示，在所有节点（虚拟机）上开放一个特定端口，任何发送到该端口的流量都被转发到对应服务。</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/2.jpg" alt="img">K8S部署简介rt 服务的 YAML 文件类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1kind: Servicemetadata:   name: my-nodeport-serviceselector:     app: my-appspec: type: NodePort ports:   - name: http   port: 80   targetPort: 80   nodePort: 30036   protocol: TCP</span><br></pre></td></tr></table></figure><p>NodePort 服务主要有两点区别于普通的“ClusterIP”服务。第一，它的类型是“NodePort”。有一个额外的端口，称为 nodePort，它指定节点上开放的端口值 。如果你不指定这个端口，系统将选择一个随机端口。大多数时候我们应该让 Kubernetes 来选择端口，因为如评论中 thockin 所说，用户自己来选择可用端口代价太大。</p><p><strong>何时使用这种方式？</strong></p><p>这种方法有许多缺点：</p><ol><li>每个端口只能是一种服务</li><li>端口范围只能是 30000-32767</li><li>如果节点/VM 的 IP 地址发生变化，你需要能处理这种情况</li></ol><p>基于以上原因，我不建议在生产环境上用这种方式暴露服务。如果你运行的服务不要求一直可用，或者对成本比较敏感，你可以使用这种方法。这样的应用的最佳例子是 demo 应用，或者某些临时应用。</p><h4 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h4><p>LoadBalancer 服务是暴露服务到 internet 的标准方式。在 GKE 上，这种方式会启动一个 Network Load Balancer[2]，它将给你一个单独的 IP 地址，转发所有流量到你的服务。</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/3.jpg" alt="img">K8S部署简介这种方式？**</p><p>如果你想要直接暴露服务，这就是默认方式。所有通往你指定的端口的流量都会被转发到对应的服务。它没有过滤条件，没有路由等。这意味着你几乎可以发送任何种类的流量到该服务，像 HTTP，TCP，UDP，Websocket，gRPC 或其它任意种类。</p><p>这个方式的最大缺点是每一个用 LoadBalancer 暴露的服务都会有它自己的 IP 地址，每个用到的 LoadBalancer 都需要付费，这将是非常昂贵的。</p><h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><p>有别于以上所有例子，Ingress 事实上不是一种服务类型。相反，它处于多个服务的前端，扮演着“智能路由”或者集群入口的角色。</p><p>你可以用 Ingress 来做许多不同的事情，各种不同类型的 Ingress 控制器也有不同的能力。</p><p>GKE 上的默认 ingress 控制器是启动一个 HTTP(S) Load Balancer[3]。它允许你基于路径或者子域名来路由流量到后端服务。例如，你可以将任何发往域名 foo.yourdomain.com 的流量转到 foo 服务，将路径 yourdomain.com/bar/path 的流量转到 bar 服务。</p><p><img src="/2019/10/31/K8S%E9%83%A8%E7%BD%B2%E7%AE%80%E4%BB%8B/4.jpg" alt="img">K8S部署简介 L7 HTTP Load Balancer[4]生成的 Ingress 对象的 YAML 文件类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line"> name: my-ingress</span><br><span class="line">spec:</span><br><span class="line"> backend:</span><br><span class="line">   serviceName: other</span><br><span class="line">   servicePort: 8080</span><br><span class="line"> rules:</span><br><span class="line"></span><br><span class="line"> - host: foo.mydomain.com</span><br><span class="line">      http:</span><br><span class="line">           paths:</span><br><span class="line">           - backend:</span><br><span class="line">               serviceName: foo</span><br><span class="line">               servicePort: 8080</span><br><span class="line"> - host: mydomain.com</span><br><span class="line">      http:</span><br><span class="line">           paths:</span><br><span class="line">         - path: /bar/*</span><br><span class="line">              ackend:</span><br><span class="line">                       serviceName: bar</span><br><span class="line">                       servicePort: 8080</span><br></pre></td></tr></table></figure><p><strong>何时使用这种方式？</strong></p><p>Ingress 可能是暴露服务的最强大方式，但同时也是最复杂的。Ingress 控制器有各种类型，包括 Google Cloud Load Balancer， Nginx，Contour，Istio，等等。它还有各种插件，比如 cert-manager[5]，它可以为你的服务自动提供 SSL 证书。</p><p>如果你想要使用同一个 IP 暴露多个服务，这些服务都是使用相同的七层协议（典型如 HTTP），那么Ingress 就是最有用的。如果你使用本地的 GCP 集成，你只需要为一个负载均衡器付费，且由于 Ingress是“智能”的，你还可以获取各种开箱即用的特性（比如 SSL、认证、路由等等）。</p><p>相关链接：</p><ol><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/services-networking/service/</a></li><li><a href="https://cloud.google.com/compute/docs/load-balancing/network/" target="_blank" rel="noopener">https://cloud.google.com/compute/docs/load-balancing/network/</a></li><li><a href="https://cloud.google.com/compute/docs/load-balancing/http/" target="_blank" rel="noopener">https://cloud.google.com/compute/docs/load-balancing/http/</a></li><li><a href="https://cloud.google.com/compute/docs/load-balancing/http/" target="_blank" rel="noopener">https://cloud.google.com/compute/docs/load-balancing/http/</a></li><li><a href="https://github.com/jetstack/cert-manager" target="_blank" rel="noopener">https://github.com/jetstack/cert-manager</a></li></ol><p>原文链接：<a href="https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0" target="_blank" rel="noopener">https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/" target="_blank" rel="noopener">Viewing Pods and Nodes</a></li><li><a href="https://www.cnblogs.com/cocowool/p/k8s_base_concept.html" target="_blank" rel="noopener">Kubernetes基础</a></li><li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/" target="_blank" rel="noopener">Using a Service to Expose Your App</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;当你在Module2创建了一个Deployment之后，Kuebernetes创建会创建一个&lt;strong&gt;Pod&lt;/strong&gt;去托管你的应用实例。一个Pod是一种Kubernetes的抽象，这种抽象代表一组一个或者多个应用的容器（例如Docker或者rkt）,和一些这些容器间的共享资源。&lt;br&gt; 这些资源包括：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;共享存储，例如Volumes&lt;/li&gt;
&lt;li&gt;网络，例如一个唯一的集群IP地址&lt;/li&gt;
&lt;li&gt;关于运行中的每个容器的详细信息，例如容器image版本，容器运行端口&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="持续集成" scheme="http://geoffen.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="K8S" scheme="http://geoffen.github.io/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>终于有人把Docker讲清楚了</title>
    <link href="http://geoffen.github.io/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/"/>
    <id>http://geoffen.github.io/2019/10/31/终于有人把Docker讲清楚了/</id>
    <published>2019-10-31T09:18:26.000Z</published>
    <updated>2019-11-07T10:24:47.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终于有人把-Docker-讲清楚了"><a href="#终于有人把-Docker-讲清楚了" class="headerlink" title="终于有人把 Docker 讲清楚了"></a>终于有人把 Docker 讲清楚了</h2><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640.webp" alt="img"></p><blockquote><p>作者 | 乐章</p><p>来源 | cnblogs.com/zhangxingeng/p/11236968.html</p><p>编辑：Java技术栈（id：javastack）</p></blockquote><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="1、了解Docker的前生LXC"><a href="#1、了解Docker的前生LXC" class="headerlink" title="1、了解Docker的前生LXC"></a><strong>1、了解Docker的前生LXC</strong></h3><p>LXC为Linux Container的简写。可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。相当于C++中的NameSpace。容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。</p><a id="more"></a><p>与传统虚拟化技术相比，它的优势在于：</p><p>（1）与宿主机使用同一个内核，性能损耗小；</p><p>（2）不需要指令级模拟；</p><p>（3）不需要即时(Just-in-time)编译；</p><p>（4）容器可以在CPU核心的本地运行指令，不需要任何专门的解释机制；</p><p>（5）避免了准虚拟化和系统调用替换中的复杂性；</p><p>（6）轻量级隔离，在隔离的同时还提供共享机制，以实现容器与宿主机的资源共享。</p><p>总结：Linux Container是一种轻量级的虚拟化的手段。</p><p>Linux Container提供了在单一可控主机节点上支持多个相互隔离的server container同时执行的机制。Linux Container有点像chroot，提供了一个拥有自己进程和网络空间的虚拟环境，但又有别于虚拟机，因为lxc是一种操作系统层次上的资源的虚拟化。</p><h3 id="2、LXC与docker什么关系？"><a href="#2、LXC与docker什么关系？" class="headerlink" title="2、LXC与docker什么关系？"></a><strong>2、LXC与docker什么关系？</strong></h3><p>docker并不是LXC替代品，docker底层使用了LXC来实现，LXC将linux进程沙盒化，使得进程之间相互隔离，并且能够课哦内阁制各进程的资源分配。</p><p>在LXC的基础之上，docker提供了一系列更强大的功能。</p><h3 id="3、什么是docker"><a href="#3、什么是docker" class="headerlink" title="3、什么是docker"></a><strong>3、什么是docker</strong></h3><p>docker是一个开源的应用容器引擎，基于go语言开发并遵循了apache2.0协议开源。</p><p>docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的linux服务器，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类iphone的app），并且容器开销极其低。</p><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="4、docker官方文档"><a href="#4、docker官方文档" class="headerlink" title="4、docker官方文档"></a><strong>4、docker官方文档</strong></h3><p><a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></p><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="5、为什么docker越来越受欢迎"><a href="#5、为什么docker越来越受欢迎" class="headerlink" title="5、为什么docker越来越受欢迎"></a><strong>5、为什么docker越来越受欢迎</strong></h3><p>官方话语：</p><ul><li>容器化越来越受欢迎，因为容器是：</li></ul><ul><li><ul><li>灵活：即使是最复杂的应用也可以集装箱化。</li><li>轻量级：容器利用并共享主机内核。</li><li>可互换：您可以即时部署更新和升级。</li><li>便携式：您可以在本地构建，部署到云，并在任何地方运行。</li><li>可扩展：您可以增加并自动分发容器副本。</li><li>可堆叠：您可以垂直和即时堆叠服务。</li></ul></li></ul><h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><ul><li><h3 id="镜像和容器（contalners）"><a href="#镜像和容器（contalners）" class="headerlink" title="镜像和容器（contalners）"></a>镜像和容器（contalners）</h3></li></ul><p>通过镜像启动一个容器，一个镜像是一个可执行的包，其中包括运行应用程序所需要的所有内容包含代码，运行时间，库、环境变量、和配置文件。</p><p>容器是镜像的运行实例，当被运行时有镜像状态和用户进程，可以使用docker ps 查看。</p><ul><li><h3 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h3></li></ul><p>容器时在linux上本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量。</p><p>虚拟机运行的是一个完成的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。</p><p> <img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640.webp" alt="img"></p><h3 id="-4"><a href="#-4" class="headerlink" title></a></h3><h3 id="6、docker版本"><a href="#6、docker版本" class="headerlink" title="6、docker版本"></a><strong>6、docker版本</strong></h3><p>Docker Community Edition（CE）社区版</p><p>Enterprise Edition(EE) 商业版</p><h3 id="-5"><a href="#-5" class="headerlink" title></a></h3><h3 id="7、docker和openstack的几项对比"><a href="#7、docker和openstack的几项对比" class="headerlink" title="7、docker和openstack的几项对比"></a><strong>7、docker和openstack的几项对比</strong></h3><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640.webp" alt="img"></p><h3 id="8、容器在内核中支持2种重要技术"><a href="#8、容器在内核中支持2种重要技术" class="headerlink" title="8、容器在内核中支持2种重要技术"></a><strong>8、容器在内核中支持2种重要技术</strong></h3><p>docker本质就是宿主机的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写时复制技术（copy-on-write）实现了高效的文件操作（类似虚拟机的磁盘比如分配500g并不是实际占用物理磁盘500g）</p><p>1）namespaces 名称空间</p><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572599922202.webp" alt="img"></p><p> 2）control Group 控制组</p><p>cgroup的特点是：　　　　　　</p><ul><li>cgroup的api以一个伪文件系统的实现方式，用户的程序可以通过文件系统实现cgroup的组件管理</li><li>cgroup的组件管理操作单元可以细粒度到线程级别，另外用户可以创建和销毁cgroup，从而实现资源载分配和再利用</li><li>所有资源管理的功能都以子系统的方式实现，接口统一子任务创建之初与其父任务处于同一个cgroup的控制组</li></ul><p>四大功能：</p><ul><li>资源限制：可以对任务使用的资源总额进行限制</li><li>优先级分配：通过分配的cpu时间片数量以及磁盘IO带宽大小，实际上相当于控制了任务运行优先级</li><li>资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等</li><li>任务控制：cgroup可以对任务执行挂起、恢复等操作</li></ul><h3 id="-6"><a href="#-6" class="headerlink" title></a></h3><h3 id="9、了解docker三个重要概念"><a href="#9、了解docker三个重要概念" class="headerlink" title="9、了解docker三个重要概念"></a><strong>9、了解docker三个重要概念</strong></h3><p>1）image镜像</p><p>docker镜像就是一个只读模板，比如，一个镜像可以包含一个完整的centos，里面仅安装apache或用户的其他应用，镜像可以用来创建docker容器，另外docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下周一个已经做好的镜像来直接使用</p><p>2）container容器</p><p>docker利用容器来运行应用，容器是从镜像创建的运行实例，它可以被启动，开始、停止、删除、每个容器都是互相隔离的，保证安全的平台，可以吧容器看做是要给简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行再其中的应用程序</p><p>3）repostory仓库</p><p>仓库是集中存储镜像文件的沧桑，registry是仓库主从服务器，实际上参考注册服务器上存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）</p><p>仓库分为两种，公有参考，和私有仓库，最大的公开仓库是docker Hub，存放了数量庞大的镜像供用户下周，国内的docker pool，这里仓库的概念与Git类似，registry可以理解为github这样的托管服务。</p><h3 id="-7"><a href="#-7" class="headerlink" title></a></h3><h3 id="10、docker的主要用途"><a href="#10、docker的主要用途" class="headerlink" title="10、docker的主要用途"></a><strong>10、docker的主要用途</strong></h3><p>官方就是Bulid 、ship、run any app/any where，编译、装载、运行、任何app/在任意地放都能运行。</p><p>就是实现了应用的封装、部署、运行的生命周期管理只要在glibc的环境下，都可以运行。</p><p>运维生成环境中：docker化。</p><ul><li>发布服务不用担心服务器的运行环境，所有的服务器都是自动分配docker，自动部署，自动安装，自动运行</li><li>再不用担心其他服务引擎的磁盘问题，cpu问题，系统问题了</li><li>资源利用更出色</li><li>自动迁移，可以制作镜像，迁移使用自定义的镜像即可迁移，不会出现什么问题</li><li>管理更加方便了</li></ul><h3 id="-8"><a href="#-8" class="headerlink" title></a></h3><h3 id="11、docker改变了什么"><a href="#11、docker改变了什么" class="headerlink" title="11、docker改变了什么"></a><strong>11、docker改变了什么</strong></h3><ul><li>面向产品：产品交付</li><li>面向开发：简化环境配置</li><li>面向测试：多版本测试</li><li>面向运维：环境一致性</li><li>面向架构：自动化扩容（微服务）</li></ul><h2 id="二、docker架构"><a href="#二、docker架构" class="headerlink" title="二、docker架构"></a><strong>二、docker架构</strong></h2><h3 id="-9"><a href="#-9" class="headerlink" title></a></h3><h3 id="1、总体架构"><a href="#1、总体架构" class="headerlink" title="1、总体架构"></a><strong>1、总体架构</strong></h3><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572599922216.webp" alt="img"></p><ul><li>distribution 负责与docker registry交互，上传洗澡镜像以及v2 registry 有关的源数据</li><li>registry负责docker registry有关的身份认证、镜像查找、镜像验证以及管理registry mirror等交互操作</li><li>image 负责与镜像源数据有关的存储、查找，镜像层的索引、查找以及镜像tar包有关的导入、导出操作</li><li>reference负责存储本地所有镜像的repository和tag名，并维护与镜像id之间的映射关系</li><li>layer模块负责与镜像层和容器层源数据有关的增删改查，并负责将镜像层的增删改查映射到实际存储镜像层文件的graphdriver模块</li><li>graghdriver是所有与容器镜像相关操作的执行者</li></ul><h3 id="-10"><a href="#-10" class="headerlink" title></a></h3><h3 id="2、docker架构2"><a href="#2、docker架构2" class="headerlink" title="2、docker架构2"></a><strong>2、docker架构2</strong></h3><p>如果觉得上面架构图比较乱可以看这个架构：</p><h3 id="-11"><a href="#-11" class="headerlink" title></a><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572599922229.webp" alt="img"></h3><p>从上图不难看出，用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</p><p>而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</p><p>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。</p><p>而libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。</p><h3 id="3、docker架构3"><a href="#3、docker架构3" class="headerlink" title="3、docker架构3"></a><strong>3、docker架构3</strong></h3><p>再来看看另外一个架构，这个个架构就简单清晰指明了server/client交互，容器和镜像、数据之间的一些联系。</p><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572599922232.webp" alt="img"></p><p>这个架构图更加清晰了架构</p><p>docker daemon就是docker的守护进程即server端，可以是远程的，也可以是本地的，这个不是C/S架构吗，客户端Docker client 是通过rest api进行通信。</p><p>docker cli 用来管理容器和镜像，客户端提供一个只读镜像，然后通过镜像可以创建多个容器，这些容器可以只是一个RFS（Root file system根文件系统），也可以ishi一个包含了用户应用的RFS，容器再docker client中只是要给进程，两个进程之间互不可见。</p><p>用户不能与server直接交互，但可以通过与容器这个桥梁来交互，由于是操作系统级别的虚拟技术，中间的损耗几乎可以不计。</p><h2 id="三、docker架构2各个模块的功能（带完善）"><a href="#三、docker架构2各个模块的功能（带完善）" class="headerlink" title="三、docker架构2各个模块的功能（带完善）"></a><strong>三、docker架构2各个模块的功能（带完善）</strong></h2><p>主要的模块有：Docker Client、Docker Daemon、Docker Registry、Graph、Driver、libcontainer以及Docker container。　　　</p><h3 id="-12"><a href="#-12" class="headerlink" title></a></h3><h3 id="1、docker-client"><a href="#1、docker-client" class="headerlink" title="1、docker client"></a><strong>1、docker client</strong></h3><p>docker client 是docker架构中用户用来和docker daemon建立通信的客户端，用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求。</p><p>docker client可以通过一下三宗方式和docker daemon建立通信：tcp://host:port;unix:path_to_socket;fd://socketfd。，docker client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。</p><p>docker client发送容器管理请求后，由docker daemon接受并处理请求，当docker client 接收到返回的请求相应并简单处理后，docker client 一次完整的生命周期就结束了，当需要继续发送容器管理请求时，用户必须再次通过docker可以执行文件创建docker client。</p><h3 id="-13"><a href="#-13" class="headerlink" title></a></h3><h3 id="2、docker-daemon"><a href="#2、docker-daemon" class="headerlink" title="2、docker daemon"></a><strong>2、docker daemon</strong></h3><p>docker daemon 是docker架构中一个常驻在后台的系统进程，功能是：接收处理docker client发送的请求。该守护进程在后台启动一个server，server负载接受docker client发送的请求；接受请求后，server通过路由与分发调度，找到相应的handler来执行请求。</p><p>docker daemon启动所使用的可执行文件也为docker，与docker client启动所使用的可执行文件docker相同，在docker命令执行时，通过传入的参数来判别docker daemon与docker client。</p><p>docker daemon的架构可以分为：docker server、engine、job。daemon</p><h3 id="-14"><a href="#-14" class="headerlink" title></a></h3><h3 id="3、docker-server"><a href="#3、docker-server" class="headerlink" title="3、docker server"></a><strong>3、docker server</strong></h3><p>docker server在docker架构中时专门服务于docker client的server，该server的功能时：接受并调度分发docker client发送的请求，架构图如下：</p><p>　　　　<img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572599922233.webp" alt="img"></p><p>在Docker的启动过程中，通过包gorilla/mux（golang的类库解析），创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。</p><p>若Docker Client通过HTTP的形式访问Docker Daemon，创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。</p><p>在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。</p><p>需要注意的是：Docker Server的运行在Docker的启动过程中，是靠一个名为”serveapi”的job的运行来完成的。原则上，Docker Server的运行是众多job中的一个，但是为了强调Docker Server的重要性以及为后续job服务的重要特性，将该”serveapi”的job单独抽离出来分析，理解为Docker Server。</p><h3 id="-15"><a href="#-15" class="headerlink" title></a></h3><h3 id="4、engine"><a href="#4、engine" class="headerlink" title="4、engine"></a><strong>4、engine</strong></h3><p>Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。</p><p>在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为”create”的job在运行时，执行的是daemon.ContainerCreate的handler。</p><h3 id="-16"><a href="#-16" class="headerlink" title></a></h3><h3 id="5、job"><a href="#5、job" class="headerlink" title="5、job"></a><strong>5、job</strong></h3><p>一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job，从Internet上下载一个文档，这是一个job；包括之前在Docker Server部分说过的，创建Server服务于HTTP的API，这也是一个job，等等。</p><p>Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</p><h3 id="-17"><a href="#-17" class="headerlink" title></a></h3><h3 id="6、docker-registry"><a href="#6、docker-registry" class="headerlink" title="6、docker registry"></a><strong>6、docker registry</strong></h3><p>Docker Registry是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。</p><p>在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。</p><p>其中，在Docker架构中，Docker可以使用公有的Docker Registry，即大家熟知的Docker Hub，如此一来，Docker获取容器镜像文件时，必须通过互联网访问Docker Hub；同时Docker也允许用户构建本地私有的Docker Registry，这样可以保证容器镜像的获取在内网完成。</p><h3 id="-18"><a href="#-18" class="headerlink" title></a></h3><h3 id="7、Graph"><a href="#7、Graph" class="headerlink" title="7、Graph"></a><strong>7、Graph</strong></h3><p>Graph在Docker架构中扮演已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。</p><p>Graph的架构如下：</p><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572599922235.webp" alt="img"></p><p>其中，GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。</p><p>同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</p><p><strong>8、driver</strong></p><p>Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。</p><p>在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。</p><p>graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。</p><p>在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。</p><p>graphdriver的架构如下：</p><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572600680712.webp" alt="img"></p><p>networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。networkdriver的架构如下：</p><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572600696159.webp" alt="img"></p><p>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。</p><p>具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。这可以认为是Docker在1.2版本上一个很大的改变，或者说Docker实现跨平台的一个先兆。execdriver架构如下：</p><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572600706623.webp" alt="img"></p><h3 id="9、libcontainer"><a href="#9、libcontainer" class="headerlink" title="9、libcontainer"></a><strong>9、libcontainer</strong></h3><p>libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。</p><p>正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。libcontainer架构如下：</p><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572600714042.webp" alt="img"></p><p>另外，libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。又由于libcontainer使用Go这种跨平台的语言开发实现，且本身又可以被上层多种不同的编程语言访问，因此很难说，未来的Docker就一定会紧紧地和Linux捆绑在一起。而于此同时，Microsoft在其著名云计算平台Azure中，也添加了对Docker的支持，可见Docker的开放程度与业界的火热度。</p><p>暂不谈Docker，由于libcontainer的功能以及其本身与系统的松耦合特性，很有可能会在其他以容器为原型的平台出现，同时也很有可能催生出云计算领域全新的项目。</p><h3 id="10、docker-container"><a href="#10、docker-container" class="headerlink" title="10、docker container"></a><strong>10、docker container</strong></h3><p>Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。</p><p>Docker按照用户的需求与指令，订制相应的Docker容器：</p><ul><li>用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；</li><li>用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；</li><li>用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；</li><li>用户通过指定运行的命令，使得Docker容器执行指定的工作。</li></ul><p><img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572600728419.webp" alt="img"></p><h2 id="四、docker简单使用"><a href="#四、docker简单使用" class="headerlink" title="四、docker简单使用"></a><strong>四、docker简单使用</strong></h2><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a><strong>1、安装</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker -y systemctl enable dockersystemctl start docker</span><br></pre></td></tr></table></figure><p>注意：启动前应当设置源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>这里设置阿里的，注册阿里云账户号每个用户都有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 ~]# vim /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=http://docs.docker.com</span><br><span class="line">After=network.target</span><br><span class="line">Wants=docker-storage-setup.service</span><br><span class="line">Requires=docker-cleanup.timer</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">NotifyAccess=main</span><br><span class="line">EnvironmentFile=-/run/containers/registries.conf</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/docker</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/docker-storage</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/docker-network</span><br><span class="line">Environment=GOTRACEBACK=crash</span><br><span class="line">Environment=DOCKER_HTTP_HOST_COMPAT=1</span><br><span class="line">Environment=PATH=/usr/libexec/docker:/usr/bin:/usr/sbin</span><br><span class="line">ExecStart=/usr/bin/dockerd-current --registry-mirror=https://rfcod7oz.mirror.aliyuncs.com  #这个值可以登陆阿里云账号请参考下图</span><br><span class="line">          --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current </span><br><span class="line">          --default-runtime=docker-runc </span><br><span class="line">          --exec-opt native.cgroupdriver=systemd </span><br><span class="line">          --userland-proxy-path=/usr/libexec/docker/docker-proxy-current </span><br><span class="line">          --init-path=/usr/libexec/docker/docker-init-current </span><br><span class="line">          --seccomp-profile=/etc/docker/seccomp.json </span><br><span class="line">          $OPTIONS </span><br><span class="line">          $DOCKER_STORAGE_OPTIONS </span><br><span class="line">          $DOCKER_NETWORK_OPTIONS </span><br><span class="line">          $ADD_REGISTRY </span><br><span class="line">          $BLOCK_REGISTRY </span><br><span class="line">          $INSECURE_REGISTRY </span><br><span class="line">          $REGISTRIES</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line">LimitNPROC=1048576</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">Restart=on-abnormal</span><br><span class="line">KillMode=process</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>　　<img src="/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640-1572601422584.webp" alt="img">　</p><h3 id="2、docker版本查询"><a href="#2、docker版本查询" class="headerlink" title="2、docker版本查询"></a><strong>2、docker版本查询</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 ~]# docker version</span><br></pre></td></tr></table></figure><h3 id="3、搜索下载镜像"><a href="#3、搜索下载镜像" class="headerlink" title="3、搜索下载镜像"></a><strong>3、搜索下载镜像</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull alpine　　　　　　　　　　#下载镜像docker search nginx　　　　　　　　　 #查看镜像docker pull nginx</span><br></pre></td></tr></table></figure><h3 id="4、查看已经下载的镜像"><a href="#4、查看已经下载的镜像" class="headerlink" title="4、查看已经下载的镜像"></a><strong>4、查看已经下载的镜像</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 ~]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEzxg/my_nginx        v1                  b164f4c07c64        8 days ago          126 MBzxg/my_nginx        latest              f07837869dfc        8 days ago          126 MBdocker.io/nginx     latest              e445ab08b2be        2 weeks ago         126 MBdocker.io/alpine    latest              b7b28af77ffe        3 weeks ago         5.58 MBdocker.io/centos    latest              9f38484d220f        4 months ago        202 MB[root@web1 ~]#</span><br></pre></td></tr></table></figure><h3 id="5、导出镜像"><a href="#5、导出镜像" class="headerlink" title="5、导出镜像"></a><strong>5、导出镜像</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  save nginx &gt;/tmp/nginx.tar.gz</span><br></pre></td></tr></table></figure><h3 id="6、删除镜像"><a href="#6、删除镜像" class="headerlink" title="6、删除镜像"></a><strong>6、删除镜像</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f nginx</span><br></pre></td></tr></table></figure><h3 id="7、导入镜像"><a href="#7、导入镜像" class="headerlink" title="7、导入镜像"></a><strong>7、导入镜像</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt;/tmp/nginx.tar.gz</span><br></pre></td></tr></table></figure><h3 id="-19"><a href="#-19" class="headerlink" title></a></h3><h3 id="8、默认配置文件"><a href="#8、默认配置文件" class="headerlink" title="8、默认配置文件"></a><strong>8、默认配置文件</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>如果更改存储目录就添加　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--graph=/opt/docker</span><br></pre></td></tr></table></figure><p>如果更改DNS——默认采用宿主机的dns</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--dns=xxxx的方式指定</span><br></pre></td></tr></table></figure><h3 id="9、运行hello-world"><a href="#9、运行hello-world" class="headerlink" title="9、运行hello world"></a><strong>9、运行hello world</strong></h3><p>这里用centos镜像echo一个hello word</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 overlay2]#  docker images</span><br></pre></td></tr></table></figure><h3 id="10、运行一个容器-run"><a href="#10、运行一个容器-run" class="headerlink" title="10、运行一个容器-run"></a><strong>10、运行一个容器-run</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 overlay2]# docker run -it alpine sh   #运行并进入alpine</span><br></pre></td></tr></table></figure><p>后台运行（-d后台运行）（–name添加一个名字）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 overlay2]# docker run -it -d --name test1</span><br></pre></td></tr></table></figure><p>还有一种-rm参数，ctrl+c后就删除，可以测试环境用，生成环境用的少</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 overlay2]# docker run -it  --rm --name centos nginx</span><br></pre></td></tr></table></figure><h3 id="11、如何进入容器"><a href="#11、如何进入容器" class="headerlink" title="11、如何进入容器"></a><strong>11、如何进入容器</strong></h3><p>三种方法，上面已经演示了一种</p><p>第一种，需要容器本身的pid及util-linux，不推荐，暂时不演示了</p><p>第二种，不分配bash终端的一种实施操作，不推荐，这种操作如果在开一个窗口也能看到操作的指令，所有人都能看到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 overlay2]# docker ps</span><br><span class="line">[root@web1 overlay2]# docker attach mynginx</span><br></pre></td></tr></table></figure><p>第三种：exec方式，终端时分开的，推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 overlay2]# docker exec -it mynginx sh</span><br></pre></td></tr></table></figure><h3 id="12、查看docker进程及删除容器"><a href="#12、查看docker进程及删除容器" class="headerlink" title="12、查看docker进程及删除容器"></a><strong>12、查看docker进程及删除容器</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 overlay2]# docker ps -a 　　　　　　#-a :显示所有的容器，包括未运行的CONTAINER ID      [root@web1 overlay2]# docker rm 9fc796e928d7 #rm时删除一个或多个容器9fc796e928d7</span><br></pre></td></tr></table></figure><h3 id="13、查看容器详细信息"><a href="#13、查看容器详细信息" class="headerlink" title="13、查看容器详细信息"></a><strong>13、查看容器详细信息</strong></h3><p>并不需要进入到容器里面，通过查看详细信息看到了刚才运行的nginx，宿主机curl ip地址访问一下运行情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 overlay2]#  docker inspect mynginx</span><br><span class="line">[root@web1 overlay2]#</span><br></pre></td></tr></table></figure><h3 id="14、查看日志"><a href="#14、查看日志" class="headerlink" title="14、查看日志"></a><strong>14、查看日志</strong></h3><p>-f  挂起这个终端，动态查看日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@web1 ~]# docker logs  -f mynginx</span><br></pre></td></tr></table></figure><p><strong>参考文章：</strong></p><p><a href="https://cloud.tencent.com/developer/article/1006116" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1006116</a>  </p><p><a href="https://yq.aliyun.com/articles/65145" target="_blank" rel="noopener">https://yq.aliyun.com/articles/65145</a></p><p><a href="https://blog.51cto.com/10085711/2068290" target="_blank" rel="noopener">https://blog.51cto.com/10085711/2068290</a></p><p><a href="https://www.cnblogs.com/zuxing/articles/8717415.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuxing/articles/8717415.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;终于有人把-Docker-讲清楚了&quot;&gt;&lt;a href=&quot;#终于有人把-Docker-讲清楚了&quot; class=&quot;headerlink&quot; title=&quot;终于有人把 Docker 讲清楚了&quot;&gt;&lt;/a&gt;终于有人把 Docker 讲清楚了&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/10/31/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%BA%E6%8A%8ADocker%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/640.webp&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;作者 | 乐章&lt;/p&gt;
&lt;p&gt;来源 | cnblogs.com/zhangxingeng/p/11236968.html&lt;/p&gt;
&lt;p&gt;编辑：Java技术栈（id：javastack）&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、简介&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;1、了解Docker的前生LXC&quot;&gt;&lt;a href=&quot;#1、了解Docker的前生LXC&quot; class=&quot;headerlink&quot; title=&quot;1、了解Docker的前生LXC&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、了解Docker的前生LXC&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;LXC为Linux Container的简写。可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。相当于C++中的NameSpace。容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="持续集成" scheme="http://geoffen.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="docker" scheme="http://geoffen.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>sourcetree3免注册登录bitbucket教程</title>
    <link href="http://geoffen.github.io/2019/10/31/sourcetree3%E5%85%8D%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95bitbucket%E6%95%99%E7%A8%8B/"/>
    <id>http://geoffen.github.io/2019/10/31/sourcetree3免注册登录bitbucket教程/</id>
    <published>2019-10-31T09:10:00.000Z</published>
    <updated>2019-10-31T09:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sourcetree下载"><a href="#Sourcetree下载" class="headerlink" title="Sourcetree下载"></a>Sourcetree下载</h2><p>Sourcetree：一个用于Windows和Mac的免费Git客户端。<br>官网：<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Sourcetree | Free Git GUI for Mac and Windows</a></p><a id="more"></a><p>下载之后，双击打开安装程序，新版本安装界面如下，提示需要登录bitbucket账号后才能继续安装</p><p>旧版 sourcetree 只需要手动添加 一个 accounts.json 文件就能实现免注册登录，而新版本则需要再修改 user.config 文件中的配置。</p><h2 id="添加-accounts-json-文件"><a href="#添加-accounts-json-文件" class="headerlink" title="添加 accounts.json 文件"></a>添加 accounts.json 文件</h2><p><code>%LocalAppData%\Atlassian\SourceTree\accounts.json</code><br>在以上目录位置创建一个accounts.json文件，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"$id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"$type"</span>: <span class="string">"SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity"</span>,</span><br><span class="line">    <span class="attr">"Authenticate"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"HostInstance"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"2"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">      <span class="attr">"Host"</span>: &#123;</span><br><span class="line">        <span class="attr">"$id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"atlassian account"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"BaseUrl"</span>: <span class="string">"https://id.atlassian.com/"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Credentials"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"4"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account"</span>,</span><br><span class="line">      <span class="attr">"Username"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"Email"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"IsDefault"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="修改-user-config-文件配置"><a href="#修改-user-config-文件配置" class="headerlink" title="修改 user.config 文件配置"></a>修改 user.config 文件配置</h2><p>该文件所在路径：<br><code>%LocalAppData%\Atlassian\SourceTree.exe_Url_xxxxxxxxxx\3.1.2.3027\user.config</code></p><p>记事本打开 user.config，在<code>&lt;SourceTree.Properties.Settings&gt;</code>添加以下内容并保存即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=&quot;AgreedToEULAVersion&quot; serializeAs=&quot;String&quot;&gt;</span><br><span class="line">    &lt;value&gt;20160201&lt;/value&gt;</span><br><span class="line">&lt;/setting&gt;</span><br></pre></td></tr></table></figure><p>最后再次打开 sourcetree 安装程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Sourcetree下载&quot;&gt;&lt;a href=&quot;#Sourcetree下载&quot; class=&quot;headerlink&quot; title=&quot;Sourcetree下载&quot;&gt;&lt;/a&gt;Sourcetree下载&lt;/h2&gt;&lt;p&gt;Sourcetree：一个用于Windows和Mac的免费Git客户端。&lt;br&gt;官网：&lt;a href=&quot;https://www.sourcetreeapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sourcetree | Free Git GUI for Mac and Windows&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发工具" scheme="http://geoffen.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://geoffen.github.io/tags/git/"/>
    
      <category term="sourcetree" scheme="http://geoffen.github.io/tags/sourcetree/"/>
    
  </entry>
  
  <entry>
    <title>docker使用说明</title>
    <link href="http://geoffen.github.io/2019/10/30/docker%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://geoffen.github.io/2019/10/30/docker使用说明/</id>
    <published>2019-10-30T13:12:14.000Z</published>
    <updated>2019-11-01T09:01:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看docker运行信息"><a href="#查看docker运行信息" class="headerlink" title="查看docker运行信息"></a>查看docker运行信息</h2><p>docker inspect 会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker inspect NAMES </span><br><span class="line"># 查看容器所有状态信息；</span><br><span class="line"></span><br><span class="line">docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; ID/NAMES</span><br><span class="line"># 查看 容器ip 地址</span><br><span class="line"></span><br><span class="line">docker inspect --format &apos;&#123;&#123;.Name&#125;&#125; &#123;&#123;.State.Running&#125;&#125;&apos; NAMES</span><br><span class="line"># 容器运行状态</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>查看进程信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top NAMES</span><br></pre></td></tr></table></figure><p><strong>查看端口；(使用容器ID 或者 容器名称)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port ID/NAMES</span><br></pre></td></tr></table></figure><p><strong>查看IP地址 也可以直接通过用 远程执行命令也可以</strong>（Centos7）；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it ID/NAMES ip addr</span><br></pre></td></tr></table></figure><h2 id="docker-的安装及使用"><a href="#docker-的安装及使用" class="headerlink" title="docker 的安装及使用"></a>docker 的安装及使用</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><blockquote><p>docker 是一个开源的软件部署解决方案<br>docker 也是轻量级的应用容器框架<br>docker 可以打包、发布、运行任何的应用</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>阿里云</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><ul><li>daocloud</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure><p>安装后将会自动重启</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine</span><br><span class="line">rm -fr /var/lib/docker/</span><br></pre></td></tr></table></figure><h3 id="配置加速器"><a href="#配置加速器" class="headerlink" title="配置加速器"></a>配置加速器</h3><p>下面是我的配置，实际使用需要根据自己的账号去查看自己的地址</p><ul><li><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://ced808ab.m.daocloud.io</span><br><span class="line">sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure><ul><li><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">阿里云</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://dist7hw1.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul><li><p>查看版本:<code>docker -v</code> //文章使用版本：Docker version 18.06.0-ce, build 0ffa825</p></li><li><p>查看镜像：<code>docker images</code></p></li><li><p>查看容器：<code>docker ps</code></p></li><li><p>启动 docker 服务：<code>sudo service docker start</code></p></li><li><p>停止 docker 服务：<code>sudo service docker stop</code></p></li><li><p>重启 docker 服务：<code>sudo service docker restart</code></p></li><li><p>进入一个运行中的容器：<code>docker exec -it 容器Id /bin/bash</code></p></li></ul><h3 id="通过-Dockerfile-使用-nginx"><a href="#通过-Dockerfile-使用-nginx" class="headerlink" title="通过 Dockerfile 使用 nginx"></a>通过 Dockerfile 使用 nginx</h3><p>通过下面的一个脚本可以简单快速的创建一个镜像并运行起来<br>大概看下应该就可以大概明白镜像的基本使用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;0.创建测试目录及代码&apos;</span><br><span class="line">mkdir dockerfiletest</span><br><span class="line">cd dockerfiletest</span><br><span class="line">mkdir dist</span><br><span class="line">echo &apos;hello world&apos;&gt;./dist/index.html</span><br><span class="line"></span><br><span class="line">echo &apos;1.创建Dockerfile&apos;</span><br><span class="line">echo &apos;</span><br><span class="line">From daocloud.io/library/nginx:1.13.0-alpine</span><br><span class="line">COPY dist/ /usr/share/nginx/html/</span><br><span class="line">&apos;&gt;./Dockerfile</span><br><span class="line"></span><br><span class="line">echo &apos;2.构建镜像&apos;</span><br><span class="line">docker build -t dockerfiletest .</span><br><span class="line"></span><br><span class="line">echo &apos;3.运行镜像&apos;</span><br><span class="line">docker run -p 3344:80 dockerfiletest</span><br></pre></td></tr></table></figure><p>下面分步拆解下</p><h4 id="1-添加-Dockerfile-文件"><a href="#1-添加-Dockerfile-文件" class="headerlink" title="1.添加 Dockerfile 文件"></a>1.添加 Dockerfile 文件</h4><p>详细请参考：<a href="https://hub.daocloud.io/repos/2b7310fb-1a50-48f2-9586-44622a2d1771" target="_blank" rel="noopener">https://hub.daocloud.io/repos/2b7310fb-1a50-48f2-9586-44622a2d1771</a></p><p>html 的简单部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">From daocloud.io/library/nginx:1.13.0-alpine</span><br><span class="line"># 将发布目录的文件拷贝到镜像中</span><br><span class="line">COPY dist/ /usr/share/nginx/html/</span><br></pre></td></tr></table></figure><p>若要使用自己的配置脚本，比如 vue 的配置,可以将自己的配置文件复制到容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">From daocloud.io/library/nginx:1.13.0-alpine</span><br><span class="line"># 删除镜像中 nginx 的默认配置</span><br><span class="line">RUN rm /etc/nginx/conf.d/default.conf</span><br><span class="line"># 复制 default.conf 到镜像中</span><br><span class="line">ADD default.conf /etc/nginx/conf.d/</span><br><span class="line"># 将发布目录的文件拷贝到镜像中</span><br><span class="line">COPY dist/ /usr/share/nginx/html/</span><br></pre></td></tr></table></figure><p>nginx 中 vue history 模式的配置 如下，可参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /usr/share/nginx/html/;</span><br><span class="line">        index index.html;</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>若是将<code>/usr/share/nginx/html/</code>和<code>/etc/nginx/conf.d/</code>挂载到本地，这样应该能够灵活使用 docker 安装的 nginx 了(未实践过)</del></p><h4 id="2-构建镜像"><a href="#2-构建镜像" class="headerlink" title="2.构建镜像"></a>2.构建镜像</h4><p>构建参数说明参考：<a href="http://www.runoob.com/docker/docker-build-command.html" target="_blank" rel="noopener">http://www.runoob.com/docker/docker-build-command.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t docker-nginx-test .</span><br></pre></td></tr></table></figure><h4 id="3-运行镜像"><a href="#3-运行镜像" class="headerlink" title="3.运行镜像"></a>3.运行镜像</h4><p>–name 服务名<br>-d 后台运行<br>-p 暴露端口:nginx 端口<br>docker-nginx-test 镜像名/IMAGE ID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name dockertest -d -p 4455:80 docker-nginx-test</span><br></pre></td></tr></table></figure><h4 id="4-测试访问"><a href="#4-测试访问" class="headerlink" title="4.测试访问"></a>4.测试访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# curl http://localhost:4455</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><blockquote><p>现在，可以通过 IP+端口的形式在外网访问站点了，但在实际使用肯定还需要绑定域名等一些操作<br>最简单的是我认为是使用 nginx 去做代理<br>目前我们公司使用的 <a href="https://traefik.io/" target="_blank" rel="noopener">traefik</a> ，最爽的莫过于 https 的支持，可以了解一下</p></blockquote><h4 id="5-基础操作"><a href="#5-基础操作" class="headerlink" title="5.基础操作"></a>5.基础操作</h4><p>1 <strong>docker images</strong> 查看镜像信息列表 镜像是静态的</p><p>2 <strong>docker ps -a</strong> 查看运行中的所有容器</p><p>3 <strong>docker pull  [images]:[version]</strong>从dockerhub拉取指定镜像</p><p>4 <strong>docker run -p 8000:80 -tdi –privileged [imageID] [command]</strong>  后台启动docker,并指定宿主机端口和docker映射端口。</p><p> <strong>-i:</strong>以交互模式运行容器，通常与 -t 同时使用；</p><p> <strong>-d:</strong>后台运行容器，并返回容器ID；</p><p><strong>-t:</strong>为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p><strong>–privileged</strong> 容器将拥有访问主机所有设备的权限</p><p>通常情况下 [command] 填下 <strong>/bin/bash</strong> 即可。</p><p>完整参数：</p><ul><li><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的高端口</li><li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>–name=”nginx-lb”:</strong> 为容器指定一个名称；</li><li><strong>–dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>–dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li><strong>-e username=”ritchie”:</strong> 设置环境变量；</li><li><strong>–env-file=[]:</strong> 从指定文件读入环境变量；</li><li><strong>–cpuset=”0-2” or –cpuset=”0,1,2”:</strong> 绑定容器到指定CPU运行；</li><li><strong>-m :</strong>设置容器使用内存最大值；</li><li><strong>–net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li><strong>–link=[]:</strong> 添加链接到另一个容器；</li><li><strong>–expose=[]:</strong> 开放一个端口或一组端口；</li><li><strong>–volume , -v:</strong> 绑定一个卷</li></ul><p>特殊情况下，如需要在centos镜像中使用<strong>systemctl</strong> . 则应添加<strong>–privileged</strong> 并设置[command ]为 <strong>init</strong>。</p><p>5 当镜像通过run 启动后，便会载入到一个动态的container(容器)中运行，此时若需要进入终端交互模式：</p><p><strong>sudo docker exec -it [containerID] /bin/bash</strong></p><p>交互模式中，使用  ctrl+p+q退出交互 保持运行,使用 exit命令退出并停止容器。</p><p>6 在容器非交互模式下，通过docker  start/stop 命令来启动/停止已部署的容器服务。</p><p>7 <strong>docker rm [containerID]</strong> 删除容器</p><p>8 <strong>docker rmi [imageID]</strong> 删除镜像</p><p>9 <strong>docker cp [YourHostFilePath] [containerID]:[DockerPath]</strong>  将宿主机内的指定文件传输至容器内部的指定地址。</p><p>10 <strong>docker logs -f  [containerID]  –tail 10 -t</strong> 查看日志，使用 <code>-f</code> 参数后，就可以查看实时日志了，</p><p>使用 <code>--tail</code> 参数可以精确控制日志的输出行数， <code>-t</code> 参数则可以显示日志的输出时间。</p><h4 id="6-镜像制作"><a href="#6-镜像制作" class="headerlink" title="6.镜像制作"></a>6.镜像制作</h4><p>1  <strong>docker commit [containerID] [ImageName]:[Version]</strong> 将修改后的容器重新打包成镜像</p><p>2 <strong>docker commit -a “runoob.com” -m “my apache” a404c6c174a2 mymysql:v1</strong> 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p><p><strong>-a</strong> :提交的镜像作者；</p><p> <strong>-c</strong> :使用Dockerfile指令来创建镜像；</p><p> <strong>-m</strong> :提交时的说明文字；</p><p> <strong>-p</strong> :在commit时，将容器暂停。</p><p>3 <strong>docker push [ImageID] [repertory_address]</strong>提交镜像到云仓库</p><h2 id="docker容器及镜像清理"><a href="#docker容器及镜像清理" class="headerlink" title="docker容器及镜像清理"></a>docker容器及镜像清理</h2><p>To clean up, all unused containers, images, network, and volumes, use the following command.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune</span><br></pre></td></tr></table></figure><p><strong>Recommended:</strong> <a href="http://skillslane.com/offer/learn-docker-technologies-devops-developers/" target="_blank" rel="noopener">Learn Docker Technologies for DevOps and Developers 53</a></p><p>To individually delete all the components, use the following commands.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br><span class="line">docker image prune</span><br><span class="line">docker network prune</span><br><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><p>For Docker versions below 1.13</p><p>To clean up containers, first, you need to clean up your containers. So that all the unwanted images can be deleted without dependency problems.</p><p>Delete all Exited Containers</p><blockquote><p>docker rm $(docker ps -q -f status=exited) </p></blockquote><p>Delete all Stopped Containers</p><blockquote><p>docker rm $(docker ps -a -q)<br>####Delete All Running and Stopped Containers<br>docker stop $(docker ps -a -q)<br>docker rm $(docker ps -a -q)</p></blockquote><h4 id="Delete-all-“none”-Images"><a href="#Delete-all-“none”-Images" class="headerlink" title="Delete all “none” Images"></a>Delete all “none” Images</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &apos;&#123; print $3 &#125;&apos;)</span><br></pre></td></tr></table></figure><h4 id="Delete-all-Dangling-Images"><a href="#Delete-all-Dangling-Images" class="headerlink" title="Delete all Dangling Images"></a>Delete all Dangling Images</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi $(sudo docker images -f &quot;dangling=true&quot; -q)</span><br></pre></td></tr></table></figure><p>Update Sept. 2016: Docker 1.13: <a href="https://github.com/docker/docker/pull/26108" target="_blank" rel="noopener">PR 26108</a> and <a href="https://github.com/docker/docker/commit/86de7c000f5d854051369754ad1769194e8dd5e1" target="_blank" rel="noopener">commit 86de7c0</a> introduce a few new commands to help facilitate visualizing how much space the docker daemon data is taking on disk and allowing for easily cleaning up “unneeded” excess.</p><p><a href="https://docs.docker.com/engine/reference/commandline/system_prune/" target="_blank" rel="noopener"><strong>docker system prune</strong></a> will delete ALL dangling data (i.e. In order: containers stopped, volumes without containers and images with no containers). Even unused data, with <code>-a</code> option.</p><p>You also have:</p><ul><li><a href="https://docs.docker.com/engine/reference/commandline/container_prune/" target="_blank" rel="noopener"><code>docker container prune</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/image_prune/" target="_blank" rel="noopener"><code>docker image prune</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/network_prune/" target="_blank" rel="noopener"><code>docker network prune</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/" target="_blank" rel="noopener"><code>docker volume prune</code></a></li></ul><p>For <em>unused</em> images, use <code>docker image prune -a</code> (for removing dangling <em>and</em> ununsed images).<br>Warning: ‘<em>unused</em>‘ means “images not referenced by any container”: be careful before using <code>-a</code>.</p><p>As illustrated in <a href="https://stackoverflow.com/users/1207596/a-l" target="_blank" rel="noopener">A L</a>‘s <a href="https://stackoverflow.com/a/50405599/6309" target="_blank" rel="noopener">answer</a>, <code>docker system prune --all</code> will remove all <em>unused</em> images not just dangling ones… which can be a bit too much.</p><p>Combining <code>docker xxx prune</code> with the <a href="https://docs.docker.com/engine/reference/commandline/system_prune/#filtering" target="_blank" rel="noopener"><code>--filter</code> option</a> can be a great way to limit the pruning (<a href="https://docs.docker.com/develop/sdk/#api-version-matrix" target="_blank" rel="noopener">docker SDK API 1.28 minimum, so docker 17.04+</a>)</p><blockquote><p>The currently supported filters are:</p></blockquote><ul><li><code>until (&lt;timestamp&gt;)</code> - only remove containers, images, and networks created before given timestamp</li><li><code>label</code> (<code>label=&lt;key&gt;</code>, <code>label=&lt;key&gt;=&lt;value&gt;</code>, <code>label!=&lt;key&gt;</code>, or <code>label!=&lt;key&gt;=&lt;value&gt;</code>) - only remove containers, images, networks, and volumes with (or <em>without</em>, in case <code>label!=...</code> is used) the specified labels.</li></ul><p>See “<a href="https://docs.docker.com/config/pruning/#prune-images" target="_blank" rel="noopener">Prune images</a>“ for an example.</p><hr><p>Original answer (Sep. 2016)</p><p>I usually do:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images --filter &quot;dangling=true&quot; -q --no-trunc)</span><br></pre></td></tr></table></figure><p>I have an <a href="https://github.com/docker/docker/blob/634a848b8e3bdd8aed834559f3b2e0dfc7f5ae3a/man/docker-images.1.md#options" target="_blank" rel="noopener">alias for removing those [dangling images]</a><a href="https://github.com/docker/docker/blob/634a848b8e3bdd8aed834559f3b2e0dfc7f5ae3a/man/docker-images.1.md#options" target="_blank" rel="noopener">13</a>: <code>drmi</code></p><blockquote><p>The <code>dangling=true</code> filter finds unused images</p></blockquote><p>That way, any intermediate image no longer referenced by a labelled image is removed.</p><p>I do the same <strong>first</strong> for <a href="https://github.com/VonC/b2d/blob/b010ab51974ac7de6162cdcbff795d7b9e84fd67/.bash_aliases#L21" target="_blank" rel="noopener">exited processes (containers)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias drmae=&apos;docker rm $(docker ps -qa --no-trunc --filter &quot;status=exited&quot;)&apos;</span><br></pre></td></tr></table></figure><p>As <a href="https://stackoverflow.com/users/95750/haridsv" target="_blank" rel="noopener">haridsv</a> points out <a href="https://stackoverflow.com/questions/32723111/how-to-remove-old-and-unused-docker-images/32723127#comment63457575_32723127" target="_blank" rel="noopener">in the comments</a>:</p><blockquote><p>Technically, <strong>you should first clean up containers before cleaning up images, as this will catch more dangling images and less errors</strong>.</p></blockquote><hr><p><a href="https://github.com/jfrazelle" target="_blank" rel="noopener">Jess Frazelle (jfrazelle)</a> has the <a href="https://github.com/jfrazelle/dotfiles/blob/a7fd3df6ab423e6dd04f27727f653753453db837/.dockerfunc#L8-L11" target="_blank" rel="noopener">bashrc function</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dcleanup()&#123;</span><br><span class="line">    docker rm -v $(docker ps --filter status=exited -q 2&gt;/dev/null) 2&gt;/dev/null</span><br><span class="line">    docker rmi $(docker images --filter dangling=true -q 2&gt;/dev/null) 2&gt;/dev/null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>To remove old images, and not just “unreferenced-dangling” images, you can consider <a href="https://github.com/spotify/docker-gc" target="_blank" rel="noopener"><strong>docker-gc</strong></a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --no-trunc --format &apos;&#123;&#123;.ID&#125;&#125; &#123;&#123;.CreatedSince&#125;&#125; &#123;&#123;.Repository&#125;&#125;&apos; \</span><br><span class="line">    | grep &apos; months&apos; | awk &apos;&#123; print $1 &#125;&apos; \</span><br><span class="line">    | xargs --no-run-if-empty docker rmi</span><br></pre></td></tr></table></figure><p>Example of <code>/etc/cron.daily/docker-gc</code> script:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh -e</span><br><span class="line"></span><br><span class="line"># Delete all stopped containers (including data-only containers).</span><br><span class="line">docker ps -a -q --no-trunc --filter &quot;status=exited&quot; | xargs --no-run-if-empty docker rm -v</span><br><span class="line"></span><br><span class="line"># Delete all tagged images more than a month old</span><br><span class="line"># (will fail to remove images still used).</span><br><span class="line">docker images --no-trunc --format &apos;&#123;&#123;.ID&#125;&#125; &#123;&#123;.CreatedSince&#125;&#125;&apos; | grep &apos; months&apos; | awk &apos;&#123; print $1 &#125;&apos; | xargs --no-run-if-empty docker rmi || true</span><br><span class="line"></span><br><span class="line"># Delete all &apos;untagged/dangling&apos; (&lt;none&gt;) images</span><br><span class="line"># Those are used for Docker caching mechanism.</span><br><span class="line">docker images -q --no-trunc --filter dangling=true | xargs --no-run-if-empty docker rmi</span><br><span class="line"></span><br><span class="line"># Delete all dangling volumes.</span><br><span class="line">docker volume ls -qf dangling=true | xargs --no-run-if-empty docker volume rm</span><br></pre></td></tr></table></figure><h2 id="docker-compose-的安装及使用"><a href="#docker-compose-的安装及使用" class="headerlink" title="docker-compose 的安装及使用"></a>docker-compose 的安装及使用</h2><h3 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h3><blockquote><p>Docker Compose 是一个用来定义和运行复杂应用的 Docker 工具。<br>使用 Docker Compose 不再需要使用 shell 脚本来启动容器。(通过 docker-compose.yml 配置)</p></blockquote><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>可以通过修改 URL 中的版本，自定义您需要的版本。</p><ul><li>Github源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><ul><li>Daocloud镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="卸载-1"><a href="#卸载-1" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="基础命令-1"><a href="#基础命令-1" class="headerlink" title="基础命令"></a>基础命令</h3><p>需要在 docker-compose.yml 所在文件夹中执行命令</p><p>使用 docker-compose 部署项目的简单步骤</p><ul><li>停止现有 docker-compose 中的容器：<code>docker-compose down</code></li><li>重新拉取镜像：<code>docker-compose pull</code></li><li>后台启动 docker-compose 中的容器：<code>docker-compose up -d</code></li></ul><p>下面将介绍 <code>docker-compose</code> 子命令的使用。也可以通过运行 <code>docker-compose --help</code>来查看这些信息。</p><ul><li><a href="#build">build</a></li><li><a href="#help">help</a></li><li><a href="#kill">kill</a></li><li><a href="#ps">ps</a></li><li><a href="#restart">restart</a></li><li><a href="#run">run</a></li><li><a href="#start">start</a></li><li><a href="#up">up</a></li><li><a href="#logs">logs</a></li><li><a href="#port">port</a></li><li><a href="#pull">pull</a></li><li><a href="#rm">rm</a></li><li><a href="#scale">scale</a></li><li><a href="#stop">stop</a></li></ul><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用法：build [options] [SERVICE...]</span><br><span class="line">选项：</span><br><span class="line">--force-rm  总是移除构建过程中产生的中间项容器</span><br><span class="line">--no-cache  构建镜像过程中不使用Cache</span><br><span class="line">--pull      总是尝试获取更新版本的镜像</span><br></pre></td></tr></table></figure><p>构建服务并打上<code>project_service</code>风格的标签（如：<code>composetest_db</code>）。如果你更改了服务的<code>Dockerfile</code>或者构建目录下的内容，需要运行<code>docker-compose build</code>重新构建服务。</p><h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法：help COMMAND</span><br></pre></td></tr></table></figure><p>显示命令的帮助信息及用法教程。</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用法：kill [options] [SERVICE...]</span><br><span class="line">选项：</span><br><span class="line">-s SIGNAL         SIGNAL 是发送给容器的信号量，默认是 SIGKILL</span><br></pre></td></tr></table></figure><p>通过发送<code>SIGKILL</code>信号来强制终止运行中的容器，也可以发送指定的信号量，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose kill -s SIGINT</span><br></pre></td></tr></table></figure><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用法：ps [options] [SERVICE...]</span><br><span class="line">选项：</span><br><span class="line">-q仅仅显示容器ID</span><br></pre></td></tr></table></figure><p>列出容器。</p><h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用法：restart [options] [SERVICE...]</span><br><span class="line">选项：</span><br><span class="line">-t, --timeout TIMEOUT      设置关闭服务的超时时间，单位为秒，默认为10</span><br></pre></td></tr></table></figure><p>重启服务。</p><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用法：run [options] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</span><br><span class="line">选项：</span><br><span class="line">-d                    分离模式：在后台运行容器，只打印新的容器名称</span><br><span class="line">--entrypoint CMD      覆盖镜像的入口点（CMD ...）</span><br><span class="line">-e KEY=VAL            设置环境变量，可以使用多次</span><br><span class="line">-u, --user=&quot;&quot;         通过指定的用户名或用户id来运行</span><br><span class="line">--no-deps             不启动link连接的服务</span><br><span class="line">--rm                  运行结束后移除容器，在分离模式下将被忽略</span><br><span class="line">-p, --publish=[]      将容器暴露端口映射到主机端口</span><br><span class="line">--service-ports       通过服务映射到主机的端口执行命令</span><br><span class="line">-T                    禁用pseudo-tty分配，默认会分配一个TTY</span><br></pre></td></tr></table></figure><p>对服务运行的命令。例如，以下命令启动web服务并运行bash命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run web bash</span><br></pre></td></tr></table></figure><p><code>run</code>命令，将使用服务中已经定义的配置来创建运行一个新的容器。也就是说，如此创建的容器，将会使用相同的挂载卷、容器连接等相同的配置，但它们依旧可以存在差异。</p><p>第一个区别是，可以使用<code>run</code>命令覆盖服务中指定的运行命令。例如，<code>web</code>服务中的配置指定的运行命令为<code>bash</code>，那么<code>docker-compose run web python app.py</code>将使用<code>python app.py</code>来覆盖它。</p><p>第二个区别是，<code>docker-compose run</code>命令不会创建任何服务配置中指定的端口映射，这样可以防止多个容器映射同一端口的冲突。如果你需要使得服务的端口创建并映射到主机，需要指定<code>--service-ports</code>标记，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --service-ports web python manage.py shell</span><br></pre></td></tr></table></figure><p>或者可以手动指定端口映射，和使用<code>docker run</code>一样，使用<code>--publish</code>或<code>-p</code>选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --publish 8080:80 -p 2022:22 -p 127.0.0.1:2021:21 web python manage.py shell</span><br></pre></td></tr></table></figure><p>如果启动一个带有容器连接的服务，<code>run</code>命令将首先检查连接到的服务是否已运行，如果是停止状态，将会启动它，直到所有的相关服务都处于正在运行状态，才会执行你创建的命令。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run db psql -h db -U docker</span><br></pre></td></tr></table></figure><p>这将创建一个与PostgreSQL容器<code>db</code>交互服务。</p><p>如果你不希望启动相关联容器，可以使用<code>--no-deps</code>标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure><h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法：start [SERVICE...]</span><br></pre></td></tr></table></figure><p>启动服务中已经存在的容器。</p><h4 id="up"><a href="#up" class="headerlink" title="up"></a>up</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用法：up [options] [SERVICE...]</span><br><span class="line">选项：</span><br><span class="line">-d                     分离模式：在后台运行容器，只打印新的容器名称</span><br><span class="line">--no-color             单色输出</span><br><span class="line">--no-deps              不启动link连接的服务</span><br><span class="line">--force-recreate       强制重新创建容器，即使镜像没有任何改变。与--no-recreate会冲突</span><br><span class="line">--no-recreate          如果对应容器已经存在,不重新创建它。与--force-recreate会冲突</span><br><span class="line">--no-build             不构建镜像，即使缺失</span><br><span class="line">-t, --timeout TIMEOUT  为容器设置关闭超时时间，单位：秒 (默认为 10)</span><br></pre></td></tr></table></figure><p>对服务，构建镜像、(重新)创建容器、启动容器。</p><p>该命令还将启动任何相关的且没有被启动的服务。</p><p><code>docker-compose up</code>命令将显示所有容器的输出，命令结束时，所有容器都将关闭。运行<code>docker-compose up -d</code>将在后台启动运行容器。</p><p>如果服务中已经存在运行中的容器了，并且在容器创建后更改服务配置或者镜像，<code>docker-compose up</code>命令将会停止当前容器（保存挂载卷）并重新构建启动容器。当然，也可以通过<code>--no-recreate</code>选项来避免重新构建。</p><p>使用<code>--force-recreate</code>标记，可以强制停止并重构所有容器。</p><h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用法：logs [options] [SERVICE...]</span><br><span class="line">选项：</span><br><span class="line">--no-color  单色输出</span><br></pre></td></tr></table></figure><p>显示服务输出的日志内容。</p><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用法：port [options] SERVICE PRIVATE_PORT</span><br><span class="line">选项：</span><br><span class="line">--protocol=proto  tcp 或 udp [默认为 tcp]</span><br><span class="line">--index=index     对应实例服务的第几个容器[默认为 1]</span><br></pre></td></tr></table></figure><p>打印服务中端口绑定对应的主机端口。</p><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用法：pull [options] [SERVICE...]</span><br><span class="line">选项：</span><br><span class="line">--ignore-pull-failures 尽可能拉取服务，忽略拉取失败</span><br></pre></td></tr></table></figure><p>拉取服务镜像。</p><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用法：rm [options] [SERVICE...]</span><br><span class="line">选项:</span><br><span class="line">-f, --force   强制删除，不询问确认信息</span><br><span class="line">-v            移除容器挂载的卷</span><br></pre></td></tr></table></figure><p>删除停止的服务容器。</p><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法：scale [SERVICE=NUM...]</span><br></pre></td></tr></table></figure><p>设置一个服务需要运行的容器数量。<br>参数形式为<code>service=num</code>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose scale web=2 worker=3</span><br></pre></td></tr></table></figure><h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用法：stop [options] [SERVICE...]</span><br><span class="line">选项：</span><br><span class="line">-t, --timeout TIMEOUT      设置关闭容器的超时时间</span><br></pre></td></tr></table></figure><p>停止容器而不移除，可以通<code>docker-compose start</code>重新启动。</p><h3 id="通过-docker-compose-yml-部署应用"><a href="#通过-docker-compose-yml-部署应用" class="headerlink" title="通过 docker-compose.yml 部署应用"></a>通过 docker-compose.yml 部署应用</h3><p>我将上面所创建的镜像推送到了阿里云，在此使用它</p><h4 id="1-新建-docker-compose-yml-文件"><a href="#1-新建-docker-compose-yml-文件" class="headerlink" title="1.新建 docker-compose.yml 文件"></a>1.新建 docker-compose.yml 文件</h4><p>通过以下配置，在运行后可以创建两个站点(只为演示)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web1:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/yimo_public/docker-nginx-test:latest</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4466:80&quot;</span><br><span class="line">  web2:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/yimo_public/docker-nginx-test:latest</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4477:80&quot;</span><br></pre></td></tr></table></figure><p>此处只是简单演示写法，说明 docker-compose 的方便</p><h4 id="2-构建完成，后台运行镜像"><a href="#2-构建完成，后台运行镜像" class="headerlink" title="2.构建完成，后台运行镜像"></a>2.构建完成，后台运行镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>运行后就可以使用 ip+port 访问这两个站点了</p><h4 id="3-镜像更新重新部署"><a href="#3-镜像更新重新部署" class="headerlink" title="3.镜像更新重新部署"></a>3.镜像更新重新部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br><span class="line">docker-compose pull</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="详细命名说明"><a href="#详细命名说明" class="headerlink" title="详细命名说明"></a>详细命名说明</h2><h3 id="1、Docker安装"><a href="#1、Docker安装" class="headerlink" title="1、Docker安装"></a>1、Docker安装</h3><p>系统环境：docker最低支持centos7且在64位平台上，内核版本在3.10以上</p><p>版本：社区版，企业版（包含了一些收费服务）</p><p>官方版安装教程（英文）</p><blockquote><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-after-using-the-convenience-script" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-after-using-the-convenience-script</a></p></blockquote><p>博主版安装教程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装docker</span><br><span class="line">yum install docker</span><br><span class="line"># 启动docker </span><br><span class="line">systemctl start/status docker </span><br><span class="line"># 查看docker启动状态</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><p><strong>配置加速器</strong></p><p>简介：DaoCloud 加速器 是广受欢迎的 Docker 工具，解决了国内用户访问 Docker Hub 缓慢的问题。DaoCloud 加速器结合国内的 CDN 服务与协议层优化，成倍的提升了下载速度。</p><p>DaoCloud官网：</p><blockquote><p><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 一条命令加速（记得重启docker）</span><br><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://95822026.m.daocloud.io</span><br></pre></td></tr></table></figure><hr><h3 id="2、Docker基础命令"><a href="#2、Docker基础命令" class="headerlink" title="2、Docker基础命令"></a>2、Docker基础命令</h3><p>docker –help（中文注解）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">docker [OPTIONS] COMMAND [arg...]</span><br><span class="line">       docker daemon [ --help | ... ]</span><br><span class="line">       docker [ --help | -v | --version ]</span><br><span class="line">A</span><br><span class="line">self-sufficient runtime for containers.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --config=~/.docker              Location of client config files  #客户端配置文件的位置</span><br><span class="line">  -D, --debug=false               Enable debug mode  #启用Debug调试模式</span><br><span class="line">  -H, --host=[]                   Daemon socket(s) to connect to  #守护进程的套接字（Socket）连接</span><br><span class="line">  -h, --help=false                Print usage  #打印使用</span><br><span class="line">  -l, --log-level=info            Set the logging level  #设置日志级别</span><br><span class="line">  --tls=false                     Use TLS; implied by--tlsverify  #</span><br><span class="line">  --tlscacert=~/.docker/ca.pem    Trust certs signed only by this CA  #信任证书签名CA</span><br><span class="line">  --tlscert=~/.docker/cert.pem    Path to TLS certificate file  #TLS证书文件路径</span><br><span class="line">  --tlskey=~/.docker/key.pem      Path to TLS key file  #TLS密钥文件路径</span><br><span class="line">  --tlsverify=false               Use TLS and verify the remote  #使用TLS验证远程</span><br><span class="line">  -v, --version=false             Print version information and quit  #打印版本信息并退出</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">    attach    Attach to a running container  #当前shell下attach连接指定运行镜像</span><br><span class="line">    build     Build an image from a Dockerfile  #通过Dockerfile定制镜像</span><br><span class="line">    commit    Create a new image from a container&apos;s changes  #提交当前容器为新的镜像</span><br><span class="line">    cp    Copy files/folders from a container to a HOSTDIR or to STDOUT  #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line">    create    Create a new container  #创建一个新的容器，同run 但不启动容器</span><br><span class="line">    diff    Inspect changes on a container&apos;s filesystem  #查看docker容器变化</span><br><span class="line">    events    Get real time events from the server#从docker服务获取容器实时事件</span><br><span class="line">    exec    Run a command in a running container#在已存在的容器上运行命令</span><br><span class="line">    export    Export a container&apos;s filesystem as a tar archive  #导出容器的内容流作为一个tar归档文件(对应import)</span><br><span class="line">    history    Show the history of an image  #展示一个镜像形成历史</span><br><span class="line">    images    List images  #列出系统当前镜像</span><br><span class="line">    import    Import the contents from a tarball to create a filesystem image  #从tar包中的内容创建一个新的文件系统映像(对应export)</span><br><span class="line">    info    Display system-wide information  #显示系统相关信息</span><br><span class="line">    inspect    Return low-level information on a container or image  #查看容器详细信息</span><br><span class="line">    kill    Kill a running container  #kill指定docker容器</span><br><span class="line">    load    Load an image from a tar archive or STDIN  #从一个tar包中加载一个镜像(对应save)</span><br><span class="line">    login    Register or log in to a Docker registry#注册或者登陆一个docker源服务器</span><br><span class="line">    logout    Log out from a Docker registry  #从当前Docker registry退出</span><br><span class="line">    logs    Fetch the logs of a container  #输出当前容器日志信息</span><br><span class="line">    pause    Pause all processes within a container#暂停容器</span><br><span class="line">    port    List port mappings or a specific mapping for the CONTAINER  #查看映射端口对应的容器内部源端口</span><br><span class="line">    ps    List containers  #列出容器列表</span><br><span class="line">    pull    Pull an image or a repository from a registry  #从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line">    push    Push an image or a repository to a registry  #推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">    rename    Rename a container  #重命名容器</span><br><span class="line">    restart    Restart a running container  #重启运行的容器</span><br><span class="line">    rm    Remove one or more containers  #移除一个或者多个容器</span><br><span class="line">    rmi    Remove one or more images  #移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除)</span><br><span class="line">    run    Run a command in a new container  #创建一个新的容器并运行一个命令</span><br><span class="line">    save    Save an image(s) to a tar archive#保存一个镜像为一个tar包(对应load)</span><br><span class="line">    search    Search the Docker Hub for images  #在docker</span><br><span class="line">hub中搜索镜像</span><br><span class="line">    start    Start one or more stopped containers#启动容器</span><br><span class="line">    stats    Display a live stream of container(s) resource usage statistics  #统计容器使用资源</span><br><span class="line">    stop    Stop a running container  #停止容器</span><br><span class="line">    tag         Tag an image into a repository  #给源中镜像打标签</span><br><span class="line">    top       Display the running processes of a container #查看容器中运行的进程信息</span><br><span class="line">    unpause    Unpause all processes within a container  #取消暂停容器</span><br><span class="line">    version    Show the Docker version information#查看容器版本号</span><br><span class="line">    wait         Block until a container stops, then print its exit code  #截取容器停止时的退出状态值</span><br><span class="line"></span><br><span class="line">Run &apos;docker COMMAND --help&apos; for more information on a command.  #运行docker命令在帮助可以获取更多信息</span><br><span class="line">docker search  hello-docker  # 搜索hello-docker的镜像</span><br><span class="line">docker search centos # 搜索centos镜像</span><br><span class="line">docker pull hello-docker # 获取centos镜像</span><br><span class="line">docker run  hello-world   #运行一个docker镜像，产生一个容器实例（也可以通过镜像id前三位运行）</span><br><span class="line">docker image ls  # 查看本地所有镜像</span><br><span class="line">docker images  # 查看docker镜像</span><br><span class="line">docker image rmi hello-docker # 删除centos镜像</span><br><span class="line">docker ps  #列出正在运行的容器（如果创建容器中没有进程正在运行，容器就会立即停止）</span><br><span class="line">docker ps -a  # 列出所有运行过的容器记录</span><br><span class="line">docker save centos &gt; /opt/centos.tar.gz  # 导出docker镜像至本地</span><br><span class="line">docker load &lt; /opt/centos.tar.gz   #导入本地镜像到docker镜像库</span><br><span class="line">docker stop  `docker ps -aq`  # 停止所有正在运行的容器</span><br><span class="line">docker  rm `docker ps -aq`    # 一次性删除所有容器记录</span><br><span class="line">docker rmi  `docker images -aq`   # 一次性删除所有本地的镜像记录</span><br></pre></td></tr></table></figure><h4 id="2-1-启动容器的两种方式"><a href="#2-1-启动容器的两种方式" class="headerlink" title="2.1 启动容器的两种方式"></a>2.1 启动容器的两种方式</h4><p>容器是运行应用程序的，所以必须得先有一个操作系统为基础</p><p>1、基于镜像新建一个容器并启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 1. 后台运行一个docker</span><br><span class="line">docker run -d centos /bin/sh -c &quot;while true;do echo 正在运行; sleep 1;done&quot;</span><br><span class="line">    # -d  后台运行容器</span><br><span class="line">    # /bin/sh  指定使用centos的bash解释器</span><br><span class="line">    # -c 运行一段shell命令</span><br><span class="line">    # &quot;while true;do echo 正在运行; sleep 1;done&quot;  在linux后台，每秒中打印一次正在运行</span><br><span class="line">docker ps  # 检查容器进程</span><br><span class="line">docker  logs  -f  容器id/名称  # 不间断打印容器的日志信息 </span><br><span class="line">docker stop centos  # 停止容器</span><br><span class="line"></span><br><span class="line"># 2. 启动一个bash终端,允许用户进行交互</span><br><span class="line">docker run --name mydocker -it centos /bin/bash  </span><br><span class="line">    # --name  给容器定义一个名称</span><br><span class="line">    # -i  让容器的标准输入保持打开</span><br><span class="line">    # -t 让Docker分配一个伪终端,并绑定到容器的标准输入上</span><br><span class="line">    # /bin/bash 指定docker容器，用shell解释器交互</span><br></pre></td></tr></table></figure><p>当利用docker run来创建容器时，Docker在后台运行的步骤如下：</p><blockquote><ol><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂在一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个ip地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ol></blockquote><p>2、将一个终止状态(stopped)的容器重新启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a  # 先查询记录</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS                    NAMES</span><br><span class="line">ee92fcf6f32d        centos              &quot;/bin/bash&quot;              4 days ago          Exited (137) 3 days ago                                kickass_raman</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker start ee9  # 再启动这个容器</span><br><span class="line">ee9</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker exec -it  ee9 /bin/bash  # 进入容器交互式界面</span><br><span class="line">[root@ee92fcf6f32d /]#   # 注意看用户名，已经变成容器用户名</span><br></pre></td></tr></table></figure><h4 id="2-2-提交创建自定义镜像"><a href="#2-2-提交创建自定义镜像" class="headerlink" title="2.2 提交创建自定义镜像"></a>2.2 提交创建自定义镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1.我们进入交互式的centos容器中，发现没有vim命令</span><br><span class="line">    docker run -it centos</span><br><span class="line"># 2.在当前容器中，安装一个vim</span><br><span class="line">    yum install -y vim</span><br><span class="line"># 3.安装好vim之后，exit退出容器</span><br><span class="line">    exit</span><br><span class="line"># 4.查看刚才安装好vim的容器记录</span><br><span class="line">    docker container ls -a</span><br><span class="line"># 5.提交这个容器，创建新的image</span><br><span class="line">    docker commit 059fdea031ba chaoyu/centos-vim</span><br><span class="line"># 6.查看镜像文件</span><br><span class="line">    docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">chaoyu/centos-vim   latest              fd2685ae25fe        5 minutes ago</span><br></pre></td></tr></table></figure><h4 id="2-3-外部访问容器"><a href="#2-3-外部访问容器" class="headerlink" title="2.3 外部访问容器"></a>2.3 外部访问容器</h4><p>容器中可以运行网络应用，但是要让外部也可以访问这些应用，可以通过-p或-P参数指定端口映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br><span class="line">  # -P 参数会随机映射端口到容器开放的网络端口</span><br><span class="line"></span><br><span class="line"># 检查映射的端口</span><br><span class="line">docker ps -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED            STATUS              PORTS                     NAMES</span><br><span class="line">cfd632821d7a        training/webapp     &quot;python app.py&quot;     21 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;5000/tcp   brave_fermi</span><br><span class="line">#宿主机ip:32768 映射容器的5000端口</span><br><span class="line"></span><br><span class="line"># 查看容器日志信息</span><br><span class="line">docker logs -f cfd  # #不间断显示log</span><br><span class="line"></span><br><span class="line"># 也可以通过-p参数指定映射端口</span><br><span class="line">docker run -d -p 9000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><p>打开浏览器访问服务器的9000端口， 内容显示 Hello world！表示正常启动</p><p>(如果访问失败的话，检查自己的防火墙，以及云服务器的安全组)</p><hr><h3 id="3、利用dockerfile定制镜像"><a href="#3、利用dockerfile定制镜像" class="headerlink" title="3、利用dockerfile定制镜像"></a>3、利用dockerfile定制镜像</h3><p>镜像是容器的基础，每次执行docker run的时候都会指定哪个镜像作为容器运行的基础。我们之前的例子都是使用来自docker hub的镜像，直接使用这些镜像只能满足一定的需求，当镜像无法满足我们的需求时，就得自定制这些镜像。</p><blockquote><p>镜像的定制就是定制每一层所添加的配置、文件。如果可以吧每一层修改、安装、构建、操作的命令都写入到一个脚本，用脚本来构建、定制镜像，这个脚本就是dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令 构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p></blockquote><p>参数详解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch #制作base image 基础镜像，尽量使用官方的image作为base image</span><br><span class="line">FROM centos #使用base image</span><br><span class="line">FROM ubuntu:14.04 #带有tag的base image</span><br><span class="line"></span><br><span class="line">LABEL version=“1.0” #容器元信息，帮助信息，Metadata，类似于代码注释</span><br><span class="line">LABEL maintainer=“yc_uuu@163.com&quot;</span><br><span class="line"></span><br><span class="line">#对于复杂的RUN命令，避免无用的分层，多条命令用反斜线换行，合成一条命令！</span><br><span class="line">RUN yum update &amp;&amp; yum install -y vim </span><br><span class="line">    Python-dev #反斜线换行</span><br><span class="line">RUN /bin/bash -c &quot;source $HOME/.bashrc;echo $HOME”</span><br><span class="line"></span><br><span class="line">WORKDIR /root #相当于linux的cd命令，改变目录，尽量使用绝对路径！！！不要用RUN cd</span><br><span class="line">WORKDIR /test # 如果没有就自动创建</span><br><span class="line">WORKDIR demo # 再进入demo文件夹</span><br><span class="line">RUN pwd     # 打印结果应该是/test/demo</span><br><span class="line"></span><br><span class="line">ADD and COPY </span><br><span class="line">ADD hello /  # 把本地文件添加到镜像中，吧本地的hello可执行文件拷贝到镜像的/目录</span><br><span class="line">ADD test.tar.gz /  # 添加到根目录并解压</span><br><span class="line"></span><br><span class="line">WORKDIR /root</span><br><span class="line">ADD hello test/  # 进入/root/ 添加hello可执行命令到test目录下，也就是/root/test/hello 一个绝对路径</span><br><span class="line">COPY hello test/  # 等同于上述ADD效果</span><br><span class="line"></span><br><span class="line">ADD与COPY</span><br><span class="line">   - 优先使用COPY命令</span><br><span class="line">    -ADD除了COPY功能还有解压功能</span><br><span class="line">添加远程文件/目录使用curl或wget</span><br><span class="line"></span><br><span class="line">ENV # 环境变量，尽可能使用ENV增加可维护性</span><br><span class="line">ENV MYSQL_VERSION 5.6 # 设置一个mysql常量</span><br><span class="line">RUN yum install -y mysql-server=“$&#123;MYSQL_VERSION&#125;”</span><br></pre></td></tr></table></figure><p>进阶知识(了解)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">VOLUME and EXPOSE </span><br><span class="line">存储和网络</span><br><span class="line"></span><br><span class="line">RUN and CMD and ENTRYPOINT</span><br><span class="line">RUN：执行命令并创建新的Image Layer</span><br><span class="line">CMD：设置容器启动后默认执行的命令和参数</span><br><span class="line">ENTRYPOINT：设置容器启动时运行的命令</span><br><span class="line"></span><br><span class="line">Shell格式和Exec格式</span><br><span class="line">RUN yum install -y vim</span><br><span class="line">CMD echo ”hello docker”</span><br><span class="line">ENTRYPOINT echo “hello docker”</span><br><span class="line"></span><br><span class="line">Exec格式</span><br><span class="line">RUN [“apt-get”,”install”,”-y”,”vim”]</span><br><span class="line">CMD [“/bin/echo”,”hello docker”]</span><br><span class="line">ENTRYPOINT [“/bin/echo”,”hello docker”]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过shell格式去运行命令，会读取$name指令，而exec格式是仅仅的执行一个命令，而不是shell指令</span><br><span class="line">cat Dockerfile</span><br><span class="line">    FROM centos</span><br><span class="line">    ENV name Docker</span><br><span class="line">    ENTRYPOINT [“/bin/echo”,”hello $name”]#这个仅仅是执行echo命令，读取不了shell变量</span><br><span class="line">    ENTRYPOINT  [“/bin/bash”,”-c”,”echo hello $name&quot;]</span><br><span class="line"></span><br><span class="line">CMD</span><br><span class="line">容器启动时默认执行的命令</span><br><span class="line">如果docker run指定了其他命令(docker run -it [image] /bin/bash )，CMD命令被忽略</span><br><span class="line">如果定义多个CMD，只有最后一个执行</span><br><span class="line"></span><br><span class="line">ENTRYPOINT</span><br><span class="line">让容器以应用程序或服务形式运行</span><br><span class="line">不会被忽略，一定会执行</span><br><span class="line">最佳实践：写一个shell脚本作为entrypoint</span><br><span class="line">COPY docker-entrypoint.sh /usr/local/bin</span><br><span class="line">ENTRYPOINT [“docker-entrypoint.sh]</span><br><span class="line">EXPOSE 27017</span><br><span class="line">CMD [“mongod”]</span><br><span class="line"></span><br><span class="line">[root@master home]# more Dockerfile</span><br><span class="line">FROm centos</span><br><span class="line">ENV name Docker</span><br><span class="line">#CMD [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello $name&quot;]</span><br><span class="line">ENTRYPOINT [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello $name”]</span><br></pre></td></tr></table></figure><hr><h3 id="4、发布到仓库"><a href="#4、发布到仓库" class="headerlink" title="4、发布到仓库"></a>4、发布到仓库</h3><h4 id="4-1-docker-hub共有镜像发布"><a href="#4-1-docker-hub共有镜像发布" class="headerlink" title="4.1 docker hub共有镜像发布"></a>4.1 docker hub共有镜像发布</h4><p>docker提供了一个类似于github的仓库docker hub，官方网站（需注册使用）</p><blockquote><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 注册docker id后，在linux中登录dockerhub</span><br><span class="line">    docker login</span><br><span class="line"></span><br><span class="line"># 注意要保证image的tag是账户名，如果镜像名字不对，需要改一下tag</span><br><span class="line">    docker tag chaoyu/centos-vim peng104/centos-vim</span><br><span class="line">    # 语法是：docker tag   仓库名   peng104/仓库名</span><br><span class="line"></span><br><span class="line"># 推送docker image到dockerhub</span><br><span class="line">    docker push peng104/centps-cmd-exec:latest</span><br><span class="line"></span><br><span class="line"># 去dockerhub中检查镜像</span><br><span class="line"># 先删除本地镜像，然后再测试下载pull 镜像文件</span><br><span class="line">    docker pull peng104/centos-entrypoint-exec</span><br></pre></td></tr></table></figure><h4 id="4-2-私有仓库"><a href="#4-2-私有仓库" class="headerlink" title="4.2 私有仓库"></a>4.2 私有仓库</h4><p>docker hub 是公开的，其他人也是可以下载，并不安全，因此还可以使用docker registry官方提供的私有仓库</p><p>用法详解：</p><blockquote><p><a href="https://yeasy.gitbooks.io/docker_practice/repository/registry.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/repository/registry.html</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 1.下载一个docker官方私有仓库镜像</span><br><span class="line">    docker pull registry</span><br><span class="line"># 2.运行一个docker私有容器仓库</span><br><span class="line">docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry  registry</span><br><span class="line">    -d 后台运行 </span><br><span class="line">    -p  端口映射 宿主机的5000:容器内的5000</span><br><span class="line">    -v  数据卷挂载  宿主机的 /opt/data/registry :/var/lib/registry </span><br><span class="line">    registry  镜像名</span><br><span class="line">    /var/lib/registry  存放私有仓库位置</span><br><span class="line"># Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制</span><br><span class="line"># 3.修改docker的配置文件，让他支持http方式，上传私有镜像</span><br><span class="line">    vim /etc/docker/daemon.json </span><br><span class="line">    # 写入如下内容</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;registry-mirrors&quot;: [&quot;http://f1361db2.m.daocloud.io&quot;],</span><br><span class="line">        &quot;insecure-registries&quot;:[&quot;192.168.11.37:5000&quot;]</span><br><span class="line">    &#125;</span><br><span class="line"># 4.修改docker的服务配置文件</span><br><span class="line">    vim /lib/systemd/system/docker.service</span><br><span class="line"># 找到[service]这一代码区域块，写入如下参数</span><br><span class="line">    [Service]</span><br><span class="line">    EnvironmentFile=-/etc/docker/daemon.json</span><br><span class="line"># 5.重新加载docker服务</span><br><span class="line">    systemctl daemon-reload</span><br><span class="line"># 6.重启docker服务</span><br><span class="line">    systemctl restart docker</span><br><span class="line">    # 注意:重启docker服务，所有的容器都会挂掉</span><br><span class="line"></span><br><span class="line"># 7.修改本地镜像的tag标记，往自己的私有仓库推送</span><br><span class="line">    docker tag docker.io/peng104/hello-world-docker 192.168.11.37:5000/peng-hello</span><br><span class="line">    # 浏览器访问http://192.168.119.10:5000/v2/_catalog查看仓库</span><br><span class="line"># 8.下载私有仓库的镜像</span><br><span class="line">    docker pull 192.168.11.37:5000/peng-hello</span><br></pre></td></tr></table></figure><hr><h3 id="5、实例演示"><a href="#5、实例演示" class="headerlink" title="5、实例演示"></a>5、实例演示</h3><p>编写dockerfile，构建自己的镜像，运行flask程序。</p><p>确保app.py和dockerfile在同一个目录！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 1.准备好app.py的flask程序</span><br><span class="line">    [root@localhost ~]# cat app.py</span><br><span class="line">    from flask import Flask</span><br><span class="line">    app=Flask(__name__)</span><br><span class="line">    @app.route(&apos;/&apos;)</span><br><span class="line">    def hello():</span><br><span class="line">        return &quot;hello docker&quot;</span><br><span class="line">    if __name__==&quot;__main__&quot;:</span><br><span class="line">        app.run(host=&apos;0.0.0.0&apos;,port=8080)</span><br><span class="line">    [root@master home]# ls</span><br><span class="line">    app.py  Dockerfile</span><br><span class="line"></span><br><span class="line"># 2.编写dockerfile</span><br><span class="line">    [root@localhost ~]# cat Dockerfile</span><br><span class="line">    FROM python:2.7</span><br><span class="line">    LABEL maintainer=&quot;温而新&quot;</span><br><span class="line">    RUN pip install flask</span><br><span class="line">    COPY app.py /app/</span><br><span class="line">    WORKDIR /app</span><br><span class="line">    EXPOSE 8080</span><br><span class="line">    CMD [&quot;python&quot;,&quot;app.py&quot;]</span><br><span class="line"></span><br><span class="line"># 3.构建镜像image,找到当前目录的Dockerfile，开始构建</span><br><span class="line">    docker build -t peng104/flask-hello-docker .</span><br><span class="line"></span><br><span class="line"># 4.查看创建好的images</span><br><span class="line">    docker image ls</span><br><span class="line"></span><br><span class="line"># 5.启动此flask-hello-docker容器，映射一个端口供外部访问</span><br><span class="line">    docker run -d -p 8080:8080 peng104/flask-hello-docker</span><br><span class="line"></span><br><span class="line"># 6.检查运行的容器</span><br><span class="line">    docker container ls</span><br><span class="line"></span><br><span class="line"># 7.推送这个镜像到私有仓库</span><br><span class="line">    docker tag  peng104/flask-hello-docker   192.168.11.37:5000/peng-flaskweb</span><br><span class="line">    docker push 192.168.11.37:5000/peng-flaskweb</span><br></pre></td></tr></table></figure><h2 id="补充一些用法"><a href="#补充一些用法" class="headerlink" title="补充一些用法"></a>补充一些用法</h2><h3 id="挂载宿主机目录"><a href="#挂载宿主机目录" class="headerlink" title="挂载宿主机目录"></a>挂载宿主机目录</h3><p>docker可以支持把一个宿主机上的目录挂载到镜像里。</p><p><code>docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</code><br>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。</p><p>现在镜像内就可以共享宿主机里的文件了。</p><p>默认挂载的路径权限为读写。如果指定为只读可以用：ro<br><code>docker run -it -v /home/dock/Downloads:/usr/Downloads:ro ubuntu64 /bin/bash</code></p><p>docker还提供了一种高级的用法。叫数据卷。</p><p>数据卷：“其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的”。感觉像是由一个容器定义的一个数据挂载信息。其他的容器启动可以直接挂载数据卷容器中定义的挂载信息。</p><p>看示例：<br><code>docker run -v /home/dock/Downloads:/usr/Downloads --name dataVol ubuntu64 /bin/bash</code><br>创建一个普通的容器。用–name给他指定了一个名（不指定的话会生成一个随机的名子）。</p><p>再创建一个新的容器，来使用这个数据卷。<br><code>docker run -it --volumes-from dataVol ubuntu64 /bin/bash --volumes-from用来指定要从哪个数据卷来挂载数据。</code></p><p>生成的docker镜像保存下来：docker save -o test.tar test:1.0<br> 导入docker镜像：docker load -i test.tar</p><h3 id="Docker容器内外互相拷贝数据"><a href="#Docker容器内外互相拷贝数据" class="headerlink" title="Docker容器内外互相拷贝数据"></a>Docker容器内外互相拷贝数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">从容器内拷贝文件到主机上</span><br><span class="line">docker cp &lt;containerId&gt;:/file/path/within/container /host/path/target </span><br><span class="line"></span><br><span class="line">从主机上拷贝文件到容器内</span><br><span class="line">参考自：</span><br><span class="line">http://stackoverflow.com/questions/22907231/copying-files-from-host-to-docker-container</span><br><span class="line">1.用-v挂载主机数据卷到容器内</span><br><span class="line">docker run -v /path/to/hostdir:/mnt $container</span><br><span class="line">在容器内拷贝</span><br><span class="line">cp /mnt/sourcefile /path/to/destfile</span><br><span class="line">2.直接在主机上拷贝到容器物理存储系统</span><br><span class="line">A. 获取容器名称或者id :</span><br><span class="line">$ docker ps</span><br><span class="line">B. 获取整个容器的id</span><br><span class="line">$ docker inspect -f   &apos;&#123;&#123;.Id&#125;&#125;&apos;  步骤A获取的名称或者id</span><br><span class="line">C. 在主机上拷贝文件:</span><br><span class="line">$ sudo cp path-file-host /var/lib/docker/aufs/mnt/FULL_CONTAINER_ID/PATH-NEW-FILE </span><br><span class="line">或者</span><br><span class="line">$ sudo cp path-file-host /var/lib/docker/devicemapper/mnt/123abc&lt;&lt;id&gt;&gt;/rootfs/root</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID      IMAGE    COMMAND       CREATED      STATUS       PORTS        NAMES</span><br><span class="line">d8e703d7e303   solidleon/ssh:latest      /usr/sbin/sshd -D                      cranky_pare</span><br><span class="line"></span><br><span class="line">$ docker inspect -f   &apos;&#123;&#123;.Id&#125;&#125;&apos; cranky_pare</span><br><span class="line">or </span><br><span class="line">$ docker inspect -f   &apos;&#123;&#123;.Id&#125;&#125;&apos; d8e703d7e303</span><br><span class="line">d8e703d7e3039a6df6d01bd7fb58d1882e592a85059eb16c4b83cf91847f88e5</span><br><span class="line"></span><br><span class="line">$ sudo cp file.txt /var/lib/docker/aufs/mnt/**d8e703d7e3039a6df6d01bd7fb58d1882e592a85059eb16c4b83cf91847f88e5</span><br><span class="line"></span><br><span class="line">3.用输入输出符</span><br><span class="line">docker run -i ubuntu /bin/bash -c &apos;cat &gt; /path/to/container/file&apos; &lt; /path/to/host/file/</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">docker exec -it &lt;container_id&gt; bash -c &apos;cat &gt; /path/to/container/file&apos; &lt; /path/to/host/file/</span><br></pre></td></tr></table></figure><p><strong>总结一下</strong></p><blockquote><p>从主机复制到容器<code>sudo docker cp host_path containerID:container_path</code></p><p>从容器复制到主机<code>sudo docker cp containerID:container_path host_path</code></p><p>容器ID的查询方法想必大家都清楚:<code>docker ps -a</code></p></blockquote><h3 id="docker-运行容器时为容器起别名"><a href="#docker-运行容器时为容器起别名" class="headerlink" title="docker 运行容器时为容器起别名"></a>docker 运行容器时为容器起别名</h3><blockquote><p>docker run –name=mydemo -p  -d 2222:80 imagename</p><p>–name: 指定容器名称</p><p>-p:指定容器端口号</p><p>-d:指定容器后台运行</p></blockquote><h3 id="docker一些有用的清理命令"><a href="#docker一些有用的清理命令" class="headerlink" title="docker一些有用的清理命令"></a>docker一些有用的清理命令</h3><p>以下命令参考自这篇<a href="http://blog.loof.fr/2016/05/docker-cleanup.html#" target="_blank" rel="noopener">文章</a>：</p><p>（1）清除已经终止的<code>container</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v $(docker ps --filter status=exited -q)</span><br></pre></td></tr></table></figure><p>（2）清除已经没用的<code>volume</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm $(docker volume ls -q -f &apos;dangling=true&apos;)</span><br></pre></td></tr></table></figure><p>（3）清除已经没用的<code>image</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -f &quot;dangling=true&quot; -q)</span><br></pre></td></tr></table></figure><p>（4）清除所有的<code>container</code>（包括正在运行的和已经退出的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -a | awk &apos;NR &gt; 1 &#123;print $1&#125;&apos;)</span><br></pre></td></tr></table></figure><h3 id="在docker-container中执行命令的脚本"><a href="#在docker-container中执行命令的脚本" class="headerlink" title="在docker container中执行命令的脚本"></a>在docker container中执行命令的脚本</h3><p>下面脚本的功能是循环地在各个<code>container</code>中执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash -x</span><br><span class="line"></span><br><span class="line">for i in &#123;1..2&#125;</span><br><span class="line">do</span><br><span class="line">        docker exec -i hammerdb_net$&#123;i&#125; bash &lt;&lt;-EOF</span><br><span class="line">        su oracle</span><br><span class="line">        source /tmp/ora_env</span><br><span class="line">        cd /data/oracle/tablespaces/</span><br><span class="line">        rm -f *.html</span><br><span class="line">        ./create_awr.sh</span><br><span class="line">        mv awr.html awr_$&#123;i&#125;.html</span><br><span class="line">        EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>需要注意的是在<code>do</code>和<code>done</code>之间应该使用<code>tab</code>而不是空格。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;查看docker运行信息&quot;&gt;&lt;a href=&quot;#查看docker运行信息&quot; class=&quot;headerlink&quot; title=&quot;查看docker运行信息&quot;&gt;&lt;/a&gt;查看docker运行信息&lt;/h2&gt;&lt;p&gt;docker inspect 会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker inspect NAMES &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看容器所有状态信息；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker inspect --format=&amp;apos;&amp;#123;&amp;#123;.NetworkSettings.IPAddress&amp;#125;&amp;#125;&amp;apos; ID/NAMES&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看 容器ip 地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker inspect --format &amp;apos;&amp;#123;&amp;#123;.Name&amp;#125;&amp;#125; &amp;#123;&amp;#123;.State.Running&amp;#125;&amp;#125;&amp;apos; NAMES&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 容器运行状态&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="持续集成" scheme="http://geoffen.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="docker" scheme="http://geoffen.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo静态页面图片无法显示的解决方案</title>
    <link href="http://geoffen.github.io/2019/10/05/Hexo%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://geoffen.github.io/2019/10/05/Hexo静态页面图片无法显示的解决方案/</id>
    <published>2019-10-05T01:17:52.000Z</published>
    <updated>2019-11-07T10:24:47.347Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image</p><blockquote><p>npm install hexo-asset-image –save</p></blockquote><p>打开_config.yml文件，修改下述内容</p><blockquote><p>post_asset_folder: true</p></blockquote><p><strong>注：如以下方法不能解决图片显示问题</strong></p><p>请按下以修改文件：</p><a id="more"></a><p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var cheerio = require(&apos;cheerio&apos;);</span><br><span class="line"></span><br><span class="line">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) &#123;</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.filter.register(&apos;after_post_render&apos;, function(data)&#123;</span><br><span class="line">  var config = hexo.config;</span><br><span class="line">  if(config.post_asset_folder)&#123;</span><br><span class="line">    var link = data.permalink;</span><br><span class="line">    var beginPos = getPosition(link, &apos;/&apos;, 3) + 1;</span><br><span class="line">    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br><span class="line">    var endPos = link.lastIndexOf(&apos;/&apos;) + 1;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;];</span><br><span class="line">    for(var i = 0; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      var key = toprocess[i];</span><br><span class="line"></span><br><span class="line">      var $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(&apos;img&apos;).each(function()&#123;</span><br><span class="line">        if ($(this).attr(&apos;src&apos;))&#123;</span><br><span class="line">            // For windows style path, we replace &apos;\&apos; to &apos;/&apos;.</span><br><span class="line">            var src = $(this).attr(&apos;src&apos;).replace(&apos;\\&apos;, &apos;/&apos;);</span><br><span class="line">            if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;</span><br><span class="line">               !/^\s*\//.test(src)) &#123;</span><br><span class="line">              // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed.</span><br><span class="line">              // In addition, to support multi-level local directory.</span><br><span class="line">              var linkArray = link.split(&apos;/&apos;).filter(function(elem)&#123;</span><br><span class="line">                return elem != &apos;&apos;;</span><br><span class="line">              &#125;);</span><br><span class="line">              var srcArray = src.split(&apos;/&apos;).filter(function(elem)&#123;</span><br><span class="line">                return elem != &apos;&apos; &amp;&amp; elem != &apos;.&apos;;</span><br><span class="line">              &#125;);</span><br><span class="line">              if(srcArray.length &gt; 1)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(&apos;/&apos;);</span><br><span class="line">              $(this).attr(&apos;src&apos;, config.root + link + src);</span><br><span class="line">              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);</span><br><span class="line">            console.info&amp;&amp;console.info($(this));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;npm install hexo-asset-image –save&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;打开_config.yml文件，修改下述内容&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;post_asset_folder: true&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;注：如以下方法不能解决图片显示问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;请按下以修改文件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://geoffen.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://geoffen.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>最简便的方法基于Next主题搭建Hexo+Github博客</title>
    <link href="http://geoffen.github.io/2019/10/01/%E6%9C%80%E7%AE%80%E4%BE%BF%E7%9A%84%E6%96%B9%E6%B3%95%E5%9F%BA%E4%BA%8ENext%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BAHexo+Github%E5%8D%9A%E5%AE%A2/"/>
    <id>http://geoffen.github.io/2019/10/01/最简便的方法基于Next主题搭建Hexo+Github博客/</id>
    <published>2019-10-01T13:45:53.000Z</published>
    <updated>2019-11-07T10:24:47.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo，反正我第一眼看到就喜欢上了它的简约，<a href="http://geoffen.github.io/">感受一下吧</a>。<br>如果你喜欢写作，我觉得你可以试试gitbook或者跟着本文搭建一个属于自己的博客空间（即使你不是IT行业的一员），不再受限于第三方博客地址，当然Hexo搭建的博客也是基于github托管的，但是并不需要你购买域名。<br>经过两天的探索加爬坑，终于把博客在git上安家了，感谢开源的大哥大姐们，由于并非js开发，所以遇到了很多坑，于是也想整理一篇比较完整的博客。</p><p>ps:我选择的主题是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next</a></p><a id="more"></a><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p><a href="https://nodejs.org/download/" target="_blank" rel="noopener">下载Node.js</a><br>参考地址：<a href="http://www.w3cschool.cc/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">安装Node.js</a></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>下载地址：<a href="http://git-scm.com/download/" target="_blank" rel="noopener">http://git-scm.com/download/</a></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd d:/hexo</span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ cd blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo g # 或者hexo generate</span><br><span class="line">$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看</span><br></pre></td></tr></table></figure><p>这里有必要提下Hexo常用的几个命令：</p><ol><li>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</li><li>hexo server (hexo s) 启动本地web服务，用于博客的预览</li><li>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）</li></ol><p>另外还有其他几个常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;postName&quot; #新建文章</span><br><span class="line">$ hexo new page &quot;pageName&quot; #新建页面</span><br></pre></td></tr></table></figure><p>常用简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n == hexo new</span><br><span class="line">$ hexo g == hexo generate</span><br><span class="line">$ hexo s == hexo server</span><br><span class="line">$ hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>常用组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g #生成部署</span><br><span class="line">$ hexo s -g #生成预览</span><br></pre></td></tr></table></figure><p>现在我们打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 已经可以看到一篇内置的blog了。</p><h3 id="Hexo主题设置"><a href="#Hexo主题设置" class="headerlink" title="Hexo主题设置"></a>Hexo主题设置</h3><p>这里以主题yilia为例进行说明。</p><h4 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><h4 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h4><p>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia。</p><h4 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd themes/yilia</span><br><span class="line">$ git pull</span><br><span class="line">$ hexo g # 生成</span><br><span class="line">$ hexo s # 启动本地web服务器</span><br></pre></td></tr></table></figure><p>现在打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，会看到我们已经应用了一个新的主题。</p><h3 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h3><h4 id="使用hexo-deploy部署"><a href="#使用hexo-deploy部署" class="headerlink" title="使用hexo deploy部署"></a>使用hexo deploy部署</h4><p>hexo deploy可以部署到很多平台，具体可以<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">参考这个链接</a>. 如果部署到github，需要在配置文件_config.xml中作如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:geoffen/geoffen.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>然后在命令行中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>即可完成部署。</p><p>注意需要提前安装一个扩展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="使用git命令行部署"><a href="#使用git命令行部署" class="headerlink" title="使用git命令行部署"></a>使用git命令行部署</h3><p>不幸的是，上述命令虽然简单方便，但是偶尔会有莫名其妙的问题出现，因此，我们也可以追本溯源，使用git命令来完成部署的工作。</p><h4 id="clone-github-repo"><a href="#clone-github-repo" class="headerlink" title="clone github repo"></a>clone github repo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd d:/hexo/blog</span><br><span class="line"></span><br><span class="line">$ git clone https://github.com/geoffen/geoffen.github.io.git .deploy/geoffen.github.io</span><br></pre></td></tr></table></figure><p>将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。</p><h4 id="创建一个deploy脚本文件"><a href="#创建一个deploy脚本文件" class="headerlink" title="创建一个deploy脚本文件"></a>创建一个deploy脚本文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">cp -R public/* .deploy/geoffen.github.io</span><br><span class="line">cd .deploy/geoffen.github.io</span><br><span class="line">git add .</span><br><span class="line">git commit -m “update”</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至geoffen.github.io的git目录下，然后使用git commit命令提交代码到geoffen.github.io这个repo的master branch上。</p><p>需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。</p><h3 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h3><p>添加sitemap和feed插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed</span><br><span class="line">$ npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure><p>修改_config.yml，增加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">Plugins:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"></span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line"></span><br><span class="line">#sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br></pre></td></tr></table></figure><p>配完之后，就可以访问<code>http://geoffen.github.io/atom.xml</code>和<code>http://geoffen.github.io/sitemap.xml</code>，发现这两个文件已经成功生成了。</p><h3 id="添加404公益"><a href="#添加404公益" class="headerlink" title="添加404公益"></a>添加404公益</h3><p>GitHub Pages有提供制作404页面的指引：<a href="https://help.github.com/articles/custom-404-pages" target="_blank" rel="noopener">Custom 404 Pages</a>。</p><p>直接在根目录下创建自己的404.html或者404.md就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。</p><p>推荐使用<a href="http://www.qq.com/404/" target="_blank" rel="noopener">腾讯公益404</a>。</p><h3 id="添加about页面"><a href="#添加about页面" class="headerlink" title="添加about页面"></a>添加about页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure><p>之后在sourceaboutindex.md目录下会生成一个index.md文件，打开输入个人信息即可，如果想要添加版权信息，可以在文件末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;font-size:12px;border-bottom: #ddd 1px solid; BORDER-LEFT: #ddd 1px solid; BACKGROUND: #f6f6f6; HEIGHT: 120px; BORDER-TOP: #ddd 1px solid; BORDER-RIGHT: #ddd 1px solid&quot;&gt;</span><br><span class="line">&lt;div style=&quot;MARGIN-TOP: 10px; FLOAT: left; MARGIN-LEFT: 5px; MARGIN-RIGHT: 10px&quot;&gt;</span><br><span class="line">&lt;IMG alt=&quot;&quot; src=&quot;https://avatars1.githubusercontent.com/u/168751?v=3&amp;s=140&quot; width=90 height=100&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;LINE-HEIGHT: 200%; MARGIN-TOP: 10px; COLOR: #000000&quot;&gt;</span><br><span class="line">本文链接：&lt;a href=&quot;&lt;%= post.link %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt; &lt;br/&gt;</span><br><span class="line">作者： </span><br><span class="line">&lt;a href=&quot;http://geoffen.github.io/&quot;&gt;令狐葱&lt;/a&gt; &lt;br/&gt;出处： </span><br><span class="line">&lt;a href=&quot;http://geoffen.github.io/&quot;&gt;http://geoffen.github.io/&lt;/a&gt;</span><br><span class="line">&lt;br/&gt;本文基于&lt;a target=&quot;_blank&quot; title=&quot;Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)&quot; href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt; 知识共享署名-相同方式共享 4.0 &lt;/a&gt;</span><br><span class="line">国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名 </span><br><span class="line">&lt;a href=&quot;http://geoffen.github.io/&quot;&gt;令狐葱&lt;/a&gt;及链接。</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="添加Fork-me-on-Github"><a href="#添加Fork-me-on-Github" class="headerlink" title="添加Fork me on Github"></a>添加Fork me on Github</h3><p><a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">获取代码</a>，选择你喜欢的代码添加到hexo/themes/yilia/layout/layout.ejs的末尾即可，注意要将代码里的you改成你的Github账号名。</p><h3 id="添加支付宝捐赠按钮及二维码支付"><a href="#添加支付宝捐赠按钮及二维码支付" class="headerlink" title="添加支付宝捐赠按钮及二维码支付"></a>添加支付宝捐赠按钮及二维码支付</h3><p>支付宝捐赠按钮在D:/hexo/themes/yilia/layout_widget目录下新建一个zhifubao.ejs文件，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;asidetitle&quot;&gt;打赏他&lt;/p&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;form action=&quot;https://shenghuo.alipay.com/send/payment/fill.htm&quot; method=&quot;POST&quot; target=&quot;_blank&quot; accept-charset=&quot;GBK&quot;&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;input name=&quot;optEmail&quot; type=&quot;hidden&quot; value=&quot;your 支付宝账号&quot; /&gt;</span><br><span class="line">    &lt;input name=&quot;payAmount&quot; type=&quot;hidden&quot; value=&quot;默认捐赠金额(元)&quot; /&gt;</span><br><span class="line">    &lt;input id=&quot;title&quot; name=&quot;title&quot; type=&quot;hidden&quot; value=&quot;博主，打赏你的！&quot; /&gt;</span><br><span class="line">    &lt;input name=&quot;memo&quot; type=&quot;hidden&quot; value=&quot;你Y加油，继续写博客！&quot; /&gt;</span><br><span class="line">    &lt;input name=&quot;pay&quot; type=&quot;image&quot; value=&quot;转账&quot; src=&quot;http://7xig3q.com1.z0.glb.clouddn.com/alipay-donate-website.png&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>添加完该文件之后，要在D:/hexo/themes/yilia/_config.yml文件中启用，如下所示，添加zhifubao</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">widgets:</span><br><span class="line">- category</span><br><span class="line">- tag</span><br><span class="line">- links</span><br><span class="line">- tagcloud</span><br><span class="line">- zhifubao</span><br><span class="line">- rss</span><br></pre></td></tr></table></figure><p>或者</p><p>很简单，打开主题配置文件_config.yml<br>添加字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">alipay: http://ww3.sinaimg.cn/small/937882b5jw1f4dalzfc5nj20p00vu0um.jpg</span><br></pre></td></tr></table></figure><p><code>alipay:</code> 填写的是支付宝或者微信的收款二维码图片地址。</p><h2 id="生成部署三部曲"><a href="#生成部署三部曲" class="headerlink" title="生成部署三部曲"></a>生成部署三部曲</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #清空缓存</span><br><span class="line">hexo g #生成静态网页</span><br><span class="line">hexo d #部署到github</span><br></pre></td></tr></table></figure><h2 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a>主题优化</h2><p><a href="http://chaserr.github.io/" target="_blank" rel="noopener">样式预览</a></p><h3 id="Next主题的安装使用"><a href="#Next主题的安装使用" class="headerlink" title="Next主题的安装使用"></a>Next主题的安装使用</h3><p>首先从github上clone到本地，在终端cd / 切换到你通过Hexo init生成的根目录，<br>然后在终端输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>进入站点的全局配置文件：_config.yml<br>找到theme字段：设置为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>到这里可以验证一下主题是否被启用。终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -- debug</span><br></pre></td></tr></table></figure><p>然后本地访问<a href="http://localhost:4000%EF%BC%8C%E7%9C%8B%E7%9C%8B%E6%95%88%E6%9E%9C%EF%BC%8C%E5%9C%A8%E6%B2%A1%E6%9C%89%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A%E4%B9%8B%E5%89%8D%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%9C%A8%E6%9C%AC%E5%9C%B0%E8%BF%9B%E8%A1%8C%E9%A2%84%E8%A7%88%E3%80%82/" target="_blank" rel="noopener">http://localhost:4000，看看效果，在没有部署到github上之前，一般都可以这样在本地进行预览。</a></p><p>关于站点全局_config.yml配置文件的其他一些参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 朝夕 #博客名</span><br><span class="line">subtitle: 朝闻道，夕死可以。 #博客副标题</span><br><span class="line">description: #给搜索引擎看的，对站点的描述，可以自定义</span><br><span class="line">author: 童星 #作者名称，显示在网站最底部</span><br><span class="line">language: zh-Hans #语言选择，这里表示中文</span><br><span class="line">email: #你的联系邮箱</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: chaserr.github.io  #可以填写你的站点域名</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing , 设置生成博文的默认格式</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post #默认布局</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0 #把文件名称转换为（1）小写或者大写</span><br><span class="line">render_drafts: #显示草稿</span><br><span class="line">post_asset_folder: false  #启动Asset文件夹</span><br><span class="line">relative_link: false #把链接改为与根目录相对位置</span><br><span class="line">future: true #显示未来的文章</span><br><span class="line">highlight: #代码块的设置</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure><p>默认的大致就这些，另外给主题添加相关功能的时候后面会慢慢加上其他一些参数。</p><h4 id="给站点添加rss和sitemap功能"><a href="#给站点添加rss和sitemap功能" class="headerlink" title="给站点添加rss和sitemap功能"></a>给站点添加rss和sitemap功能</h4><p>打开终端，切换到站点根目录，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed</span><br><span class="line">$ npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure><p>在全局配置文件_config.yml进行插件配置：（为防止好找，在最下面进行配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#插件配置</span><br><span class="line">plugins: hexo-generator-feed </span><br><span class="line">#- hexo-generator-sitemap </span><br><span class="line"></span><br><span class="line">feed:</span><br><span class="line">  type: atom ##feed类型 atom或者rss2</span><br><span class="line">  path: atom.xml ##feed路径</span><br><span class="line">  limit: 20  ##feed文章最小数量</span><br></pre></td></tr></table></figure><h4 id="给站点添加本地搜索功能"><a href="#给站点添加本地搜索功能" class="headerlink" title="给站点添加本地搜索功能"></a>给站点添加本地搜索功能</h4><ul><li>使用swiftype添加站内搜索</li></ul><p>去swiftype官网注册一个账号，按照步骤选择自己喜欢的搜索样式，配置完成后，选择install，然后会出现<a href="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160531_10.png" target="_blank" rel="noopener"><img src="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160531_10.png" alt="Snip20160531_10"></a><br>如图所示，我不知道为什么，这个代码框无法滚动，所以我们必须将它全部复制出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  (function(w,d,t,u,n,s,e)&#123;w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function()&#123;</span><br><span class="line">  (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t);</span><br><span class="line">  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);</span><br><span class="line">  &#125;)(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;);</span><br><span class="line">  </span><br><span class="line">  _st(&apos;install&apos;,&apos;7Qoo1zkKbfSsp5bzUjQu&apos;,&apos;2.0.0&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后复制install —-2.0.0之间的一段代码，添加到全局配置文件里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 搜索插件 hexo-generator-sitemap</span><br><span class="line">swiftype_key: 7Qoo1zkKbfSsp5bzUjQu</span><br></pre></td></tr></table></figure><ul><li>添加本地搜索</li></ul><p>直接在全局配置文件添加参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br></pre></td></tr></table></figure><p>search.xml这些都是默认带有的</p><h4 id="给站点添加友情链接功能"><a href="#给站点添加友情链接功能" class="headerlink" title="给站点添加友情链接功能"></a>给站点添加友情链接功能</h4><p>直接在全局配置文件添加参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">links_title: 友情链接</span><br><span class="line">links:</span><br><span class="line">#百度: http://www.baidu.com/</span><br><span class="line">#新浪: http://example.com/</span><br></pre></td></tr></table></figure><p>其实也可以新建一个文件专门放置这些需要链接的网站，这样方便管理，不必每次都对全局配置文件进行更改</p><blockquote><p>如果没有链接，那么友情链接不会显示，为了测试，可以随便写一个</p></blockquote><h4 id="给站点添加多说评论、热评、分享功能"><a href="#给站点添加多说评论、热评、分享功能" class="headerlink" title="给站点添加多说评论、热评、分享功能"></a>给站点添加多说评论、热评、分享功能</h4><p>直接在全局配置文件添加参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Disqus  disqus评论,  与多说类似, 国内一般使用多说</span><br><span class="line">#disqus_shortname: </span><br><span class="line">duoshuo_shortname: chaser</span><br><span class="line"></span><br><span class="line"># 多说热评文章 true 或者 false</span><br><span class="line">duoshuo_hotartical: true</span><br><span class="line"></span><br><span class="line"># 多说分享服务</span><br><span class="line">duoshuo_share: true</span><br><span class="line">duoshuo_info:</span><br><span class="line">  ua_enable: true</span><br><span class="line">  admin_enable: false</span><br><span class="line">  user_id:</span><br><span class="line">  admin_nickname:</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>这里的<code>duoshuo_shortname</code>是需要你去多说主页 – <a href="http://duoshuo.com/" target="_blank" rel="noopener">传送门</a> 注册一个账号，然后填写你的多说域名，这里填写的就是你在多说填写的域名<br>例如：我的是：<code>http://chaser.duoshuo.com/</code>，那么我填写的就是<code>chaser</code></p><ul><li>这里配置的是所有页面都支持评论，但是后面有的页面不需要，比如标签页，分类页，关于等等，那么就单独设置。</li></ul></blockquote><h3 id="Next主题的优化"><a href="#Next主题的优化" class="headerlink" title="Next主题的优化"></a>Next主题的优化</h3><p>这之前，先对主题配置文件进行一些配置，打开博客根目录/themes/next，这个路径，然后打开，主题配置文件_config.yml：</p><h4 id="配置个人头像"><a href="#配置个人头像" class="headerlink" title="配置个人头像"></a>配置个人头像</h4><p>在主题配置文件里找到avatar字段，(如果没有就添加)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.jpg</span><br><span class="line"># in site  directory(source/uploads): /uploads/avatar.jpg</span><br><span class="line">avatar: http://ww4.sinaimg.cn/small/937882b5jw1f4db4lroy9j20hs0npmy6.jpg</span><br></pre></td></tr></table></figure><blockquote><p>我采用的是地址，并没有将图片放在本地（采用新浪博客相册）</p></blockquote><h4 id="Next主题选择"><a href="#Next主题选择" class="headerlink" title="Next主题选择"></a>Next主题选择</h4><p>在主题配置文件_config.yml里，找到scheme字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure><ul><li><p>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</p></li><li><p>Mist - Muse 的紧凑版本，整洁有序的单栏外观</p></li><li><p>Pisces - 双栏 Scheme，小家碧玉似的清新</p><p>我选择的是第三种，去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure><p>，然后把第一个前面加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure><blockquote><p>每进行一步都可以自己去进行预览：</p><p>hexo s –debug</p></blockquote></li></ul><h4 id="Next主题菜单配置"><a href="#Next主题菜单配置" class="headerlink" title="Next主题菜单配置"></a>Next主题菜单配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)</span><br><span class="line">menu:</span><br><span class="line">  home: / #主页</span><br><span class="line">  categories: /categories #分类页面</span><br><span class="line">  about: /about #关于</span><br><span class="line">  archives: /archives #归档</span><br><span class="line">  tags: /tags #标签</span><br><span class="line">  commonweal: /404.html  #公益404</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line"># Icon Mapping:</span><br><span class="line">#   Map a menu item to a specific FontAwesome icon name.</span><br><span class="line">#   Key is the name of menu item and value is the name of FontAwsome icon. Key is case-senstive.</span><br><span class="line">#   When an question mask icon presenting up means that the item has no mapping icon.</span><br><span class="line">menu_icons:</span><br><span class="line">  enable: true #是否显示图标</span><br><span class="line">  #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br></pre></td></tr></table></figure><blockquote><ol><li>如果需要添加你自己自定义的菜单，那么就只需要在menu下添加相关的菜单项，然后新建页面与之匹配，然后去next主题目录的<code>languages</code>目录下找到我们之前配置的主题所使用的语言，（我们用的是<code>zh-Hans</code>）对其进行国际化。</li><li>menu_icon的设置采用<code>key-value</code>。key对应上面的menu里面的菜单项，大小写一致，value就是对应<a href="http://www.bootcss.com/p/font-awesome/#icons-web-app" target="_blank" rel="noopener">FontAwsome icon</a>这个网站的图标的名字，去掉前缀icon</li></ol><p>关于这里的所有的图标都支持从<code>FontAwsome icon</code>这个网站获取，当然也可以自己放在资源文件夹里（一般比如个人头像(<code>avatar</code>)，网站图标(<code>favicon</code>)等)。<br>当然也支持从网址获取，推荐使用<code>七牛</code>云存储。当然也可以使用新浪博客的相册，谷歌相册，甚至QQ空间，都可以，只要能获取到图片网址，并且你不会轻易删掉。</p></blockquote><h5 id="添加关于，标签，分类，公益404页面"><a href="#添加关于，标签，分类，公益404页面" class="headerlink" title="添加关于，标签，分类，公益404页面"></a>添加关于，标签，分类，公益404页面</h5><p>菜单配置好了，但是我们还得新建一些页面与之相匹配，否则点击进去找不到。这里说一下，对于<code>标签页</code>和<code>分类页</code>，我们需要在新建一篇文章的时候指定它的标签和分类。对于刚开始建立的博客，点进去可能是空的，所以等会新建一篇文章试试，这之前，先建立相关页面。</p><h6 id="添加标签页"><a href="#添加标签页" class="headerlink" title="添加标签页"></a>添加标签页</h6><p>打开终端，进入博客根站点，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>进入博客根目录/source路径，找到tags文件夹，可以看到生成了index.md文件。可以使用编辑器打开<br>在里面添加<code>tags</code>和<code>comments</code><br><a href="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_11.png" target="_blank" rel="noopener"><img src="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_11.png" alt="Snip20160531_11"></a></p><blockquote><ol><li><code>tags</code>设置页面的类型</li><li><code>comments</code>用来控制是否显示评论。</li></ol></blockquote><h6 id="添加分类页"><a href="#添加分类页" class="headerlink" title="添加分类页"></a>添加分类页</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>进入博客根目录/source路径，找到categories文件夹，可以看到生成了index.md文件。可以使用编辑器打开<br>在里面添加<code>tags</code>和<code>comments</code><br><a href="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_11.png" target="_blank" rel="noopener"><img src="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_11.png" alt="Snip20160531_11"></a></p><blockquote><ol><li><code>tags</code>设置页面的类型</li><li><code>comments</code>用来控制是否显示评论。</li></ol></blockquote><h6 id="添加关于页"><a href="#添加关于页" class="headerlink" title="添加关于页"></a>添加关于页</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><p>进入博客根目录/source路径，找到categories文件夹，可以看到生成了index.md文件。可以使用编辑器打开<br>在里面添加<code>tags</code>和<code>comments</code><br><a href="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_11.png" target="_blank" rel="noopener"><img src="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_11.png" alt="Snip20160531_11"></a></p><blockquote><ol><li><code>tags</code>设置页面的类型</li><li><code>comments</code>用来控制是否显示评论。</li></ol></blockquote><p>about这个页面一般都是填写一些你的个人信息，要不要无所谓，我这里给about页面添加了一个背景音乐盒.去网易云音乐，创建一个自己的歌单，然后分享，然后找到自己分享的动态，点击链接，<a href="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_12.png" target="_blank" rel="noopener"><img src="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_12.png" alt="Snip20160531_12"></a><br>出现如图的页面，然后点击生成’’外链播放器’’字样。将出现的代码复制，粘贴到你的about页面<br><a href="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_13.png" target="_blank" rel="noopener"><img src="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_13.png" alt="Snip20160531_13"></a></p><p>新建一篇文章给它添加分类和标签试试吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;Hexo教程&quot;</span><br></pre></td></tr></table></figure><p>通过mou编辑器打开：添加<code>tags</code>和<code>categories</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: title #文章標題</span><br><span class="line">date: 2016-06-01 23:47:44 #文章生成時間</span><br><span class="line">categories: &quot;Hexo教程&quot; #文章分類目錄 可以省略</span><br><span class="line">tags: #文章標籤 可以省略</span><br><span class="line"> - 标签1</span><br><span class="line"> - 标签2</span><br><span class="line"> description: #你對本頁的描述 可以省略</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h6 id="添加公益404页面"><a href="#添加公益404页面" class="headerlink" title="添加公益404页面"></a>添加公益404页面</h6><p>直接在根目录的source路径下，新建一个404.html文件，就可以了<br>附：404.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot;</span><br><span class="line">        charset=&quot;utf-8&quot; homePageUrl=&quot;your site url &quot;</span><br><span class="line">        homePageName=&quot;回到我的主页&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>提示：<code>homePageUrl</code>记得修改成你的博客域名</p></blockquote><h3 id="Next主题侧边栏社交链接"><a href="#Next主题侧边栏社交链接" class="headerlink" title="Next主题侧边栏社交链接"></a>Next主题侧边栏社交链接</h3><p>打开主题配置文件_config.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Sidebar Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Social Links</span><br><span class="line">social:</span><br><span class="line">GitHub: https://github.com/chaserr</span><br><span class="line">新浪微博: http://weibo.com/lovaxiang</span><br><span class="line">FaceBook: https://www.facebook.com/x.tongxing</span><br><span class="line">GooglePlus : https://plus.google.com/u/0/117848542581702766384</span><br><span class="line">豆瓣: https://www.douban.com/people/lovax/</span><br><span class="line"></span><br><span class="line"># Social Links Icons</span><br><span class="line">social_icons:</span><br><span class="line"> enable: true #控制是否显示图标</span><br><span class="line">  # Icon Mappings.</span><br><span class="line">  # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome</span><br><span class="line">  GitHub: github</span><br><span class="line">  新浪微博: weibo</span><br><span class="line">  FaceBook: facebook</span><br><span class="line">  GooglePlus: google-plus</span><br><span class="line">  豆瓣: globe  #douban</span><br></pre></td></tr></table></figure><blockquote><p>这里的配置和Menu里一样，</p><ol><li><code>social</code>后面跟着的是你的社交网站的主页地址</li><li><code>social_icons</code>是FontAwesome网站的图标名称</li></ol><p>不过豆瓣icon好像是没有的，我在github上issue过，他们给我的解决方案就是去官网找到图标，放到本地资源、。、<br>所以亲们也不用去issue了。直接用别的代替吧，如果真想显示你的豆瓣的话。</p></blockquote><h3 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h3><p>很简单，打开主题配置文件_config.yml<br>添加字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">alipay: http://ww3.sinaimg.cn/small/937882b5jw1f4dalzfc5nj20p00vu0um.jpg</span><br></pre></td></tr></table></figure><blockquote><p><code>alipay:</code> 填写的是支付宝或者微信的收款二维码图片地址。</p></blockquote><h3 id="给文章添加阅读量"><a href="#给文章添加阅读量" class="headerlink" title="给文章添加阅读量"></a>给文章添加阅读量</h3><h4 id="配置LeanCloud"><a href="#配置LeanCloud" class="headerlink" title="配置LeanCloud"></a>配置LeanCloud</h4><p>打开<a href="https://leancloud.cn/login.html#/signin" target="_blank" rel="noopener">LeanCloud</a>官网，注册一个账号，完成激活<br><a href="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_14.png" target="_blank" rel="noopener"><img src="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_14.png" alt="Snip20160531_14"></a><br>点击创建新应用之后，进入新创建的应用<br><a href="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_15.png" target="_blank" rel="noopener"><img src="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_15.png" alt="Snip20160531_15"></a><br>点击创建Class，类名叫做<code>Counter</code>。</p><h4 id="修改主题配置文件-config-yml"><a href="#修改主题配置文件-config-yml" class="headerlink" title="修改主题配置文件_config.yml"></a>修改主题配置文件_config.yml</h4><p>打开主题配置文件，找到<code>leancloud_visitors</code>字段或者创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: ytnok33cvEchgidigtb0WumC-gzGzoHsz #&lt;AppID&gt;</span><br><span class="line">  app_key: SrcG8cy1VhONurWBoEBGGHML #&lt;AppKEY&gt;</span><br></pre></td></tr></table></figure><blockquote><ol><li><code>app_id</code></li><li><code>app_key</code><br><a href="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_18.png" target="_blank" rel="noopener"><img src="http://7xuupy.com1.z0.glb.clouddn.com/Snip20160601_18.png" alt="Snip20160531_18"></a></li></ol><p>将对应key的value复制填写即可。</p></blockquote><h4 id="添加lean-analytics-swing"><a href="#添加lean-analytics-swing" class="headerlink" title="添加lean-analytics.swing"></a>添加lean-analytics.swing</h4><p>在主题目录下的\layout_scripts路径下，新建名为：<code>lean-analytics.swing</code>的文件，<br>这里贴上<code>lean-analytics.swing</code>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.leancloud_visitors.enable %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;# custom analytics part create by xiamo #&#125;</span><br><span class="line">  &lt;script src=&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;AV.initialize(&quot;&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;&quot;, &quot;&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;&quot;);&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    function showTime(Counter) &#123;</span><br><span class="line">      var query = new AV.Query(Counter);</span><br><span class="line">      var entries = [];</span><br><span class="line">      var $visitors = $(&quot;.leancloud_visitors&quot;);</span><br><span class="line"></span><br><span class="line">      $visitors.each(function () &#123;</span><br><span class="line">        entries.push( $(this).attr(&quot;id&quot;).trim() );</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      query.containedIn(&apos;url&apos;, entries);</span><br><span class="line">      query.find()</span><br><span class="line">        .done(function (results) &#123;</span><br><span class="line">          var COUNT_CONTAINER_REF = &apos;.leancloud-visitors-count&apos;;</span><br><span class="line"></span><br><span class="line">          if (results.length === 0) &#123;</span><br><span class="line">            $visitors.find(COUNT_CONTAINER_REF).text(0);</span><br><span class="line">            return;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          for (var i = 0; i &lt; results.length; i++) &#123;</span><br><span class="line">            var item = results[i];</span><br><span class="line">            var url = item.get(&apos;url&apos;);</span><br><span class="line">            var time = item.get(&apos;time&apos;);</span><br><span class="line">            var element = document.getElementById(url);</span><br><span class="line"></span><br><span class="line">            $(element).find(COUNT_CONTAINER_REF).text(time);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .fail(function (object, error) &#123;</span><br><span class="line">          console.log(&quot;Error: &quot; + error.code + &quot; &quot; + error.message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addCount(Counter) &#123;</span><br><span class="line">      var $visitors = $(&quot;.leancloud_visitors&quot;);</span><br><span class="line">      var url = $visitors.attr(&apos;id&apos;).trim();</span><br><span class="line">      var title = $visitors.attr(&apos;data-flag-title&apos;).trim();</span><br><span class="line">      var query = new AV.Query(Counter);</span><br><span class="line"></span><br><span class="line">      query.equalTo(&quot;url&quot;, url);</span><br><span class="line">      query.find(&#123;</span><br><span class="line">        success: function(results) &#123;</span><br><span class="line">          if (results.length &gt; 0) &#123;</span><br><span class="line">            var counter = results[0];</span><br><span class="line">            counter.fetchWhenSave(true);</span><br><span class="line">            counter.increment(&quot;time&quot;);</span><br><span class="line">            counter.save(null, &#123;</span><br><span class="line">              success: function(counter) &#123;</span><br><span class="line">                var $element = $(document.getElementById(url));</span><br><span class="line">                $element.find(&apos;.leancloud-visitors-count&apos;).text(counter.get(&apos;time&apos;));</span><br><span class="line">              &#125;,</span><br><span class="line">              error: function(counter, error) &#123;</span><br><span class="line">                console.log(&apos;Failed to save Visitor num, with error message: &apos; + error.message);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            var newcounter = new Counter();</span><br><span class="line">            /* Set ACL */</span><br><span class="line">            var acl = new AV.ACL();</span><br><span class="line">            acl.setPublicReadAccess(true);</span><br><span class="line">            acl.setPublicWriteAccess(true);</span><br><span class="line">            newcounter.setACL(acl);</span><br><span class="line">            /* End Set ACL */</span><br><span class="line">            newcounter.set(&quot;title&quot;, title);</span><br><span class="line">            newcounter.set(&quot;url&quot;, url);</span><br><span class="line">            newcounter.set(&quot;time&quot;, 1);</span><br><span class="line">            newcounter.save(null, &#123;</span><br><span class="line">              success: function(newcounter) &#123;</span><br><span class="line">                var $element = $(document.getElementById(url));</span><br><span class="line">                $element.find(&apos;.leancloud-visitors-count&apos;).text(newcounter.get(&apos;time&apos;));</span><br><span class="line">              &#125;,</span><br><span class="line">              error: function(newcounter, error) &#123;</span><br><span class="line">                console.log(&apos;Failed to create&apos;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function(error) &#123;</span><br><span class="line">          console.log(&apos;Error:&apos; + error.code + &quot; &quot; + error.message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $(function() &#123;</span><br><span class="line">      var Counter = AV.Object.extend(&quot;Counter&quot;);</span><br><span class="line">      if ($(&apos;.leancloud_visitors&apos;).length == 1) &#123;</span><br><span class="line">        addCount(Counter);</span><br><span class="line">      &#125; else if ($(&apos;.post-title-link&apos;).length &gt; 1) &#123;</span><br><span class="line">        showTime(Counter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>网上也有人贴出来这部分代码，但是会出现阅读量出现重复情况，这里的代码是经过测试后出现的，准确无误。</p></blockquote><h4 id="修改post-swing文件"><a href="#修改post-swing文件" class="headerlink" title="修改post.swing文件"></a>修改post.swing文件</h4><p>打开主题目录\layout_macro路径,找到post.swig文件，找到<code>LeanCould PageView #</code>字样,去掉 其中一个<code>&amp;nbsp; | &amp;nbsp</code>，否则部署之后会出现双<code>||</code>。</p><h4 id="修改layout-swing文件"><a href="#修改layout-swing文件" class="headerlink" title="修改layout.swing文件"></a>修改layout.swing文件</h4><p>打开主题目录\layout路径，找到_layout.swing<br>搜索<code>&lt;/body&gt;</code>标签，在其上方添加代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.leancloud_visitors.enable %&#125;</span><br><span class="line">&#123;% include &apos;_scripts/lean-analytics.swig&apos; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="给页面添加High一下"><a href="#给页面添加High一下" class="headerlink" title="给页面添加High一下"></a>给页面添加High一下</h3><p>打开<code>博客根目录\themes\next\layout_partials\header.swig</code>，在<code>&lt;ul&gt; ... /ul&gt;</code>标签之间加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt; &lt;a title=&quot;把这个链接拖到你的Chrome收藏夹工具栏中&quot; href=&apos;javascript:(function() &#123;</span><br><span class="line">    function c() &#123;</span><br><span class="line">        var e = document.createElement(&quot;link&quot;);</span><br><span class="line">        e.setAttribute(&quot;type&quot;, &quot;text/css&quot;);</span><br><span class="line">        e.setAttribute(&quot;rel&quot;, &quot;stylesheet&quot;);</span><br><span class="line">        e.setAttribute(&quot;href&quot;, f);</span><br><span class="line">        e.setAttribute(&quot;class&quot;, l);</span><br><span class="line">        document.body.appendChild(e)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function h() &#123;</span><br><span class="line">        var e = document.getElementsByClassName(l);</span><br><span class="line">        for (var t = 0; t &lt; e.length; t++) &#123;</span><br><span class="line">            document.body.removeChild(e[t])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function p() &#123;</span><br><span class="line">        var e = document.createElement(&quot;div&quot;);</span><br><span class="line">        e.setAttribute(&quot;class&quot;, a);</span><br><span class="line">        document.body.appendChild(e);</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            document.body.removeChild(e)</span><br><span class="line">        &#125;, 100)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function d(e) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            height : e.offsetHeight,</span><br><span class="line">            width : e.offsetWidth</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function v(i) &#123;</span><br><span class="line">        var s = d(i);</span><br><span class="line">        return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function m(e) &#123;</span><br><span class="line">        var t = e;</span><br><span class="line">        var n = 0;</span><br><span class="line">        while (!!t) &#123;</span><br><span class="line">            n += t.offsetTop;</span><br><span class="line">            t = t.offsetParent</span><br><span class="line">        &#125;</span><br><span class="line">        return n</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function g() &#123;</span><br><span class="line">        var e = document.documentElement;</span><br><span class="line">        if (!!window.innerWidth) &#123;</span><br><span class="line">            return window.innerHeight</span><br><span class="line">        &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123;</span><br><span class="line">            return e.clientHeight</span><br><span class="line">        &#125;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function y() &#123;</span><br><span class="line">        if (window.pageYOffset) &#123;</span><br><span class="line">            return window.pageYOffset</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function E(e) &#123;</span><br><span class="line">        var t = m(e);</span><br><span class="line">        return t &gt;= w &amp;&amp; t &lt;= b + w</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function S() &#123;</span><br><span class="line">        var e = document.createElement(&quot;audio&quot;);</span><br><span class="line">        e.setAttribute(&quot;class&quot;, l);</span><br><span class="line">        e.src = i;</span><br><span class="line">        e.loop = false;</span><br><span class="line">        e.addEventListener(&quot;canplay&quot;, function() &#123;</span><br><span class="line">            setTimeout(function() &#123;</span><br><span class="line">                x(k)</span><br><span class="line">            &#125;, 500);</span><br><span class="line">            setTimeout(function() &#123;</span><br><span class="line">                N();</span><br><span class="line">                p();</span><br><span class="line">                for (var e = 0; e &lt; O.length; e++) &#123;</span><br><span class="line">                    T(O[e])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 15500)</span><br><span class="line">        &#125;, true);</span><br><span class="line">        e.addEventListener(&quot;ended&quot;, function() &#123;</span><br><span class="line">            N();</span><br><span class="line">            h()</span><br><span class="line">        &#125;, true);</span><br><span class="line">        e.innerHTML = &quot; &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;&quot;;</span><br><span class="line">        document.body.appendChild(e);</span><br><span class="line">        e.play()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function x(e) &#123;</span><br><span class="line">        e.className += &quot; &quot; + s + &quot; &quot; + o</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function T(e) &#123;</span><br><span class="line">        e.className += &quot; &quot; + s + &quot; &quot; + u[Math.floor(Math.random() * u.length)]</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    function N() &#123;</span><br><span class="line">        var e = document.getElementsByClassName(s);</span><br><span class="line">        var t = new RegExp(&quot;\\b&quot; + s + &quot;\\b&quot;);</span><br><span class="line">        for (var n = 0; n &lt; e.length; ) &#123;</span><br><span class="line">            e[n].className = e[n].className.replace(t, &quot;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    var e = 30;</span><br><span class="line">    var t = 30;</span><br><span class="line">    var n = 350;</span><br><span class="line">    var r = 350;</span><br><span class="line">    var i = &quot;//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3&quot;;</span><br><span class="line">    var s = &quot;mw-harlem_shake_me&quot;;</span><br><span class="line">    var o = &quot;im_first&quot;;</span><br><span class="line">    var u = [&quot;im_drunk&quot;, &quot;im_baked&quot;, &quot;im_trippin&quot;, &quot;im_blown&quot;];</span><br><span class="line">    var a = &quot;mw-strobe_light&quot;;</span><br><span class="line">    var f = &quot;//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css&quot;;</span><br><span class="line">    var l = &quot;mw_added_css&quot;;</span><br><span class="line">    var b = g();</span><br><span class="line">    var w = y();</span><br><span class="line">    var C = document.getElementsByTagName(&quot;*&quot;);</span><br><span class="line">    var k = null;</span><br><span class="line">    for (var L = 0; L &lt; C.length; L++) &#123;</span><br><span class="line">        var A = C[L];</span><br><span class="line">        if (v(A)) &#123;</span><br><span class="line">            if (E(A)) &#123;</span><br><span class="line">                k = A;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (A === null) &#123;</span><br><span class="line">        console.warn(&quot;Could not find a node of the right size. Please try a different page.&quot;);</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    c();</span><br><span class="line">    S();</span><br><span class="line">    var O = [];</span><br><span class="line">    for (var L = 0; L &lt; C.length; L++) &#123;</span><br><span class="line">        var A = C[L];</span><br><span class="line">        if (v(A)) &#123;</span><br><span class="line">            O.push(A)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()    &apos;&gt;High一下&lt;/a&gt; &lt;/li&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3&quot;</code>可以替换成任意你想要的音乐地址</p></blockquote><h3 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h3><p>favicon图标也就是我们打开一个网页，出现在最浅的图标样式，可以自定义，首先我们需要一个favicon.ico的图标，可以去<a href="http://www.bitbug.net/" target="_blank" rel="noopener">比特虫</a>网站制作，网上的做法是将其放在根目录的source文件夹里。然后在主题目录的layout_partials路径下，修改header.swig的meta标签，我实验了一下，并不能配置成功呢，所以代码就不贴了，这里介绍我的做法:<br>图表制作好后，上传到云存储空间，获取图片的网址，然后打开主题配置文件_config.yml，找到favicon字段，将图片网址粘贴在后面，即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">favicon: http://ww4.sinaimg.cn/square/937882b5jw1f4db4lroy9j20hs0npmy6.jpg #网站图标</span><br></pre></td></tr></table></figure><p>到此，Next的主题算是简单的美化了一下，你现在可以在本地预览，也可以将其部署到github上去哦。</p><h3 id="增加评论功能"><a href="#增加评论功能" class="headerlink" title="增加评论功能"></a>增加评论功能</h3><p>Hexo Next 集成 utterances 评论系统</p><h4 id="GitHub-配置与脚本获取"><a href="#GitHub-配置与脚本获取" class="headerlink" title="GitHub 配置与脚本获取"></a>GitHub 配置与脚本获取</h4><ol><li>创建存放 comments 的代码仓库，必须为 public，且可创建 issue。</li><li><a href="https://github.com/apps/utterances" target="_blank" rel="noopener">install utterances app</a> 点击这个链接安装utterances app到刚刚创建的那个仓库。</li><li>打开 <a href="https://utteranc.es/" target="_blank" rel="noopener">https://utteranc.es/</a> ，根据提示的步骤生成所需的js script。也可在下面代码的基础上更新自己的信息。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://utteranc.es/client.js&quot;</span><br><span class="line">        repo=&quot;maoqyhz/comments&quot; # onwer/repo</span><br><span class="line">        issue-term=&quot;pathname&quot;   # 命名issue的格式，默认pathname</span><br><span class="line">        label=&quot;Comment&quot;         # 创建issue的tag，默认Comment</span><br><span class="line">        theme=&quot;github-light&quot;    # 评论系统theme，github-light或github-dark</span><br><span class="line">        crossorigin=&quot;anonymous&quot; # 跨域，默认</span><br><span class="line">        async&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="Hexo-Next-主题配置"><a href="#Hexo-Next-主题配置" class="headerlink" title="Hexo Next 主题配置"></a>Hexo Next 主题配置</h4><p>首先，进入主题目录，在 <code>layout/_third-party/comments/</code> 中创建 <code>utterances.swig</code>，并添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.utterances.enable %&#125;</span><br><span class="line">&lt;script src=&quot;https://utteranc.es/client.js&quot;</span><br><span class="line">        repo=&quot;&#123;&#123; theme.utterances.repo &#125;&#125;&quot;</span><br><span class="line">        issue-term=&quot;&#123;&#123; theme.utterances.issue_term &#125;&#125;&quot;</span><br><span class="line">        label=&quot;Comment&quot;</span><br><span class="line">        theme=&quot;&#123;&#123; theme.utterances.theme &#125;&#125;&quot;</span><br><span class="line">        crossorigin=&quot;anonymous&quot;</span><br><span class="line">        async&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>再在 <code>layout/_partials/comments.swig</code> 最后添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.utterances.enable %&#125;</span><br><span class="line"> &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt;</span><br><span class="line">    &#123;% include &apos;../_third-party/comments/utterances.swig&apos; %&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>最后，在主题配置文件 <code>theme/_config.yml</code> 中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># utterances </span><br><span class="line">utterances:</span><br><span class="line">  enable: true</span><br><span class="line">  repo:                  # owner/repo</span><br><span class="line">  issue_term: pathname   # pathname, url, title</span><br><span class="line">  theme: github-light    # github-light or github-dark</span><br></pre></td></tr></table></figure><p>重新生成网页，就能看到评论系统了。</p><h3 id="添加分享功能"><a href="#添加分享功能" class="headerlink" title="添加分享功能"></a>添加分享功能</h3><p>多说已经不可用</p><p>参考<code>https://github.com/theme-next/hexo-next-share</code></p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="标签页和分类页无内容显示"><a href="#标签页和分类页无内容显示" class="headerlink" title="标签页和分类页无内容显示"></a>标签页和分类页无内容显示</h3><p>首先创建两个页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><p>打开 <code>categories</code> 和<code>tags</code> 文件夹下的 <code>index.md</code> ，在最下面一行加一行文字就行，注意中间有空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type: categories</span><br></pre></td></tr></table></figure><h3 id="生成静态页面报错"><a href="#生成静态页面报错" class="headerlink" title="生成静态页面报错"></a>生成静态页面报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Template render error: (unknown path) [Line 7, Column 23]</span><br><span class="line">  Error: Unable to call `the return value of (posts[&quot;first&quot;])[&quot;updated&quot;][&quot;toISOString&quot;]`</span><br></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">把</span><br><span class="line"></span><br><span class="line">plugins:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">改成</span><br><span class="line"></span><br><span class="line">plugins:</span><br><span class="line">  hexo-generator-feed</span><br><span class="line">就行了，把短横线去掉</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Hexo，反正我第一眼看到就喜欢上了它的简约，&lt;a href=&quot;http://geoffen.github.io/&quot;&gt;感受一下吧&lt;/a&gt;。&lt;br&gt;如果你喜欢写作，我觉得你可以试试gitbook或者跟着本文搭建一个属于自己的博客空间（即使你不是IT行业的一员），不再受限于第三方博客地址，当然Hexo搭建的博客也是基于github托管的，但是并不需要你购买域名。&lt;br&gt;经过两天的探索加爬坑，终于把博客在git上安家了，感谢开源的大哥大姐们，由于并非js开发，所以遇到了很多坑，于是也想整理一篇比较完整的博客。&lt;/p&gt;
&lt;p&gt;ps:我选择的主题是&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Next&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://geoffen.github.io/tags/hexo/"/>
    
      <category term="博客" scheme="http://geoffen.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 如何向开源项目提PR</title>
    <link href="http://geoffen.github.io/2019/07/29/GitHub-%E5%A6%82%E4%BD%95%E5%90%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90PR/"/>
    <id>http://geoffen.github.io/2019/07/29/GitHub-如何向开源项目提PR/</id>
    <published>2019-07-29T05:16:19.000Z</published>
    <updated>2019-11-07T10:24:47.347Z</updated>
    
    <content type="html"><![CDATA[<ul><li>fork 到自己的仓库</li><li>git clone 到本地</li><li>上游建立连接<br><code>git remote add upstream 开源项目地址</code></li><li>创建开发分支 (非必须)<br><code>git checkout -b dev</code></li><li>修改提交代码<br><code>git status</code> <code>git add .</code> <code>git commit -m</code> <code>git push origin branch</code></li><li>同步代码三部曲<br><code>git fetch upstream</code> <code>git rebase upstream/master</code> <code>git push origin master</code></li><li>提交pr<br>去自己github仓库对应fork的项目下new pull request</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;fork 到自己的仓库&lt;/li&gt;
&lt;li&gt;git clone 到本地&lt;/li&gt;
&lt;li&gt;上游建立连接&lt;br&gt;&lt;code&gt;git remote add upstream 开源项目地址&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建开发分支 (非必须)&lt;br&gt;&lt;code&gt;gi
      
    
    </summary>
    
    
    
      <category term="GitHub" scheme="http://geoffen.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>简析 GitLab Runner</title>
    <link href="http://geoffen.github.io/2019/07/25/%E7%AE%80%E6%9E%90-GitLab-Runner/"/>
    <id>http://geoffen.github.io/2019/07/25/简析-GitLab-Runner/</id>
    <published>2019-07-25T14:34:02.000Z</published>
    <updated>2019-11-07T10:24:47.422Z</updated>
    
    <content type="html"><![CDATA[<p>原计划本文是作为此系列文章的最后一篇，即整合<code>Kubernetes</code>和<code>GitLab CI</code>并构建持续集成流程。但由于后面对<code>GitLab Runner</code>作了进一步的了解，因此，在此作下记录，同时方便有需要的同学。上两篇文章的主题分别是在<code>Kubernetes</code>中安装<code>GitLab Runner</code>以及<code>Docker-in-Docker &amp; Socket-Binding</code>这两种可以实现在容器中执行容器命令的方法。本文侧重于对<code>GitLab Runner</code>相关内容作一个补充。本文内容主要来源于两个地方：一部分是来提炼于官方文档，另一部分是通过查阅源码，归纳总结出来的核心操作的逻辑。因此，如果大家对<code>GitLab Runner</code>有兴趣或者学习/工作有需要，可以仔细查阅<a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">官方文档</a>，和追踪它的<a href="https://gitlab.com/gitlab-org/gitlab-ce/tree/master" target="_blank" rel="noopener">源码</a>。这篇文章主要阐述三个方面的内容，一是关于<code>GitLab Runner</code>的知识，其二是强调和细化一下<code>Executors</code>这个概念，最后，通过阅读源码，概要阐述<code>GitLab Runner</code>和<code>GitLab Server</code>二者的基本交互逻辑。</p><a id="more"></a><p>不是不说，有些概念官方也没有说地特别清楚（个人观点，至少对于新手而言不太友好），需要自己去实践才能彻底明白其中的原理或用法。<code>GitLab Runner</code>的源代码是用<code>Golang</code>写的，总体而言，各模块代码组织结构比较清晰，而且也不会难以读懂，强烈建议有兴趣的读者可以翻看下。下面对这三方面一一展开介绍。</p><h2 id="关于-GitLab-Runner"><a href="#关于-GitLab-Runner" class="headerlink" title="关于 GitLab Runner"></a>关于 GitLab Runner</h2><p>有一个最基本的概念需要清楚——<code>GitLab Runner</code>到底是做什么的？事实上，<code>GitLab Runner(Runner)</code>并不负责最终执行我们在<code>.gitlab-ci.yml</code>中定义的各个<code>stage</code>中的脚本（真奇怪，明明都被称为是<code>Runner</code>了）。意识到这一点很重要。因此，对于<code>Job</code>的构建效率与<code>Runner</code>本身的配置没有直接关联（但是<code>Runner</code>确实会影响到<code>CI</code>流程的构建效率，这在后面阐述）。</p><p>另外，需要提醒的是，<code>GitLab Runner</code>允许以<code>rpm</code>包、<code>debian</code>包（<code>yum</code>源、<code>apt-get</code>）安装在 <code>Linux</code>,、<code>macOS</code>或<code>FreeBSD</code>上，甚至可以通过二进制文件安装在<code>Windows</code>上，当然也可以通过拉取镜像安装在<code>Docker</code>或 <code>Kubernetes</code>中。<code>Runner</code>本身没有任何特殊之处，它也只是一个使用<code>Golang</code>编写的程序而已，因此，理论上它可以安装在任何具有<code>Golang</code>环境的机器上。</p><p>另外一个问题是，很多时候如果你的<code>GitLab CI</code>工作流程跑得比较慢（这很常见），或者说构建效率较低。此时，一般而言，可以从三个方面来调整解决：</p><ul><li>调整你的<code>.gitlab-ci.yml</code>文件内容（确保自己熟悉<a href="https://docs.gitlab.com/ce/ci/yaml/" target="_blank" rel="noopener"><code>.gitlab-ci.yml</code></a>各选项），实施一些优化操作。典型地，让各<code>stage</code>之间共享缓存。</li><li>优化你的<code>GitLab Runner</code>的配置和<code>Job</code>调度策略。这包括两个方面，其一是<code>Runner</code>的配置，比如，<code>concurrent</code>参数决定了你的项目中同时可以构建的<code>Job</code>的数量，另外还有其它的几个相关的选项。其二是<code>Runner</code>调度<code>Job</code>的策略，不同的调度策略会影响到你提交的<code>Job</code>的构建情况。典型地，若某个<code>Project</code>包含很多个<code>Job</code>，那么它很有可能会占居大量的<code>Runner</code>资源，而<code>Shared Runner</code>采用的<code>Fair Usage Queue</code>调度策略就可以缓解此问题。<code>Runner</code>的调度策略与<a href="https://docs.gitlab.com/ee/ci/runners/#shared-specific-and-group-runners" target="_blank" rel="noopener"><code>Runner</code>的类型</a>相关，其中<code>Specific/Group Runner</code>使用的是<code>FIFO</code>，注意，此<code>FIFO</code>针对的是<code>Job</code>，而不是<code>Project</code>。而<code>Shared Runner</code>使用的是<code>Fair Usage Queue</code>这种调度策略，官方文档给了<a href="https://docs.gitlab.com/ee/ci/runners/#how-shared-runners-pick-jobs" target="_blank" rel="noopener">两个例子</a>来解释。在后面，我有一张<code>PPT</code>有阐述<code>Fair Usage Queue</code>策略具体是怎样，另外有两张<code>GIF</code>分别对应官方文档的两个示例。</li><li>最后，当然，你也可以升级<code>Runner</code>的物理硬件资源配置，这种方法就不多阐述了。</li></ul><p>关于<code>GitLab Runner</code>的最佳实践，这是<code>GitLab</code>官方论坛的<a href="https://forum.gitlab.com/t/best-practices-for-ci-with-gitlab/5169" target="_blank" rel="noopener">讨论贴</a>。这是网上的一个关于<a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-ci-cd-best-practices" target="_blank" rel="noopener"><code>GitLab Best Practices</code>的建议</a>。若有需要，大家可以参考下。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/GitLab-Runner/GitLab-Runer.png" alt="GitLab-Runner"></p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/GitLab-Runner/shared-runner-1.gif" alt="Shared Runner - Fair Usage Queue-1"></p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/GitLab-Runner/shared-runner-2_1.gif" alt="Shared Runner - Fair Usage Queue-2"></p><p>最后，通过阅读官方文档，本文整理一些关于<code>Runner</code>一些<code>tips</code>：</p><ul><li><p>关于<code>Runner</code></p><ol><li>你可以为多个<code>Project</code>注册同一个<code>Specific Runner</code>，与使用<code>Shared Runner</code>注册给多个<code>Project</code>的区别是：你需要显式地在每个<code>Project</code>下 enable 这个<code>Specific Runner</code>；</li><li>注意<code>Specific Runner</code>不会为会<code>forked project</code>自动开启，因此，你需要显式注册绑定；</li><li>GitLab admin 只能注册<code>Shared Runner</code>，当然你也可以在<code>Shared Runner</code>被注册后，主动为某个<code>Project</code>取消注册此 <code>Shared Runner</code>；</li><li><code>Specific Runner</code>可以被 lock 到某个<code>Project</code>。这样其它项目不能使用此<code>Runner</code>；</li><li>注册<code>Specific Runner</code>有两种方法：<br>a.  一是直接通过<code>gitlabUrl</code>和 <code>registerToken</code>。注意此 <code>registerToken</code> 是同<code>Project</code>绑定的！<br>b.  另一种是将<code>Shared Runner</code>转换成<code>Specific Runner</code>。此操作是一次性的，且只有 admin 才能操作。</li><li>你可以通过使用<code>protected branches</code>或<code>protected tags</code>来关联拥有这些信息的<code>protected project</code>和 <code>protected Runner</code>。因为考虑到实际生产环境有些 Runner 可能包含私密信息；</li><li>实践建议：尝试给<code>Runner</code>使用<code>tag</code>，同时给<code>Project</code>打上 <code>tag</code>； 为<code>Runner</code>设置执行<code>Job</code>的超时时间。</li></ol></li><li><p>注册<code>Runner</code>是否与<code>Project</code>有关，例如<code>registerUrl</code> 和 <code>token</code> 跟项目是相关的？<br>注册<code>Specific Runner</code>与<code>Project</code>相关。必须使用<code>gitlabUrl</code>以及此项目下的<code>registerToken</code>才能将此 <code>Runner</code>注册到此<code>project</code>下。若没有提供正确的<code>registerToken</code>（但这个<code>registerToken</code>确实合法的，比如选择了其它 <code>Project</code>的<code>registerToken</code>），则也可以显式地在这些<code>Project</code>下手动 enable 此 <code>Runner</code>，前提是你是这些项目的<code>maintainer</code>。</p><p><strong>TODO</strong>: 你可以实践一个错误的<code>registerToken</code>，即它不与任何<code>Project</code>关联（<code>Kubernetes Executor</code>）。<br><strong>实践结果</strong>：<code>Runner</code>所在的<code>Pod</code>启动失败，容器就绪探针有问题。因此，验证了前述逻辑。</p></li><li><p>关于<code>Runner Token</code>的问题？<br>有两种类型的<code>Token</code>。一个是<code>Registration Token</code>，用于<code>Runner</code>注册时使用。另一个是<code>Authentication Token</code>，用于<code>Runner</code>向<code>GitLab</code>提供认证。这个<code>Token</code>可以在使用<code>Registration Token</code>注册到<code>GitLab</code>时自动获取到（由 <code>GitLab Server</code>返回）；然后，<code>Runner</code>会将它放在<code>Runner</code>的配置文件中。 或者是手动在<code>Runner</code>配置文件 的<code>[[runners]] section</code>下设置<code>token=&quot;&lt;authentication_token&gt;&quot;</code>。之后，<code>GitLab Server</code> 和 <code>Runner</code>就能正常建立连接。</p></li></ul><h2 id="关于-Executor"><a href="#关于-Executor" class="headerlink" title="关于 Executor"></a>关于 Executor</h2><p>既然<code>Runner</code>不是<code>Job</code>的执行体，那究竟是谁负责执行<code>Job</code>呢？事实上，这与<code>Executor</code>密切相关。总而言之，<code>Runner</code>是借助<code>Executor</code>来创建具体的执行我们<code>Job</code>的资源实体，官方文档把它称为<code>Runner</code>，有点尴尬，但是读者必须清楚二者的区别。那<a href="https://docs.gitlab.com/runner/executors/" target="_blank" rel="noopener"><code>Executor</code></a>又是什么呢？我个人的理解是，所谓的<code>Executor</code>是一个抽象的概念，它为<code>GitLab CI</code>构建过程提供资源环境。引入<code>Executor</code>这个概念，可以使得<code>Runner</code>使用不同的 <code>Executor</code>（<code>SSH</code>、<code>Shell</code>和<code>Kubernetes</code>等）来执行<code>Job</code>构建过程。典型地，在具体某个环境中，比如在<code>Kubernets</code>中，就由 <a href="https://docs.gitlab.com/runner/executors/kubernetes.html" target="_blank" rel="noopener"><code>Kuberentes Executor</code></a>来请求<code>Kubernetes API Server</code>动态创建<code>Pod</code>，动态创建出来的<code>Pod</code>才负责<code>Job</code>的执行（关于<code>Pod</code>的含义读者可以参考<code>Kubernetes</code>文档）。</p><p>最后，<code>Runner</code>所安装的地方并不会与最终<code>Job</code>的执行体绑定，我们姑且称这个执行体为<code>Executor</code>吧，可能不是很准确。比如，如果我们使用<code>Kubernetes Executor</code>，则我们可以将<code>Runner</code>安装在<code>Windows</code>上，但却将它远程连接到<code>Kubernetes</code>集群，并通过<code>Kubernetes Executor</code>来为<code>Job</code>的构建动态创建<code>Pod</code>，但这种方式不是最简便或最合理的，个人是将<code>Runner</code>同样安装在<code>Kubernetes</code>中，这是官方的推荐做法，一方面，因为最终的应用是部署在<code>Kubernetes</code>中，因此，这会带来便利；另外，也会省去<code>Runner</code>连接集群的一些认证等过程。当然，如果选择将<code>Runner</code>安装在<code>Windows</code>中，这是最简单朴素的方式，此时<code>Runnre</code>会直接在本地为每一个<code>Job</code>动态启动一个进程，是的，这就是<code>Shell Executor</code>。更准确而言，应该是<code>PowerShell Executor</code>。下面是个人翻译整理官方文档的一些关于各种<code>Executor</code>的基本情况：</p><ul><li><a href="https://docs.gitlab.com/runner/executors/ssh.html" target="_blank" rel="noopener"><code>SSH</code></a><ul><li>通过<code>ssh</code>连接到远程主机，然后在远程主机上启动一个进程来执行<code>GitLab CI</code>构建过程。连接时需指定<code>url、port、user、password/identity_file</code>等参数；</li><li>若想要上传<code>artificate</code>，需要将<code>Runner</code>安装在<code>ssh</code> 连接到的远程主机上。</li></ul></li><li><a href="https://docs.gitlab.com/runner/executors/shell.html" target="_blank" rel="noopener"><code>Shell</code></a><ul><li>使用安装<code>Runner</code>的同一台主机启动一个进程来执行<code>GitLab CI</code>构建过程。凡是支持安装<code>Runner</code>的机器类型，都可以用使用<code>shell</code>的方式。这意味着<code>Windows PowerShell</code>、<code>Bash</code>、<code>Sh</code>和<code>CMD</code>都是可以的。</li></ul></li><li><a href="https://docs.gitlab.com/runner/executors/virtualbox.html" target="_blank" rel="noopener"><code>VirtualBox/Parallel</code></a><ul><li>通过<code>ssh</code>远程连接到虚拟机，在虚拟机中执行<code>GitLab CI</code>构建过程，可能会创建虚拟机快照以加速下一次构建。类似地，需指定<code>user、password/identity_file</code>；</li><li>同<code>SSH</code>方式类似，若想要上传<code>artificate</code>，需要将<code>Runner</code>安装在<code>VirtualBox</code>的虚拟机中；</li><li>正式开启<code>CI</code>流程前，需提前在<code>VirtualBox</code>中创建或导入一个<code>Base Virtual Machine</code>，并在其中安装 <code>OpenSSH Server</code>以及依赖等。</li></ul></li><li><a href="https://docs.gitlab.com/runner/executors/docker.html" target="_blank" rel="noopener"><code>Docker</code></a><ul><li>将<code>Executor</code>连接到<code>Docker Daemon</code>，并在一个单独容器中跑每一次的构建过程，并使用在<code>.gitlab-ci.yml</code>文件中定义的镜像，<code>Docker Executor</code>具体是通过<code>config.toml</code>文件来配置的。</li></ul></li><li><a href="https://docs.gitlab.com/runner/executors/kubernetes.html" target="_blank" rel="noopener"><code>Kuberentes</code></a><ul><li>让<code>Runner</code>连接到连<code>Kubernetes API Server</code>，为每一个<code>Job</code>动态创建一个<code>Pod</code>来执行<code>GitLab CI</code>构建过程。</li><li>且此<code>Pod</code>除了包含固有的<code>Infra Container</code>外，还一定会包含<code>Build Container</code>和<code>Help Container</code>，另外，可能包含<code>Service Container</code>。简单而言，<code>Build Container</code>用于执行<code>.gitlab-ci.yml</code>文件中在<code>stage</code>标签中定义的脚本。<code>Help Container</code>则用于辅助<code>Build Container</code>的执行构建工作，具体是负责<code>git</code>和<code>certificate store</code>相关的操作。最后<code>Service Container</code>的用途则对应着<code>.gitlab-ci.yml</code>文件中定义的<code>service</code>标签，即一个辅助容器，为<code>Build Container</code>提供服务，其基本实现原理是<code>Docker Link</code>。</li><li>最后，每一个<code>Job</code>都会包含四个阶段（<code>Job</code>构建过程的生命周期）：<code>Prepare</code>、<code>Pre-Build</code>、<code>Build</code>和<code>Post-Build</code>。这几个阶段的具体作用，我在这里就不阐述了，比较简单，可以阅读<a href="https://docs.gitlab.com/runner/executors/kubernetes.html#workflow" target="_blank" rel="noopener">这里</a>，也可以在源码中找到。</li></ul></li></ul><p>关于<code>Executor</code>就阐述到这里，<code>Executor</code>的概念非常重要，也比较抽象。</p><h2 id="关于-GitLab-Server-同-GitLab-Runner-的交互"><a href="#关于-GitLab-Server-同-GitLab-Runner-的交互" class="headerlink" title="关于 GitLab Server 同 GitLab Runner 的交互"></a>关于 GitLab Server 同 GitLab Runner 的交互</h2><p>这一小节简要阐述下<code>GitLab Server</code>同<code>GitLab Runner</code>的交互过程，基本是通过阅读源码总结而来，但并未详细阅读源码，只是大概理清整个交互逻辑。因此，如果读者没有跟随源码，下面的描述中涉及到源码的部分可能会有点不模糊，不过没有关系，若读者只想了解二者交互的大概过程，只需要把下面的二者的交互图搞清楚即可。但若读者有兴趣，个人还是建议，可以翻看下源码，会更清楚一些。</p><p>下面从四个重要操作展开叙述，分别是：</p><ul><li><strong><code>Register Runner</code></strong>，<code>Runner</code>注册过程，即将<code>Runner</code>绑定到<code>GitLab Server</code>实例的过程；</li><li><strong><code>Polling Job</code></strong>，<code>Runner</code>轮询<code>Job</code>的过程，当<code>Runner</code>从<code>GitLab Server</code>获取到<code>Authetication Token</code>后，它会定期去向<code>GitLab Server</code>轮询是否有等待构建的<code>Job</code>；</li><li><strong><code>Handle Job</code></strong>，<code>Runner</code>一旦轮询到<code>Job</code>后，它会启动构建过程，即开始上述四个阶段：<code>Prepare、Pre-Build、Build和Post-Build</code>。（对于<code>Kubernetes Executor</code>而言）。</li><li><strong><code>Patch Job</code></strong>，在构建<code>Job</code>的过程中，会定期将<code>Job Trace</code>日志信息发送给<code>GitLab Server</code>；</li></ul><h3 id="Register-Runner"><a href="#Register-Runner" class="headerlink" title="Register Runner"></a>Register Runner</h3><p><strong><code>Register Runner</code></strong>。当执行客户端执行<code>register</code>命令(<code>gitlab-runner register ...</code>)并提供一些配置信息时，如<code>gitlabUrl、executors、token</code>和<code>tag</code>等，会触发对应的<code>Runner</code>注册过程。源码中对应的方法是 <code>commands/register.go#Execute</code>，然后会继续调用<code>register.askRunner</code>方法来配置<code>Runner</code>，在构造所需参数后，将调用<code>network/gitlab.RegisterRunner</code>方法来注册<code>Runner</code>。在此方法中，最终通过<code>http POST /runners</code>来完成向<code>GitLab Server</code>发送注册请求，同时处理注册请求的返回结果。其中，注册请求的重要参数包括 <code>registrationToken</code>，<code>locked</code>，<code>maximum_timeout</code>，<code>tag_list</code>等（这需要在配置时填写的）。而注册请求的响应内容包含一个<code>token</code>，正如前文所述，在此之后，当<code>Runner</code>向<code>GitLab Server</code>请求<code>Job</code>信息时，需携带此 <code>token</code>。最后，需要提醒的是，<a href="https://gitlab.example.com/api/v4/runners" target="_blank" rel="noopener">此接口</a>是公开的，换言之，你可以使用程序调用此接口。</p><h3 id="Polling-Job"><a href="#Polling-Job" class="headerlink" title="Polling Job"></a>Polling Job</h3><p><strong><code>Polling Job</code></strong>。当<code>Runner</code>注册成功后，其会定期（默认是<code>3</code>秒，可配置）向<code>GitLab</code>请求<code>Job</code>信息。这在源码中对应的是<code>commands/multi.go#processRunner</code>方法，然后调<code>multi.requestJob</code>法，进一步调用 <code>network.RequestJob</code>（即<code>GitLabClient.RequestJob</code>）请求<code>Job</code>。最终通过<code>http POST /jobs/request</code>接口 来完成轮询<code>Job</code>请求。此请求的重要参数包括<code>token</code>和<code>RunnerInfo</code>等 。而响应内容包括<code>jobInfo、gitInfo</code>等。当然，若没有没有等待构建的<code>Job</code>信息，则返回<code>204 StatusNoContent</code>。最后，此接口似乎没有公开。</p><p>关于<code>Polling Job</code>的具体源码体现。在<code>commands/multi.go#Run</code>方法中，异步开启一个<code>goroutine</code>，执行 <code>multi.feedRunners(runners)</code>方法，此方法会判断是否在可用的<code>runners</code>，若存在，则遍历所有可用的 <code>runner</code>，并周期性地（默认，每隔<code>CheckInterval=3s</code>）往<code>runners</code> 通道中压入<code>runner</code>。需要注意的是，若有多个<code>runners</code>，则实际的周期是<code>CheckInterval / len(runners)</code>。接着会调用方法链： <code>multi.startWorkers -&gt; multi.processRunners</code>，在此方法中通过<code>select case</code>结构从<code>runners</code>取前面压入的<code>runner</code>实例，一旦取出成功，则调用<code>multi.processRunner</code>方法，随后的步骤如前所述。</p><p>需要注意的是，在正式调用<code>multi.requestJob</code>方法前，会先通过<code>common.GetExecutor</code>获取<code>executor</code>，同时还要为<code>runner</code>申请足够资源 <code>(multi.acquireRunnerResources)</code>。</p><p>另外，最终构建<code>Job</code>是通过方法链完成的：<code>common/build.go#build.Run(mr.config, trace) -&gt; build.run(context, executor) -&gt; build.executeScript(runContext, executor)</code>。关于构建的四个阶段，对应的源码内容也比较清楚，在<code>build.executeScript</code>方法中存在如下代码调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepare -&gt; build.executeStage(ctx, BuildStagePrepare, executor)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pre-build -&gt; build.attemptExecuteStage(ctx, </span><br><span class="line">BuildStageGetSources|BuildStageRestoreCache|BuildStageDownloadArtifacts, executor, </span><br><span class="line">b.GetGetSourcesAttempts()</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">build -&gt; build.executeStage(ctx, BuildStageUserScript, </span><br><span class="line">executor) 和 build.executeStage(timeoutContext, </span><br><span class="line">BuildStageAfterScript, executor)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post-build -&gt; build.executeStage(ctx, BuildStageArchiveCache, </span><br><span class="line">executor) 和 b.executeUploadArtifacts(ctx, err, executor</span><br></pre></td></tr></table></figure><h3 id="Handle-Job"><a href="#Handle-Job" class="headerlink" title="Handle Job"></a>Handle Job</h3><p><strong><code>Handle Job</code></strong>。当成功获取<code>Job</code>息后，<code>Runner</code>就开始处理<code>Job</code>的构建过程。这在源码中对应的是 <code>commands/multi.go#requestJob</code>方法，然后调用<code>network.ProcessJob</code>方法。在这之前会构造 <code>jobCredentials{ID, Token}</code>，接着通过<code>trace.newJobTrace</code>创建<code>Job Trace</code>即<code>Job</code>处理日志，在构造函数中指定了<code>Job Trace</code>更新的周期，默认是<code>UpdateInterval=3s</code>，然后调用<code>trace.start</code>方法开启 Job Trace 输出。</p><h3 id="Patch-Job"><a href="#Patch-Job" class="headerlink" title="Patch Job"></a>Patch Job</h3><p><strong><code>Patch Job</code></strong>。在<code>Job</code>被正式构建时，是通过调用<code>trace.start</code>方法来调用<code>trace.watch</code>以周期性地<code>patch Job trace</code>。在源码中是通过<code>trace.incrementalUpdate -&gt; trace.sendPatch -&gt; network.PatchTrace</code>方法链来完成调用的，最终通过<code>http PATCH /jobs/{JobId}/trace</code>来完成<code>patch Job trace</code>请求。其中重要参数即为<code>job trace content</code>，且为增量输出，在请求的<code>headers</code>中需要设置<code>Job token</code>。若请求发送成功，则返回 <code>StatusAccepted 202</code>响应码。同时，每隔<code>forceSendInterval</code>（默认<code>30s</code>） 的时间还要更新<code>Job</code>执行状态信息（<code>pending、running、failed</code>和<code>success</code>），在源码中是通过方法链<code>trace.touchJob -&gt; network.UpdateJob</code>来完成，最后通过<code>http  PUT /jobs/{JobId}</code>完成请求的发送，其中重要参数包括<code>runnerInfo、JobToken、JobState</code> 等。但需要注意的是，若<code>Job</code>执行失败，则会附带上失败原因<code>FailureReason</code>，若<code>Job Status</code>更新成功，则返回<code>UpdateSucceeded 200</code>响应码。</p><p>下面是一张完整的<code>GitLab Server</code>同<code>GitLab Runner</code>的交互图。其中，最左边的表示客户端执行的<code>Runner</code>的命令（注册，启动和取消注册）。中间用红色标示的表示各个详细的阶段。右边中绿色标注的表示<code>Runner</code>同<code>GitLab Server</code>的<code>Http</code>通信细节，这个是最重要的。右边的黑色和蓝色标示的表示<code>Runner</code>自身内部执行的一些操作。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/GitLab-Runner/Runner%26GitLabServer_meitu_1.jpg" alt="Runner-GitLab-communication"></p><p>简单小结，本文主要阐述了三个方面的内容：一是阐述<code>Runner</code>相关的知识，特别要清楚<code>Runner</code>的本质是什么，以及提高<code>GitLab CI</code>构建效率的三个方面的知识，最后补充了<code>Runner</code>相关的细节知识点；二是阐述<code>Executor</code>相关的知识，包括<code>Executor</code>的本质，与<code>Runner</code>的关系，并且简要阐述了各种<code>Executor</code>，需要重点关注<code>Kubernetes Executor</code>。最后，阐述<code>GitLab Server</code>同<code>GitLab Runner</code>基本交互逻辑，主要是包括四个阶段（没包括最后的取消注册），这几个阶段都挺重要，读者可以借助二者的交互图来理解，重点关注二者之间的<code>Http</code>交互的各阶段。这有助于理解<code>Runner</code>的执行原理。</p><p>参考文献</p><p>[1].<a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">https://docs.gitlab.com/runner/</a><br>[2].<a href="https://forum.gitlab.com/t/best-practices-for-ci-with-gitlab/5169" target="_blank" rel="noopener">https://forum.gitlab.com/t/best-practices-for-ci-with-gitlab/5169</a><br>[3].<a href="https://docs.gitlab.com/runner/executors/" target="_blank" rel="noopener">https://docs.gitlab.com/runner/executors/</a><br>[4].<a href="https://docs.gitlab.com/runner/executors/kubernetes.html" target="_blank" rel="noopener">https://docs.gitlab.com/runner/executors/kubernetes.html</a><br>[5].<a href="https://docs.gitlab.com/ee/api/" target="_blank" rel="noopener">https://docs.gitlab.com/ee/api/</a><br>[6].<a href="https://gitlab.com/gitlab-org/gitlab-ce/tree/master" target="_blank" rel="noopener">https://gitlab.com/gitlab-org/gitlab-ce/tree/master</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原计划本文是作为此系列文章的最后一篇，即整合&lt;code&gt;Kubernetes&lt;/code&gt;和&lt;code&gt;GitLab CI&lt;/code&gt;并构建持续集成流程。但由于后面对&lt;code&gt;GitLab Runner&lt;/code&gt;作了进一步的了解，因此，在此作下记录，同时方便有需要的同学。上两篇文章的主题分别是在&lt;code&gt;Kubernetes&lt;/code&gt;中安装&lt;code&gt;GitLab Runner&lt;/code&gt;以及&lt;code&gt;Docker-in-Docker &amp;amp; Socket-Binding&lt;/code&gt;这两种可以实现在容器中执行容器命令的方法。本文侧重于对&lt;code&gt;GitLab Runner&lt;/code&gt;相关内容作一个补充。本文内容主要来源于两个地方：一部分是来提炼于官方文档，另一部分是通过查阅源码，归纳总结出来的核心操作的逻辑。因此，如果大家对&lt;code&gt;GitLab Runner&lt;/code&gt;有兴趣或者学习/工作有需要，可以仔细查阅&lt;a href=&quot;https://docs.gitlab.com/runner/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;，和追踪它的&lt;a href=&quot;https://gitlab.com/gitlab-org/gitlab-ce/tree/master&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;。这篇文章主要阐述三个方面的内容，一是关于&lt;code&gt;GitLab Runner&lt;/code&gt;的知识，其二是强调和细化一下&lt;code&gt;Executors&lt;/code&gt;这个概念，最后，通过阅读源码，概要阐述&lt;code&gt;GitLab Runner&lt;/code&gt;和&lt;code&gt;GitLab Server&lt;/code&gt;二者的基本交互逻辑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="持续集成" scheme="http://geoffen.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="gitlab-ci" scheme="http://geoffen.github.io/tags/gitlab-ci/"/>
    
  </entry>
  
  <entry>
    <title>浅析 docker-in-docker 和 socket-binding</title>
    <link href="http://geoffen.github.io/2019/07/07/%E6%B5%85%E6%9E%90-docker-in-docker-%E5%92%8C-socket-binding/"/>
    <id>http://geoffen.github.io/2019/07/07/浅析-docker-in-docker-和-socket-binding/</id>
    <published>2019-07-06T22:08:17.000Z</published>
    <updated>2019-11-07T10:24:47.417Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章详细阐述在<code>k8s</code>中安装<code>gitlab runner</code>的整个流程，并且也阐明了其中涉及的原理。原计划这一篇博文紧接着叙述基于<code>k8s</code>并集成<code>gitlab-ci</code>的持续集成部署方案的第二阶段——研究集成<code>gitlab-ci</code>和<code>k8s</code>来实现一个以<code>build-&gt;test-&gt;deploy</code>为核心的持续集成部署流程。第一阶段只是搭建好了环境，显然第二阶段要更重要。但考虑到个人在第二阶段实验过程涉及到至关重要的一个问题，因此，打算单独开一篇博文总结一些看过的资料，并基于个人的理解与认识将此问题解释清楚。是的，这个问题是：若我们想在<code>docker</code>中运行<code>docker</code>应该如何实现呢？简单而言，在一个<code>docker</code>容器内能够安装<code>docker daemon</code>，以使得我们能够执行<code>docker build/push</code>等命令。这个问题在<code>ci/cd</code>中很典型，无论是采用<code>Jenkins</code>还是<code>gitlab-ci</code>同<code>docker</code>或<code>k8s</code>结合。比如，对于<code>gitlab-ci</code>而言，它的每一个<code>stage</code>都跑在一个容器中的，而若想在某个<code>stage</code>中执行<code>docker</code>命令（典型的，在服务构建阶段会涉及到<code>docker build</code>），默认是不支持的。我们将此种需求概略地称为在容器中运行容器。在本博文中主要讨论实现此需求的两种实现方式，但事实上，也可能不仅仅这两种方式。</p><a id="more"></a><p>本文不会过多阐述<a href="https://docs.docker.com/" target="_blank" rel="noopener"><code>docker</code></a>基本原理，但这两种实现方式确实会涉及到<code>docker</code>的一些知识。因此，你需要具备<code>docker</code>基本原理的基础。若要在一个容器中安装另外一个容器，从技术上而言，这是可以实现的。似乎在<code>Docker 0.6</code>版就添加了这个新特性，且从使用上而言，也较为简单，我们暂且称之<code>docker-in-docker(dind)</code>。但它涉及到一些安全问题，也可能会引起一些奇怪的问题。具体你可以参考<a href="http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" target="_blank" rel="noopener">这里</a>。因此，自然而然就诞生了其它更为合理的方式——<code>socket-binding</code>，它实际上并非严格意义上的<code>docker-in-docker</code>，但它可以实现类似在容器中执行容器相关命令的效果。并且它还具备其它的优势，典型的，可以让子容器，孙子容器等等共享镜像缓存，这在某些情况下是非常合适的。下面详细介绍这两种实现方式，都遵循从实践到理论的阐述思路。</p><h2 id="docker-in-docker"><a href="#docker-in-docker" class="headerlink" title="docker-in-docker"></a>docker-in-docker</h2><p><code>docker-in-docker</code>这种模式从最初作为新特性被引入<code>docker</code>，到当前的版本，功能确实日趋完善。但在这里仍旧只涉及其核心部分的实践及原理。</p><h3 id="docker-in-docker-初步实践"><a href="#docker-in-docker-初步实践" class="headerlink" title="docker-in-docker 初步实践"></a>docker-in-docker 初步实践</h3><p>在<code>0.6</code>版的<code>Docker</code>在执行<code>docker run</code>命令时，增加了一项新特性——<code>privileged</code>选项参数，可以说就是此参数真正实现了在容器中运行容器的功能。如图1，当你执行如下命令：</p><p><code>docker run --privileged -it jpetazzo/dind</code></p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/practice-privileged-1.png" alt="run-jpetazzo/dind-with-privileged"></p><p>它会从<a href="https://hub.docker.com/r/jpetazzo/dind/" target="_blank" rel="noopener"><code>docker hub</code></a>下载一个特殊的<code>docker image</code>，此镜像包含了<code>docker client</code>和<code>docker daemon</code>，并且指明以特权模式来执行它，然后它启动一个本地<code>docker daemon</code>，并进入容器交互式<code>shell</code>。在此特殊容器中，你可以继续执行<code>docker run</code>启动容器：</p><p><code>docker run -it ubuntu bash</code></p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/practice-previliged.png" alt="run-in-dind"></p><p>仔细观察你的容器<code>ID</code>，你的<code>hostname</code>发生了变化，说明你已经从外层容器进入到了内层容器了！值得注意的是，此时，内层容器与外层容器依然是隔离的。我们可以简单验证一下。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/practice-privileged-3.png" alt="dind-islotation"></p><h3 id="docker-in-docker-in-docker"><a href="#docker-in-docker-in-docker" class="headerlink" title="docker-in-docker-in-docker?"></a>docker-in-docker-in-docker?</h3><p>有读者可能会思考，既然我可以在容器中启动容器，即<code>docker-in-docker</code>，那么我是否可以做到<code>docker-in-docker-in-docker</code>呢？是的，这完全可以实现，甚至，理论上你可以无限递归下去，只要你在启动下一层容器时，开启特权选项即可。你可以实践下图的操作内容，观察容器<code>ID</code>，说明你确实做到了容器递归嵌套容器。而且你会发现每次执行<code>docker run</code>命令时，它都会去下载<code>jpetazzo/dind</code>这个镜像，这说明了各个层级的容器不会共享<code>image</code>，这也间接证明了各层级的容器确实处于隔离状态。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/docker-in-docker-in-docker.png" alt="docker-in-docker-docker"></p><h3 id="关于-privileged-特权模式"><a href="#关于-privileged-特权模式" class="headerlink" title="关于 privileged 特权模式"></a>关于 privileged 特权模式</h3><p>关于<code>privileged</code>特权模式。我们知道<code>linux</code>进程包括<code>priviledged process</code>，即<code>root</code>用户（或者说<code>pid=0</code>的用户）创建的进程，和<code>unpriviledged process</code>，即普通用户创建的进程。<code>--privileged</code>选项实际上就是创建<code>priviledged container</code>进程。考虑到默认情况下<code>docker</code>容器运行模式为<code>unprivileged</code>，这使得在一个<code>docker</code>容器中跑另外一个<code>docker daemon</code>不被允许，因为容器不能访问宿主机的任何<code>device</code>。但一个具备<code>privileged</code>特权的容器则允许访问所有<code>device</code><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/devices.txt" target="_blank" rel="noopener"><code>(cgroup device)</code></a>，即可以访问<code>/dev</code>下所有的目录。换言之，当容器被配置成<code>privileged</code>模式时，容器对宿主机的所有<code>device</code>具有完全控制权，同时通过修改<code>AppArmor</code>及<code>SELinux</code>相关的配置，使得容器几乎相当于运行在宿主机上的进程一样，具有完全访问宿主机的权限。</p><p>虽然，在<code>Docker 0.6</code>版，纯粹只添加了<code>--privileged</code>选项。但当前的版本(<code>18.09.6</code>)其实限制容器对宿主机设备的访问权限的粒度已经控制得比较精确了。换言之，如果只想让容器访问部分设备，可以使用<code>--device</code>选项，这使得默认情况下，容器对这些设备具有<code>read</code>、<code>write</code>、和<code>mknod</code>权限，但可使用<code>:rwm</code>作出限制。</p><p>除了使用<code>privileged</code>选项，也可使用<code>--cap-add</code>和<code>--cap-drop</code>选项以更细粒度的控制容器对宿主机访问的某些方面的权限。更多可参考<code>docker</code><a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="jpetazzo-dind-基本原理"><a href="#jpetazzo-dind-基本原理" class="headerlink" title="jpetazzo-dind 基本原理"></a>jpetazzo-dind 基本原理</h3><p>现在，我们来讨论一下<code>jpetazzo/dind</code>这个镜像的特殊之处。主要参考的是<a href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/" target="_blank" rel="noopener">这篇文章</a>。事实上，这个镜像也没有什么太大不同，也是由<code>Dockerfile</code>构建，下面是它的<code>Dockerfile</code>内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> jerome.petazzoni@docker.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># Let's start with some basic stuff.</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update -qq &amp;&amp; apt-get install -qqy \</span></span><br><span class="line"><span class="bash">    apt-transport-https \</span></span><br><span class="line"><span class="bash">    ca-certificates \</span></span><br><span class="line"><span class="bash">    curl \</span></span><br><span class="line"><span class="bash">    lxc \</span></span><br><span class="line"><span class="bash">    iptables</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Install Docker from Docker Inc. repositories.</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -sSL https://get.docker.com/ | sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install the magic wrapper.</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./wrapdocker /usr/<span class="built_in">local</span>/bin/wrapdocker</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /usr/<span class="built_in">local</span>/bin/wrapdocker</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define additional metadata for our image.</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /var/lib/docker</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"wrapdocker"</span>]</span></span><br></pre></td></tr></table></figure><p><code>Dockerfile</code>所包含的内容并不复杂，主要做了如下四几件事情：</p><ul><li>安装一些<code>docker daemon</code>依赖软件包，包括<code>lxc</code>和<code>iptables</code>。另外，当<code>docker daemon</code>同<code>docker index/registry</code>通信时，需要校验其<code>SSL</code>认证，因此需安装<code>ca-certificates</code>和<code>apt-transport-https</code>等。</li><li>挂载<code>/var/lib/docker volume</code>。因为容器文件系统是基于<code>AUFS</code>的挂载点(<code>mountpoint</code>)，而构成<code>AUFS</code>的分层文件系统应为正常的文件系统。 换言之，<code>/var/lib/docker</code>这个用于存储它创建的容器的目录不能是<code>AUFS</code>文件系统。因此，将此目录以<code>volume</code>的形式挂载到宿主机。这使得后面在容器中创建的内层容器的数据真正存储宿主机的<code>/var/lib/docker/volumns</code>目录下。</li><li>通过脚本快速安装一个最新的<a href="https://github.com/docker/docker-install" target="_blank" rel="noopener"><code>docker</code></a>二进制镜像文件。</li><li>执行一个<a href="https://github.com/jpetazzo/dind/blob/master/wrapdocker" target="_blank" rel="noopener"><code>helper</code></a>脚本。脚本主要操作包括如下三个方面：<ul><li>确保<code>cgroup</code>伪文件系统已经被正确挂载，若没有挂载，则依据宿主机中<code>cgroup</code>层级文件系统的形式对它进行挂载，因为<code>docker(lxc-start)</code>需要它。</li><li>关闭宿主机上多余的文件描述符。否则可能会造成文件描述符资源泄露。虽然这不是严格必需，但目前我们关闭它可以避免一些奇怪的行为（副作用）。</li><li>检测你是否在命令行中通过<code>-e PORT=...</code>指定了一个<code>PORT</code>环境变量。如果你确实指定了，<code>docker daemon</code>将会在前台启动，并在指定<code>TCP</code>端口监听<code>API</code>请求。反之，它会在后台启动<code>docker daemon</code>进程，并且为你提供一个交互式的<code>shell</code>。</li></ul></li></ul><h3 id="docker-as-a-service"><a href="#docker-as-a-service" class="headerlink" title="docker-as-a-service"></a>docker-as-a-service</h3><p>最后，需要补充的一点是，若你想使用<code>docker-in-docker</code>来作为一个服务（上述已提到<code>helper</code>脚本中最后一个操作，即判定<code>docker deamon</code>是监听指定端口，还是提供一个临时<code>shell</code>），即计划提供一个<code>Docker-as-a-Service</code>，注意不是<code>Containers-as-a-Service</code>，这两者在概念上是有区别的。因为我们提供的服务是一个<code>docker</code>实例。我们可以通过如下命令，通过让容器运行于后台模式，并对外暴露一个端口来实现：</p><p><code>docker run --privileged -d -p 1234 -e PORT=1234 jpetazzo/dind</code></p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/dokcer-as-as-service.png" alt="docker-as-a-service"></p><p>如上的命令可以获取到容器的<code>ip</code>和<code>port</code>，如此便可为第三方提供<code>docker</code>实例的服务。简单而言，它们可直接连接到<code>docker</code>实例(<code>docker daemon</code>)执行与容器相关的操作。我们简单运行一个只安装了<code>docker clinet</code>的容器，然后设置其<code>DOCKER_HOST</code>为此提供<code>docker daemon</code>的容器的地址，然后简单实验一下是否成功连接，并使用作为服务的<code>docker daemon</code>。当然，你也可以参考<a href="https://hub.docker.com/_/docker" target="_blank" rel="noopener">这里</a>，使用<code>docker link</code>来做实验完成类似的效果。同样，考虑到此<code>docker</code>实例服务是以<code>priviliged</code>模式运行的，因此，它可能会因为获取了特权而造成不可预料的风险。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/docker-as-a-servce-1.png" alt="dind-host"></p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/docker-as-a-service-2.png" alt="dind-docker"></p><h2 id="socket-binding"><a href="#socket-binding" class="headerlink" title="socket-binding"></a>socket-binding</h2><p><code>docker-in-docker</code>的方式可以实现在容器中启动另一个容器，但它确实存在安全风险，而且，也存在潜在的棘手问题，具体可以参考这篇<a href="http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/" target="_blank" rel="noopener">博文</a>。值得一提的是，使用<code>dind</code>的方式，无法让各内层容器之间或容器与主机之间共享缓存，这在基于<code>k8s</code>集成<code>gitlab</code>实现持续集成部署方案的用例中是一个比较严重的问题。因此，笔者考虑使用<code>socket-binding</code>的方式（<code>socket-binding</code>称呼源自<code>gitlab</code><a href="https://docs.gitlab.com/runner/executors/kubernetes.html#exposing-varrundockersock" target="_blank" rel="noopener">官方文档</a>，也可称之为<a href="https://docs.docker.com/storage/bind-mounts/" target="_blank" rel="noopener"><code>bind-mount</code></a>）。</p><h3 id="socket-binding-实践"><a href="#socket-binding-实践" class="headerlink" title="socket-binding 实践"></a>socket-binding 实践</h3><p>事实上，很多情况下，我们并不真正需要在一个容器中运行另外一个容器（或许存在特例）。我们需要的可能只是想在<code>docker</code>容器中能够继续执行<code>docker</code>相关操作（如<code>docker build/pull/push</code>等），至少在笔者的使用案例中是这样的。因此，使用<code>dind</code>的方式是否显得小题大做了？事实上若要达到我们的目的（在容器中执行<code>docker</code>相关命令操作）是很简单的——在启动容器时使用<code>-v</code>选项以绑定挂载的方式(<code>binding mount</code>)将宿主机的<code>docker socket</code>挂载到容器，即执行如下命令：</p><p><code>docker run -it -v /var/run/docker.sock:/var/run/docker.sock some-docker-image /bin/bash</code></p><p>且此<code>docker run</code>命令中的使用的<code>some-docker-image</code>镜像则不必为<code>jpetazzo/dind</code>，它没有任何特殊之处。当然，此镜像必须包含<code>docker client</code>，而可以不用包含<code>docker engine</code>。因为，当我们以<code>socket-binding</code>的形式来<code>run</code>一个容器时，它实际上是将宿主机的<code>/var/run/docker.sock</code>挂载到了容器中<code>/var/run/docker.sock</code>，这使得在容器中执行<code>docker build/push/pull</code>命令真正使用的是宿主机的<code>docker daemon</code>，换言之，我们使用容器中的<code>docker client</code>和容器外的宿主机的<code>docker daemon</code>进行通信。这不同于<code>dind</code>，它并非真正实现了在容器中运行容器的功能。当使用<code>socket-binding</code>的方式时，所创建的容器和执行<code>docker</code>命令的当前容器处于同一层级（不是父子关系，而是兄弟关系），都是直接隶属于宿主机下的一层。因此，你可以推理得到，正因为所有的”内层”容器实际上都使用的是宿主机的<code>docker daemon</code>，这使得宿主机和所有有的容器可以共享镜像缓存！最后，同<code>docker-in-docker-in-docker...</code>类似，<code>socket-binding</code>的方式理论上也可以无限递归。我们简单通过如下的操作过程简单实践：</p><p>先使用下面的<code>Dockerfile</code>构建我们的实验镜像，注意，我们在容器中只安装了<code>docker client</code>。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/socket-binding-1.png" alt="sc-dockerfile"></p><p>然后，构建一个名为<code>dind-sc</code>的镜像。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/socket-binding-2.png" alt="sc-image-build"></p><p>使用<code>run</code>命令启动容器，并进入到容器中，执行<code>docker version</code>命令，可以同时输出了<code>docker client</code>和<code>docker engine</code>的信息！另外，执行<code>docker image</code>命令，发现输出一堆<code>image</code>，是的，这是宿主机上的镜像。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/socket-binding-3.png" alt="sc-docker-run"></p><p>我们再一次在当前容器中基于此<code>Dockerfile</code>构建（有没有发现这次构建非常快，是的，使用了上一次的镜像缓存），然后运行此容器……，重复上述的操作。可以发现，所启动的容器的地位其实是一样的，它们都在同一个层级。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/socket-binding-4.png" alt="sc-dind-build"></p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/socket-binding-5.png" alt="sc-docker-2"></p><p>最后，实验验证宿主机同各容器共享镜像<code>cache</code>。可以看到，我们在宿主机中构建的镜像可以在容器中看到，而在容器中拉到的<code>nginx</code>镜像，也能在宿主机中看到。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/dind%26socket-binding/socket-binding-6.png" alt="sc-docker-cache"></p><h3 id="关于-docker-volume"><a href="#关于-docker-volume" class="headerlink" title="关于 docker volume"></a>关于 docker volume</h3><p>基于<code>socket-binding</code>来实现在容器中执行容器相关操作的命令的原理其实就是<code>docker volume</code>。<code>docker</code>为了能够保存（持久化）数据以及共享容器间的数据，引入了<code>volume</code>机制。简单而言，<code>volume</code>就是目录或者文件，它可以绕过默认的由多个只读层及一个读写层叠加而成的联合文件系统(<code>union file system</code>)，而以正常的文件或者目录的形式存在于宿主机上。<code>volume</code>机制隔离了容器自身与数据，这是为了保证数据对于容器的生命周期来说是持久化的，换言之，即使你删除了停止的容器数据也还在（除非显式加上<code>-v</code>选项）。</p><p><code>volume</code>可以通过两种方式来创建：其一是在<code>Dockerfile</code>中指定<code>VOLUME /some/dir</code>；其二是执行<code>docker run -v /some/dir</code>命令来指定。这两种方式都是让<code>Docker</code>在主机上创建一个目录，注意默认情况下是在<code>/var/lib/docker</code>下的。并将其挂载到我们指定的路径(<code>/some/dir</code>)，当此路径在容器中不存在时，默认会自动创建它。值得注意的是，我们也可以显式指定将宿主机的某个目录或文件挂载到容器的指定位置（在上述实践环节正是这样操作的，这种方式也被称为是<code>bind-mount</code>）。最后强调一点，当删除使用<code>volume</code>的容器时，<code>volume</code>本身不受影响。</p><p>更多关于<code>volume</code>的操作请查看<a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">官方文档</a>。</p><p>简单小结，本文阐述了两种实现在容器中运行容器的方法——<code>docker-in-docker</code>和<code>socket-binding</code>。对于<code>docker-in-docker</code>这种方式，虽然它存在不少问题，但它确实实现了在容器中运行容器。围绕<code>docker-in-docker</code>，先简单演示了其基本用法，然后进一步推广出<code>docker-in-docker-in-docker...</code>模式，这在理论上都是可行的。紧接从<code>privileged</code>选项切入阐述<code>dind</code>的相关原理，重点解释了<code>jpetazzo/dind</code>此特殊镜像的构建过程，最后描述了生产环境中<code>dind</code>的实践方式，即以<code>docker-as-a-service</code>的模式以将<code>docker</code>实例通过端口暴露给外部使用。另一种巧妙实现在容器中执行容器命令的方法是<code>socket-binding</code>。可以说，<code>dind</code>能够实现的，它基本都能实现，而且，它解决了各内层容器同宿主机共享镜像缓存的问题。且<code>socket-binding</code>的用法也较为简单，其原理简单而言，就是采用<code>bind-mount</code>通过<code>-v</code>选项将宿主机的<code>docker daemon</code>挂载到容器中，使得只需在容器中安装<code>docker client</code>（事实上，也可不安装<code>docker client</code>，而直接将宿主机的<code>/usr/bin/docker</code>挂载到容器中，同时安装<code>docker</code>执行所需的依赖文件即可）即可执行<code>docker pull/push/build</code>命令。</p><p>参考文献</p><p><code>docker-in-docker</code><br>[1].<a href="https://hub.docker.com/_/docker" target="_blank" rel="noopener">https://hub.docker.com/_/docker</a><br>[2].<a href="https://github.com/jpetazzo/dind/" target="_blank" rel="noopener">https://github.com/jpetazzo/dind/</a><br>[3].<a href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/" target="_blank" rel="noopener">https://blog.docker.com/2013/09/docker-can-now-run-within-docker/</a><br>[4].<a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities</a></p><p><code>socket-binding</code><br>[1].<a href="https://docs.docker.com/storage/volumes/" target="_blank" rel="noopener">https://docs.docker.com/storage/volumes/</a><br>[2].<a href="http://dockone.io/article/128" target="_blank" rel="noopener">http://dockone.io/article/128</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章详细阐述在&lt;code&gt;k8s&lt;/code&gt;中安装&lt;code&gt;gitlab runner&lt;/code&gt;的整个流程，并且也阐明了其中涉及的原理。原计划这一篇博文紧接着叙述基于&lt;code&gt;k8s&lt;/code&gt;并集成&lt;code&gt;gitlab-ci&lt;/code&gt;的持续集成部署方案的第二阶段——研究集成&lt;code&gt;gitlab-ci&lt;/code&gt;和&lt;code&gt;k8s&lt;/code&gt;来实现一个以&lt;code&gt;build-&amp;gt;test-&amp;gt;deploy&lt;/code&gt;为核心的持续集成部署流程。第一阶段只是搭建好了环境，显然第二阶段要更重要。但考虑到个人在第二阶段实验过程涉及到至关重要的一个问题，因此，打算单独开一篇博文总结一些看过的资料，并基于个人的理解与认识将此问题解释清楚。是的，这个问题是：若我们想在&lt;code&gt;docker&lt;/code&gt;中运行&lt;code&gt;docker&lt;/code&gt;应该如何实现呢？简单而言，在一个&lt;code&gt;docker&lt;/code&gt;容器内能够安装&lt;code&gt;docker daemon&lt;/code&gt;，以使得我们能够执行&lt;code&gt;docker build/push&lt;/code&gt;等命令。这个问题在&lt;code&gt;ci/cd&lt;/code&gt;中很典型，无论是采用&lt;code&gt;Jenkins&lt;/code&gt;还是&lt;code&gt;gitlab-ci&lt;/code&gt;同&lt;code&gt;docker&lt;/code&gt;或&lt;code&gt;k8s&lt;/code&gt;结合。比如，对于&lt;code&gt;gitlab-ci&lt;/code&gt;而言，它的每一个&lt;code&gt;stage&lt;/code&gt;都跑在一个容器中的，而若想在某个&lt;code&gt;stage&lt;/code&gt;中执行&lt;code&gt;docker&lt;/code&gt;命令（典型的，在服务构建阶段会涉及到&lt;code&gt;docker build&lt;/code&gt;），默认是不支持的。我们将此种需求概略地称为在容器中运行容器。在本博文中主要讨论实现此需求的两种实现方式，但事实上，也可能不仅仅这两种方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="持续集成" scheme="http://geoffen.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="docker" scheme="http://geoffen.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>k8s 中安装 gitlab runner</title>
    <link href="http://geoffen.github.io/2019/07/06/k8s-%E4%B8%AD%E5%AE%89%E8%A3%85-gitlab-runner/"/>
    <id>http://geoffen.github.io/2019/07/06/k8s-中安装-gitlab-runner/</id>
    <published>2019-07-05T22:08:17.000Z</published>
    <updated>2019-11-07T10:24:47.401Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作的内容属于<code>devops</code>领域方向，研究的课题是基于<code>k8s</code>并集成<code>gitlab-ci</code>的持续集成部署方案。个人以前只使用过<code>Jenkins</code>来做持续集成部署(<code>ci/cd</code>)，而且，当时应该是部署在云主机上的。<code>gitlab</code>本身一个企业级代码托管平台，在<code>8.0</code>版本加入了<code>ci</code>，并且默认为每个项目开启。持续集成基本解放了软件项目的开发测试到最终的部署上线的繁琐流程，简单而言，它保证了每一次往版本库提交的代码都符合预期。我们知道<code>docker</code>解决了应用打包和发布这一运维技术难题，简单而言，<code>docker</code>所提供的极为方便的打包机制直接打包了应用运行所需要的整个操作系统，从而保证了本地环境和云端环境的高度一致。但毕竟在整个云计算领域中，<code>docker</code>只是整个容器生态的一个承载点，换言之，与开发者更为密切相关的事情是定义容器组织和管理规范的容器编排技术，这属于一个更高的层次，是一个平台级的技术。<code>kuberentes</code>正是这样一个开源平台，简而言之，<code>kubernetes</code>项目解决的问题是容器的编排、调度以及集群管理，当然，它也提供了一些高级的运维功能，如路由网关、水平扩展、监控、备份以及灾难恢复等。这也使得<code>kubernetes</code>从一诞生就备受关注。因此，将<code>gitlab-ci</code>与<code>k8s</code>进行整合是<code>ci/cd</code>实践中值得期待的方案。本系列博客会阐述个人基于<code>k8s</code>并集成<code>gitlab-ci</code>的持续集成部署方案的实现过程。实践环节包括两个部分，其一是在<code>k8s</code>中安装<code>gitlab runner</code>，其二是研究集成<code>gitlab-ci</code>和<code>k8s</code>来实现一个以<code>build-&gt;test-&gt;deploy</code>为核心的持续集成部署流程。本文的内容为第一个部分。</p><a id="more"></a><p>本文不会过多阐述<a href="https://docs.docker.com/" target="_blank" rel="noopener"><code>docker</code></a>相关原理，也不会过多涉及到<a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener"><code>kubernetes</code></a>相关原理。只会在阐述整个基于<a href="https://docs.gitlab.com/ee/ci/introduction/" target="_blank" rel="noopener"><code>gitlab-ci</code></a>和<code>kubernetes</code>的持续集成部署方案的过程中，涉及到的概念原理。本文从如下几个方面来完整的阐述在<code>k8s</code>中安装<a href="https://docs.gitlab.com/ee/ci/runners/README.html#shared-specific-and-group-runners" target="_blank" rel="noopener"><code>gitlab runner</code></a>的流程：其一，简述<code>gitlab-ci</code>的核心概念及基本原理；其二，简述<code>gitlab runner</code>相关知识 ；其三，详细阐述<code>gitlab runner</code>在<code>k8s</code>中的安装流程；最后，对<code>gitlab runner</code>相关的配置文件中重要的配置进行介绍，以更深入地理解<code>gitlab runner</code>集成到<code>k8s</code>的原理。依据官方文档是使用<a href="https://helm.sh/docs/" target="_blank" rel="noopener"><code>helm</code></a>作为软件安装工具，以在<code>k8s</code>中安装<code>gitlab runner</code>，但本文不会过多涉及<code>helm</code>的相关知识和原理。事实上，若读者不具备相关的知识基础，也没有太大影响。若读者已经对<code>gitlab, gitlab runner</code>已经较为熟悉，可以直接跳到第3小节。</p><h2 id="gitlab-ci-核心概念和基本原理"><a href="#gitlab-ci-核心概念和基本原理" class="headerlink" title="gitlab-ci 核心概念和基本原理"></a>gitlab-ci 核心概念和基本原理</h2><p>所谓持续集成持续部署(<code>ci/cd</code>, <code>Continuous Integration, Continuous Delivery, and Continuous Deployment</code>)，通俗而言，即在软件开发过程中，每当涉及版本库代码变更或更迭时，通过自动化执行一些由开发人员定义的脚本，以最小化引入错误的风险。自动化执行脚本说明（几乎）不需要人为干预。具体而言，持续集成表示当开发人员提交代码到版本库时（不一定是<code>master</code>分支），都会触发一系列的关于测试、构建等步骤的脚本自动化执行，以验证版本库中当前的代码所产生的效果是符合预期的。另外，持续交付(<code>Continuous Delivery</code>)和持续部署(<code>Continuous Deployment</code>)的区别在于是否需要人为干预，以部署项目到生产环境，而后者不需要人为干预。</p><p><code>gitlab-ci/cd</code>集成了上述功能。其基本原理是版本库每一次<code>push</code>或者<code>merge reqeust</code>操作都会触发一次<code>gitlab-ci</code>流程，即执行开发人员预先在<code>.gitlab-ci.yml</code>定义的一系列<code>stage</code>，典型的，包括<code>build</code>、<code>test</code>和<code>deploy</code>这几个核心阶段。<code>gitlab-ci</code>确实较为强大，提供了丰富的功能，以实现项目开发的快速更迭。比如，它可以在各<code>stage</code>中共享缓存，以提高各<code>stage</code>的构建效率。和<code>gitlab-ci/cd</code>相关的几个核心概念如下：</p><ul><li><code>pipeline</code>，表示一次构建任务，可包含多个阶段，如依赖安装、运行测试、项目编译、服务部署。</li><li><code>stage</code>，表示某个具体阶段，它们会依次串行执行，前一个成功执行后下一个才会执行，相反，若前一个执行失败，下一个则默认不会执行。</li><li><code>job</code>，表示<code>stage</code>上所执行的具体工作，一个<code>stage</code>可包含若干个并行执行的<code>job</code>，只有所有的<code>job</code>都执行成功，整个<code>stage</code>才被标记为执行成功，否则标记为执行失败。</li></ul><p>图1来自<code>gitlab</code>官网，阐述了<code>gitlab-ci</code>的一个典型工作流程。使用<code>gitlab</code>作为代码托管工具，你不需要额外的第三方<code>ci/cd</code>软件，并且，它提供整个流程的可视化界面。</p><p><img src="https://raw.githubusercontent.com/qqzeng/qqzeng.github.io/hexo/static/install-runner-in-k8s/gitlab_workflow_example_11_9.png" alt="gitlab workflow example"></p><p>图1 <code>gitlab workflow example</code></p><p>下面的<code>.gitlab-ci.yml</code>模板文件同样来自<a href="https://gitlab.com/gitlab-examples/spring-gitlab-cf-deploy-demo" target="_blank" rel="noopener"><code>gitlab</code>官网</a>，它是依赖<code>spring boot</code>的<code>java</code>应用服务的一个<code>.gitlab-ci.yml</code>示例。没有任何复杂的内容，整个<code>pipeline</code>中包含<code>test</code>和<code>build</code>两个<code>stage</code>。在全局<code>before_script</code>所定义的脚本会在所有<code>stage</code>执行之前被执行，<code>artifacts</code>表示此<code>stage</code>会生成一个<code>artifact</code>（比如一个<code>war</code>包或者可执行文件），最后<code>only</code>表示只会在对应的分支下执行。因此，当你将此<code>.gitlab-ci.yml</code>文件放到你的项目的根目录时，则表示此项目的<code>gitlab-ci</code>的功能已经开启，当你往版本库中<code>push</code>代码时，你会看到它会起作用了——自动执行你在<code>.gitlab-ci.yml</code>中定义的脚本（前提是你已经安装好了<code>gitlab</code>和<code>gitlab runner</code>，且将<code>runner</code>注册到了<code>gitlab</code>仓库中对应的项目，这会在后面提及）。你可以在<a href="https://gitlab.com/gitlab-examples" target="_blank" rel="noopener">这里</a>找到更多的<code>.gitlab-ci.yml</code>示例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">image: java:8</span><br><span class="line"></span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - deploy</span><br><span class="line">  </span><br><span class="line">before_script:</span><br><span class="line">  - chmod +x mvnw</span><br><span class="line">  </span><br><span class="line">build:</span><br><span class="line">  stage: build</span><br><span class="line">  script: ./mvnw package</span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">      - target/demo-0.0.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">production:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script:</span><br><span class="line">  - curl --location "https://cli.run.pivotal.io/stable?release=linux64-binary&amp;source=github" | tar zx</span><br><span class="line">  - ./cf login -u $CF_USERNAME -p $CF_PASSWORD -a api.run.pivotal.io</span><br><span class="line">  - ./cf push</span><br><span class="line">  only:</span><br><span class="line">  - master</span><br></pre></td></tr></table></figure><h2 id="gitlab-runner-相关知识"><a href="#gitlab-runner-相关知识" class="headerlink" title="gitlab runner 相关知识"></a>gitlab runner 相关知识</h2><p>当你读完上节内容中一个示例后，你会想你在<code>.gitlab-ci.yml</code>中定义的脚本到底是在哪里执行的，换言之，是什么提供了你执行这些<code>stage</code>的资源。是的，这就是<code>gitlab runner</code>所做的。它会同<code>gitlab-ci</code>协同工作，<code>gitlab runner</code>用于运行<code>stage</code>中定义的<code>job</code>（<code>job</code>是<code>runner</code>执行的最小单位）。在阐述<code>runner</code>在<code>k8s</code>中的安装流程之前，让我们先来了解下<code>gitlab runner</code>的基本知识。</p><p>当你<a href="https://docs.gitlab.com/runner/#install-gitlab-runner" target="_blank" rel="noopener">安装<code>gitlab runner</code></a>并<a href="https://docs.gitlab.com/runner/register/" target="_blank" rel="noopener">将它注册到某个项目</a>后（当然你可以使用<code>shared runner</code>，在这种情况下，此<code>runner</code>就不会隶属于某个项目，而是被一组或所有的项目所共享使用），你可以使用它来执行你在<code>.gitlab-ci.yml</code>中定义的<code>job</code>，只要<code>runner</code>能够访问<code>gitlab server</code>所在的网络，则<code>gitlab</code>和<code>runner</code>就能通过<code>api</code>进行网络通信，准确而言，是<code>runner</code>会定期轮询<code>gitlab server</code>是否有等待被执行的<code>pipeline</code>。从本质上而言，<code>runner</code>只是一个使用<code>go</code>语言编写的进程，当利用它来执行<code>.gitlab-ci.yml</code>中定义的<code>pipeline</code>时，它会<code>clone</code>对应的项目，然后执行你预定义在<code>job</code>中的脚本。</p><p>前面提到，当多个项目共享同一个<code>runner</code>时，则称此<code>runner</code>为<code>shared runner</code>，且理想状况下，<code>runner</code>不应该同<code>gitlab server</code>安装在同一台机器上，这会影响<code>gitlab</code>的正常工作。且<code>gitlab admin</code>只能注册<code>shared runner</code>。具体而言，<code>runner</code>主要包括如下三种：</p><ul><li><code>shared runner</code>，它主要服务于多个项目中具有类似需求的<code>job</code>，显然，使用<code>shared runner</code>可以不需要为每一个项目配置单独的<code>runner</code>，且通常来说，<code>shared runner</code>与项目是多对多的关系，类似于资源池。<code>shared runner</code>采用<a href="https://docs.gitlab.com/ee/ci/runners/README.html#how-shared-runners-pick-jobs" target="_blank" rel="noopener"><code>fair useage queue</code></a>来调度<code>job</code>，这可以防止某个项目由于定义了过多的<code>job</code>而独占整个可用的<code>shared runner</code>集合。</li><li><code>specific runner</code>，它主要服务于具有特殊需求的项目，通常会结合<code>tag</code>来将<code>specific runner</code>与项目进行绑定，<code>specific runner</code>采用<code>FIFO</code>的方式调度<code>job</code>。值得注意的是，<code>specific runner</code>也可服务于多个项目，只是你需要显式的为每个项目<code>enable</code>它们。</li><li><code>group runner</code>，定义在<code>group runner</code>集合中的<code>runner</code>会服务于一组项目，与<code>shared runner</code>不同的是，它也采用的是<code>FIFO</code>的方式来调度<code>job</code>，这意味着一个定义了较多<code>job</code>的项目可能会长时间独占所有<code>runner</code>。</li></ul><p>最后，通过一个示例来简要阐述<code>shared runner</code>是如何调度<code>job</code>的，即<code>fair useage queue</code>的原理，这些内容基本来自于<a href="https://docs.gitlab.com/ee/ci/runners/README.html#how-shared-runners-pick-jobs" target="_blank" rel="noopener">官方文档</a>。示例如下：若我们为<code>project 1</code>定义了3个<code>job</code>，为<code>project 2</code>定义了2个<code>job</code>，为<code>project 3</code>定义了1个<code>job</code>，则一个典型的调度流程如下：首选会调度<code>p1-j1(job 1 of project 1)</code>，因为此时它是所有不存在正运行的<code>job</code>的项目中编号最小的<code>job</code>，这句话很重要。然后调度<code>p2-j4</code>，因为此时<code>porject 1</code>有一个正运行的作业<code>job 1</code>。再调度<code>p3-j6</code>，原因是类似的。其次，调度<code>p1-j2</code>，因为它是存在正在运行<code>job</code>的项目中，包含最少运行的<code>job</code>数（每个项目都有1个）的项目的尚未运行的<code>job</code>的编号。接下来的调度依次是<code>p2-j5</code>、<code>p1-j3</code>。需要注意的是，上面描述的调度顺序的前提是每个被调度的<code>job</code>都一直处于运行状态。因为，若当我们调度<code>p1-j1</code>时，它立刻完成了，则下一个调度的<code>job</code>则仍然从<code>project 1</code>中挑选，即为<code>p1-j2</code>。因此，总结一下，当调度<code>job</code>时，首先看哪个<code>project</code>存在最少的处于运行状态的<code>job</code>数量，然后在此<code>project</code>中选择尚未运行的<code>job</code>集合中编号最小的<code>job</code>。</p><p>此小节阐述了<code>gitlab runner</code>的基本原理，以及不同类型的<code>runner</code>的适用情形，同时通过一个示例来阐述<code>shared runner</code>是如何调度<code>job</code>的。更多详细内容可参考<a href="https://docs.gitlab.com/ee/ci/runners/README.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="k8s-中安装gitlab-runner-的详细流程"><a href="#k8s-中安装gitlab-runner-的详细流程" class="headerlink" title="k8s 中安装gitlab runner 的详细流程"></a>k8s 中安装<code>gitlab runner</code> 的详细流程</h2><p>本小节侧重实践，详细阐述在<code>k8s</code>中安装<code>gitlab runner</code>的整个过程。其中，<code>gitlab</code>的版本是<code>GitLab Community Edition 9.4.2</code>，<code>minikube</code>的版本是<code>v1.2.0</code>，<code>Kubernetes</code>的版本是<code>v1.15.0</code>，最后<code>Docker</code>的版本是<code>18.09.6</code>。具体而言，主要包括两个方面的内容：一是<code>minikube</code>安装的注意事项，其次是在<code>k8s</code>中部署<code>gitlab runner</code>的详细流程。基本都是参考官方文档。</p><h3 id="minikube-安装注意事项"><a href="#minikube-安装注意事项" class="headerlink" title="minikube 安装注意事项"></a>minikube 安装注意事项</h3><p>需要说明的是，在这之前你应该有一个<code>kubernetes</code>集群，笔者的实验环境是<code>VMware® Workstation 15 Pro</code>安装<code>ubuntu18.04 desktop</code>系统，然后搭建了<code>minikube</code>（单节点）的<code>k8s</code>环境，<code>vm driver</code>采用的是<code>kvm2</code>。</p><blockquote><p>笔者之前尝试过<code>virtualbox hypervisor</code>，并以<code>virtualbox</code>和<code>kvm2</code>作为<code>vm driver</code>，但都没有成功。简单说，<code>virtualbox hypervisor</code>不支持对硬件的虚拟化。相关的<code>issue</code>可以看<a href="https://github.com/kubernetes/minikube/issues/4348" target="_blank" rel="noopener">这里</a>和<a href="https://github.com/kubernetes/minikube/issues/2991" target="_blank" rel="noopener">这里</a>，<code>virtualbox</code>官方一个相关说明，在<a href="https://www.virtualbox.org/ticket/4032" target="_blank" rel="noopener">这里</a>。如果有读者在<code>virtualbox hypervisor</code>下成功安装<code>kvm2</code>或<code>virtual</code>作为<code>vm driver</code>，还请留言。</p></blockquote><p>关于<code>minikube</code>的安装，直接参考<a href="https://kubernetes.io/docs/tasks/tools/install-minikube/" target="_blank" rel="noopener">官方文档</a>即可。但需要注意GFW，若不能上外网，可以尝试通过拉取国内镜像源来安装，参考<a href="https://yq.aliyun.com/articles/221687" target="_blank" rel="noopener">这里</a>。另外一个在安装前需要关注的操作是：<code>egrep --color &#39;vmx|svm&#39; /proc/cpuinfo</code>，必须确保此命令的输出不为空，否则，表明你的系统不支持虚拟化。安装完之后，可以执行一个<code>hello world</code>，参考<a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">这里</a>，以确认<code>minkube</code>已经成功安装。</p><h3 id="k8s-中安装gitlab-runner"><a href="#k8s-中安装gitlab-runner" class="headerlink" title="k8s 中安装gitlab runner"></a>k8s 中安装<code>gitlab runner</code></h3><p>前述提到<code>gitlab runner</code>只是一个使用<code>go</code>编写的程序。因此，理论上在任何安装了<code>go</code>的环境都能安装<code>gitlab runner</code>，不仅仅局限于<code>k8s</code>的环境，详解可参考<a href="https://docs.gitlab.com/runner/install/" target="_blank" rel="noopener">这里</a>。但若将<code>runner</code>安装在<code>k8s</code>中，其原理与其它方式还是略有区别，这个在后面阐述。另外，在前一小节中提到，<code>runner</code>会周期性的轮询<code>gitlab server</code>以确认当前是否有需要执行的<code>pipeline</code>，换言之，<code>runner</code>是可以安装在你本地环境的（不需要一个外网能够访问的ip），但<code>gitlab server</code>若安装在本地环境（主机或<code>docker</code>），你要确保它能够被<code>runner</code>访问到。</p><p>官方提供的在<code>k8s</code>安装<code>runner</code>的<a href="https://docs.gitlab.com/runner/install/kubernetes.html" target="_blank" rel="noopener">最新教程</a>采用了<a href="https://helm.sh/docs/" target="_blank" rel="noopener"><code>helm</code></a>，因此，在安装<code>runner</code>前需要提前在<code>k8s</code>集群中安装<code>helm</code>。简单而言，<code>helm</code>是一个在<code>k8s</code>环境下的软件包管理工具，类似于<code>ubuntu</code>下的<code>apt-get</code>或<code>centos</code>下的<code>yum</code>。<code>helm</code>会为我们管理一个软件包所包含的一系列配置文件，通过使用<code>helm</code>，应用发布者可以很方便地打包(<code>pakcage</code>)应用、管理应用依赖关系和应用版本，并将其发布应用到软件仓库。另外，<code>helm</code>还提供了<code>k8s</code>上的软件部署和卸载、应用回滚等高阶功能。<code>helm</code>是一个典型的<code>cs</code>架构，为了让<code>helm</code>帮助我们管理<code>k8s</code>中的软件包，它会将<code>tiller server</code>安装在<code>k8s</code>集群中，然后使用<code>helm client</code>与之通信来完成指定功能。在<code>helm</code>安装过程中，需要注意的就是<code>helm</code>的权限(<code>RBAC</code>)的配置，在笔者的实验中，为了方便测试，给予了<code>tiller</code>这个<code>ServiceAccount</code>的<code>role</code>为<code>cluster-admin</code>。图2为<code>helm</code>的相关安装配置。更多关于<code>helm</code>的中文资料可以参考<a href="https://zhaohuabing.com/2018/04/16/using-helm-to-deploy-to-kubernetes/" target="_blank" rel="noopener">这里</a>和<a href="https://whmzsu.github.io/helm-doc-zh-cn/quickstart/install-zh_cn.html" target="_blank" rel="noopener">这里</a>。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/install-runner-in-k8s/tiller.jpg" alt="helm"></p><p>图2 <code>k8s</code>中安装<code>helm</code>的相关配置</p><p>事实上，所谓的在<code>k8s</code>中安装<code>gitlab runner</code>，也就是将<code>gitlab runner</code>这个<code>helm chart</code>包安装在<code>k8s</code>中，<code>runner</code>具体是使用<code>kubernetes executor</code>执行<code>job</code>，<code>executor</code>会连接到<code>k8s</code>集群中的<code>kubernetes API</code>，并为每个<code>job</code>创建一个<code>pod</code>。<code>pod</code>是<code>k8s</code>中应用编排的最小单元（不是<code>container</code>），相当于一个逻辑/虚拟机主机，它包含了一组共享资源的<code>contaienr</code>，这些<code>container</code>共享相同的<code>network namespace</code>，可通过<code>localhost</code>通信，另外，这些<code>container</code>可声明共享同一个<code>volume</code>。通常而言，为<code>gitlab-ci</code>的每个<code>job</code>动态创建的<code>pod</code>至少包含两个<code>container</code>（也有三个的情况），分别是<code>build container</code>和<code>service container</code>，其中<code>build container</code>即用于构建<code>job</code>，而当在<code>.gitlab-ci.yml</code>中定义了<a href="https://docs.gitlab.com/ce/ci/yaml/README.html#services" target="_blank" rel="noopener"><code>service</code>标签</a>时，就会此<code>service container</code>来运行对应的<code>service</code>，以连接到<code>build container</code>，并协助它完成指定功能。这同<code>docker</code>中的<a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/" target="_blank" rel="noopener"><code>link container</code></a>原理类似。最后，当使用<code>docker/docker+machine/kubernetes</code>的<code>executors</code>时，<code>gitlab runner</code>会使用基于<a href="https://docs.gitlab.com/runner/configuration/advanced-configuration.html#helper-image" target="_blank" rel="noopener"><code>helper image</code></a>的<code>help container</code>，它的使用是处理<code>git</code>、<code>artifacts</code>以及<code>cache</code>相关操作。它包含了<code>gitlab-runner-helper</code>二进制包，提供了<code>git</code>、<code>git-lfs</code>、<code>SSL certificates store</code>等命令。但当使用<code>kubernetes executor</code>时，<code>runner</code>会临时从<code>gitlab/gitlab-runner-helper</code>下载镜像而并非从本地的归档文件中加载此二进制文件。</p><p>现在可以执行正式的安装操作了。安装之前，通常我们需要配置<code>runner</code>，这通过在<a href="https://gitlab.com/charts/gitlab-runner/blob/master/values.yaml" target="_blank" rel="noopener"><code>values.yaml</code></a>中自定义特定选项来实现，以覆盖默认选项值。配置过程也较为简单，唯一必须配置的选项是<code>gitlabUrl</code>和<code>runnerRegistrationToken</code>，前者即为<code>gitlab server</code>的<code>url</code>，它可以是一个完整域名（如<code>https://example.gitlab.com</code>），也可以是一个<code>ip</code>地址（记得不要漏掉端口号），而后者则为你的<code>gitlab</code>的<code>token</code>，以表明你具备向<code>gitlab</code>添加<code>runner</code>的权限。这两个值可以从<code>gitlab-project-settings-pipelines</code>下获取到（注意因为笔者的<code>gitlab</code>帐户只是普通帐户，意味着只能注册<code>specific runner</code>，它与<code>admin</code>的稍有不同）。图3显示了这两个选项参数。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/install-runner-in-k8s/gitlab-url-token.jpg" alt="gitlaburl and token"></p><p>图3 <code>runner</code>所需的<code>gitlabUrl</code>和<code>token</code>参数</p><p>确认了这两个最核心的配置选项后，如果你不需要覆盖其它的默认选项值，就可以开始<a href="https://docs.gitlab.com/runner/install/kubernetes.html#installing-gitlab-runner-using-the-helm-chart" target="_blank" rel="noopener">安装</a>了，非常简单。仅有两个步骤：</p><p>其一，将<code>gitlab</code>这个<code>repository</code>添加到<code>helm repository list</code>中。执行下面的命令即可：<br><code>helm repo add gitlab https://charts.gitlab.io</code><br>其二，使用<code>helm</code>来安装<code>gitlab runner chart</code>，如下：<br><code>helm install --namespace &lt;NAMESPACE&gt; --name gitlab-runner -f &lt;CONFIG_VALUES_FILE&gt; gitlab/gitlab-runner</code><br>其中<code>&lt;NAMESPACE&gt;</code>指定了你需要将<code>runner</code>安装在哪个<code>namespace</code>，因为，你很可能需要预先创建此<code>namespace</code>，这通过<code>kubectl create namespace &lt;NAMESPACE&gt;</code>命令来实现。而后一个参数则为你定义的<code>values.yml</code>配置文件的路径。</p><p>附带介绍下，另外两个重要的操作——<code>gitlab runner</code>的升级以及卸载操作。升级操作同安装操作非常类似，<code>&lt;RELEASE-NAME&gt;</code>即为<code>gitlab runner</code>，<code>release</code>是<code>helm</code>的概念，表示安装在<code>k8s</code>中的一个软件：<br><code>helm upgrade --namespace &lt;NAMESPACE&gt; -f &lt;CONFIG_VALUES_FILE&gt; &lt;RELEASE-NAME&gt; gitlab/gitlab-runner</code></p><p>最后的卸载操作可通过如下命令实现：<br><code>helm delete --namespace &lt;NAMESPACE&gt; &lt;RELEASE-NAME&gt;</code><br>值得注意的是，即使执行了此卸载操作，<code>helm</code>仍然保留已删除<code>release</code>的记录，这允许你回滚已删除的资源并重新激活它们。若要彻底删除，可以加上<code>--purge</code>选项。</p><p>至此，最简版本的<code>gitlab runner</code>已经安装完毕。当执行<code>helm install</code>命令后，它会打印出此次安装所涉及的对象资源，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">NAME:   gitlab-runner</span><br><span class="line">LAST DEPLOYED: Fri Jul  5 11:06:30 2019</span><br><span class="line">NAMESPACE: kube-gitlab-test</span><br><span class="line">STATUS: DEPLOYED</span><br><span class="line"></span><br><span class="line">RESOURCES:</span><br><span class="line">==&gt; v1/ConfigMap</span><br><span class="line">NAME                         DATA  AGE</span><br><span class="line">gitlab-runner-gitlab-runner  5     0s</span><br><span class="line"></span><br><span class="line">==&gt; v1/Pod(related)</span><br><span class="line">NAME                                          READY  STATUS    RESTARTS  AGE</span><br><span class="line">gitlab-runner-gitlab-runner-6f996b5464-8wwnz  0/1    Init:0/1  0         0s</span><br><span class="line"></span><br><span class="line">==&gt; v1/Secret</span><br><span class="line">NAME                         TYPE    DATA  AGE</span><br><span class="line">gitlab-runner-gitlab-runner  Opaque  2     0s</span><br><span class="line"></span><br><span class="line">==&gt; v1/ServiceAccount</span><br><span class="line">NAME                         SECRETS  AGE</span><br><span class="line">gitlab-runner-gitlab-runner  1        0s</span><br><span class="line"></span><br><span class="line">==&gt; v1beta1/Deployment</span><br><span class="line">NAME                         READY  UP-TO-DATE  AVAILABLE  AGE</span><br><span class="line">gitlab-runner-gitlab-runner  0/1    1           0          0s</span><br><span class="line"></span><br><span class="line">==&gt; v1beta1/Role</span><br><span class="line">NAME                         AGE</span><br><span class="line">gitlab-runner-gitlab-runner  0s</span><br><span class="line"></span><br><span class="line">==&gt; v1beta1/RoleBinding</span><br><span class="line">NAME                         AGE</span><br><span class="line">gitlab-runner-gitlab-runner  0s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line"></span><br><span class="line">Your GitLab Runner should now be registered against the GitLab instance reachable at: &quot;http://*******/&quot;</span><br></pre></td></tr></table></figure><p>你也可以执行如图4中的命令，以确认是否安装成功，甚至使用<code>-o yaml</code>选项来查看各对象配置的详细内容。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/install-runner-in-k8s/gitlab-runner.jpg" alt="gitlab runner install result"></p><p>图4 <code>k8s</code>中安装的<code>gitlab ruuner</code>详情</p><p>安装成功后，如图5所示，我们可以到<code>gitlab</code>管理上查看已经有一个<code>runner</code>实例可供特定的项目使用了，记得在这之前先在<code>gitlab</code>上创建一个示例项目，不然，你可能找不到此页面的位置。</p><p><img src="https://github.com/qqzeng/qqzeng.github.io/raw/hexo/static/install-runner-in-k8s/gitlab-runner-list.jpg" alt="gitlab runner list"></p><p>图5 <code>gitlab</code> 特定项目所关联的 <code>runner</code> 列表</p><p>在本小节的最后，我们来看一下<code>values.yml</code>文件中定义的核心配置选项。其它的配置在下一小节阐述。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## The GitLab Server URL (with protocol) that want to register the runner against</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/commands/README.html#gitlab-runner-register</span></span><br><span class="line"><span class="comment">## gitlab server 的地址</span></span><br><span class="line"><span class="attr">gitlabUrl:</span> <span class="attr">https://gitlab.example.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## The registration token for adding new Runners to the GitLab server. This must</span></span><br><span class="line"><span class="comment">## be retrieved from your GitLab instance.</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/ee/ci/runners/</span></span><br><span class="line"><span class="comment">## 向 gitlab server 添加 runner 的令牌</span></span><br><span class="line"><span class="attr">runnerRegistrationToken:</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Set the certsSecretName in order to pass custom certificates for GitLab Runner to use</span></span><br><span class="line"><span class="comment">## Provide resource name for a Kubernetes Secret Object in the same namespace,</span></span><br><span class="line"><span class="comment">## this is used to populate the /etc/gitlab-runner/certs directory</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/tls-self-signed.html#supported-options-for-self-signed-certificates</span></span><br><span class="line"><span class="comment">## 当需要向 gitlab runner 提供自定义证书时，可在此附上证书对应的secret名称</span></span><br><span class="line"><span class="comment">##（secret 需提前安装在k8s）</span></span><br><span class="line"><span class="comment">#certsSecretName:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure the maximum number of concurrent jobs</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section</span></span><br><span class="line"><span class="comment">## 使用所有注册的 runner 能并行执行的 job 数量的上限，0 表示不限制</span></span><br><span class="line"><span class="attr">concurrent:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Defines in seconds how often to check GitLab for a new builds</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section</span></span><br><span class="line"><span class="comment">## runner 轮询 gitlab server 来查询是否有待执行的 pipeline 的间隔时间/s</span></span><br><span class="line"><span class="attr">checkInterval:</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## For RBAC support:</span></span><br><span class="line"><span class="comment">## runner 的 RBAs 权限配置（RBAC是kubernetes 1.6版本默认使用的权限机制）。</span></span><br><span class="line"><span class="comment">## 若你想 helm 为你创建对应角色、权限及角色绑定，则设置为 true，否则若你已额外创建，则设置为false</span></span><br><span class="line"><span class="attr">rbac:</span></span><br><span class="line"><span class="attr">  create:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Run the gitlab-bastion container with the ability to deploy/manage containers of jobs</span></span><br><span class="line">  <span class="comment">## cluster-wide or only within namespace</span></span><br><span class="line">  <span class="comment">## false 表示创建的角色是隶属于某个 namespace,反之属于 cluster 范围内，后者权限更大</span></span><br><span class="line"><span class="attr">  clusterWideAccess:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## If RBAC is disabled in this Helm chart, use the following Kubernetes Service Account name.</span></span><br><span class="line">  <span class="comment">## 若你额外创建了 RBAC 相关配置，则在这里指定 ServiceAccount 的名称</span></span><br><span class="line">  <span class="comment">## default 是每个 namespace 中自带的一个帐户，但其拥有的角色可能不具备执行某些操作的权限</span></span><br><span class="line">  <span class="comment"># serviceAccountName: default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configuration for the Pods that the runner launches for each new job</span></span><br><span class="line"><span class="comment">## 配置 runner 为每一个 job 动态创建的 pod</span></span><br><span class="line"><span class="attr">runners:</span></span><br><span class="line">  <span class="comment">## Default container image to use for builds when none is specified</span></span><br><span class="line">  <span class="comment">## 基础容器所使用的镜像</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">ubuntu:18.04</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Run all containers with the privileged flag enabled</span></span><br><span class="line">  <span class="comment">## This will allow the docker:stable-dind image to run if you need to run Docker</span></span><br><span class="line">  <span class="comment">## commands. Please read the docs before turning this on:</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/executors/kubernetes.html#using-docker-dind</span></span><br><span class="line">  <span class="comment">## 这个选项对于 ci/cd 应用场景至关重要。简单而言，true 表示启用 pod 中容器的特权，</span></span><br><span class="line">  <span class="comment">## 此时，容器几乎具有容器外运行在宿主机的进程完全相同的权限，可以访问所有的设备，存在一定风险</span></span><br><span class="line">  <span class="comment">## 但是开启此选项是实现 docker-in-docker 的前提，后面会详细阐述 dind</span></span><br><span class="line"><span class="attr">  privileged:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Namespace to run Kubernetes jobs in (defaults to 'default')</span></span><br><span class="line">  <span class="comment">## 配置 runner 为每个 job 创建的 pod 所运行的 namespace</span></span><br><span class="line">  <span class="comment"># namespace:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Build Container specific configuration</span></span><br><span class="line">  <span class="comment">## build 容器，用作 stage 中的基础容器</span></span><br><span class="line"><span class="attr">  builds:</span></span><br><span class="line">    <span class="comment"># cpuLimit: 200m</span></span><br><span class="line">    <span class="comment"># memoryLimit: 256Mi</span></span><br><span class="line"><span class="attr">    cpuRequests:</span> <span class="number">100</span><span class="string">m</span> <span class="comment"># 基础 cpu 占用量，表示 0.1 的cpu，m 表示 Milli 毫</span></span><br><span class="line"><span class="attr">    memoryRequests:</span> <span class="number">128</span><span class="string">Mi</span> <span class="comment"># 基础内存占用量，表示 128M 的内存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Service Container specific configuration</span></span><br><span class="line">  <span class="comment">## service 容器，通过 link build 容器，以协助 build 容器完成特定功能</span></span><br><span class="line"><span class="attr">  services:</span></span><br><span class="line">    <span class="comment"># cpuLimit: 200m</span></span><br><span class="line">    <span class="comment"># memoryLimit: 256Mi</span></span><br><span class="line"><span class="attr">    cpuRequests:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">    memoryRequests:</span> <span class="number">128</span><span class="string">Mi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Helper Container specific configuration</span></span><br><span class="line">  <span class="comment">## helper 容器，用于执行 git, git-lfs, SSL certificates store 等命令</span></span><br><span class="line"><span class="attr">  helpers:</span></span><br><span class="line">    <span class="comment"># cpuLimit: 200m</span></span><br><span class="line">    <span class="comment"># memoryLimit: 256Mi</span></span><br><span class="line"><span class="attr">    cpuRequests:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">    memoryRequests:</span> <span class="number">128</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure><p>至此，关于在<code>k8s</code>中安装<code>gitlab runner</code>的完整流程已经阐述完毕。事实上，后面的版本中使用<code>helm</code>来安装<code>gitlab runner</code>是非常便捷的。但同时，它也向我们隐藏了相关的配置细节，为了更好的理解<code>runner</code>在<code>k8s</code>中的运行原理，有必要详细了解相关的配置文件。最后，值得注意的是，<code>runner</code>使用<code>kubernetes executor</code>的原理也是值得关注的。</p><h2 id="gitlab-runner-配置详解"><a href="#gitlab-runner-配置详解" class="headerlink" title="gitlab runner 配置详解"></a>gitlab runner 配置详解</h2><p>为了进一步理解<code>gitlab ruuner</code>的相关原理，本小节会详细解读有关其<a href><code>value.yml</code></a>配置选项，在正式的生产环境中，我们可能需要自定义其中的大部分的配置选项的值。其中，核心配置选项已在上一节中详细阐述。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## GitLab Runner Image</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## ref: https://hub.docker.com/r/gitlab/gitlab-runner/tags/</span></span><br><span class="line"><span class="comment">## gitlab runner 的默认镜像</span></span><br><span class="line"><span class="comment"># image: gitlab/gitlab-runner:alpine-v11.6.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images</span></span><br><span class="line"><span class="comment">## gitlab runner 镜像的拉取策略，Never/IfNotPresent/Always</span></span><br><span class="line"><span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/commands/README.html#gitlab-runner-register</span></span><br><span class="line"><span class="comment">## gitlab server 的地址</span></span><br><span class="line"><span class="comment"># gitlabUrl: http://gitlab.your-domain.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/ce/ci/runners/README.html</span></span><br><span class="line"><span class="comment">## 向 gitlab server 添加 runner 的令牌</span></span><br><span class="line"><span class="comment"># runnerRegistrationToken: ""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## The Runner Token for adding new Runners to the GitLab Server. This must</span></span><br><span class="line"><span class="comment">## be retrieved from your GitLab Instance. It is token of already registered runner.</span></span><br><span class="line"><span class="comment">## ref: (we don't yet have docs for that, but we want to use existing token)</span></span><br><span class="line"><span class="comment">## 已注册的 runner 的token。不是特别清楚此选项的意义，感觉同上一个选项类似</span></span><br><span class="line"><span class="comment"># runnerToken: ""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/commands/README.html#gitlab-runner-unregister</span></span><br><span class="line"><span class="comment">## 当 runner 被重新创建时，会导致 gitlab server 引用一个不存在的 runner，因此，开启此选项表示在</span></span><br><span class="line"><span class="comment">## runner 关闭时会自动从 gitlab server 取消注册</span></span><br><span class="line"><span class="attr">unregisterRunners:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/tls-self-signed.html#supported-options-for-self-signed-certificates</span></span><br><span class="line"><span class="comment">## 当需要向 gitlab runner 提供自定义证书时，可在此附上证书对应的secret名称</span></span><br><span class="line"><span class="comment">##（secret 需提前安装在k8s）</span></span><br><span class="line"><span class="comment"># certsSecretName:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section</span></span><br><span class="line"><span class="comment">## 使用所有注册的 runner 能并行执行的 job 数量的上限，0 表示不限制</span></span><br><span class="line"><span class="attr">concurrent:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section</span></span><br><span class="line"><span class="comment">## runner 轮询 gitlab server 来查询是否有待执行的 pipeline 的间隔时间/s</span></span><br><span class="line"><span class="attr">checkInterval:</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section</span></span><br><span class="line"><span class="comment">## gitlab runner 的日志级别</span></span><br><span class="line"><span class="comment"># logLevel:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## runner 的 RBAs 权限配置（RBAC是kubernetes 1.6版本默认使用的权限机制）。</span></span><br><span class="line"><span class="comment">## 若你想 helm 为你创建对应角色、权限及角色绑定，则设置为 true，否则若你已额外创建，则设置为false</span></span><br><span class="line"><span class="attr">rbac:</span></span><br><span class="line"><span class="attr">  create:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## false 表示创建的角色是隶属于某个 namespace,反之属于 cluster 范围内，后者权限更大</span></span><br><span class="line"><span class="attr">  clusterWideAccess:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## 若你额外创建了 RBAC 相关配置，则在这里指定 ServiceAccount 的名称</span></span><br><span class="line">  <span class="comment">## default 是每个 namespace 中自带的一个帐户，但其拥有的角色可能不具备执行某些操作的权限</span></span><br><span class="line">  <span class="comment"># serviceAccountName: default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/monitoring/#configuration-of-the-metrics-http-server</span></span><br><span class="line"><span class="comment">## 是否开启 metric 数据记录器，使用的是 Prometheus metrics exporter</span></span><br><span class="line"><span class="attr">metrics:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 配置 runner 为每一个 job 动态创建的 pod 相关选项</span></span><br><span class="line"><span class="attr">runners:</span></span><br><span class="line">  <span class="comment">## 基础容器(build container)默认使用的镜像</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">ubuntu:18.04</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/</span></span><br><span class="line">  <span class="comment">## 当从私有 registry 拉取镜像时，需要预先在 k8s 中创建对应的 secret，并在这里填写对应的 secret</span></span><br><span class="line">  <span class="comment"># imagePullSecrets: []</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## 镜像拉取策略，Never/IfNotPresent/Always</span></span><br><span class="line">  <span class="comment"># imagePullPolicy: ""</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Defines number of concurrent requests for new job from GitLab</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runners-section</span></span><br><span class="line">  <span class="comment">## gitlab-ci 能够并发请求的 job 数量</span></span><br><span class="line">  <span class="comment"># requestConcurrency: 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## 此 runner 是否与特定项目绑定</span></span><br><span class="line">  <span class="comment"># locked: true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/ce/ci/runners/#using-tags</span></span><br><span class="line">  <span class="comment">## runner 所运行的 pod 所关联的 tag</span></span><br><span class="line">  <span class="comment"># tags: ""</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/executors/kubernetes.html#using-docker-dind</span></span><br><span class="line">  <span class="comment">## 这个选项对于 ci/cd 应用场景至关重要。简单而言，true 表示启用 pod 中容器的特权，</span></span><br><span class="line">  <span class="comment">## 此时，容器几乎具有容器外运行在宿主机的进程完全相同的权限，可以访问所有的设备，存在一定风险</span></span><br><span class="line">  <span class="comment">## 但是开启此选项是实现 docker-in-docker 的前提，后面会详细阐述 dind</span></span><br><span class="line"><span class="attr">  privileged:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># gitlab runner 为 runner-token and runner-registration-token 创建的 secret 的名称</span></span><br><span class="line">  <span class="comment"># secret: gitlab-runner</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## 配置 runner 为每个 job 创建的 pod 所运行的 namespace</span></span><br><span class="line">  <span class="comment"># namespace:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## ref: https://gitlab.com/gitlab-org/gitlab-runner/blob/master/docs/configuration/autoscale.md#distributed-runners-caching</span></span><br><span class="line">  <span class="comment">## 分布式 runner 缓存相关的配置，这里暂且忽略</span></span><br><span class="line"><span class="attr">  cache:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">    <span class="comment">## General settings</span></span><br><span class="line">    <span class="comment"># cacheType: s3</span></span><br><span class="line">    <span class="comment"># cachePath: "gitlab_runner"</span></span><br><span class="line">    <span class="comment"># cacheShared: true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## S3 settings</span></span><br><span class="line">    <span class="comment"># s3ServerAddress: s3.amazonaws.com</span></span><br><span class="line">    <span class="comment"># s3BucketName:</span></span><br><span class="line">    <span class="comment"># s3BucketLocation:</span></span><br><span class="line">    <span class="comment"># s3CacheInsecure: false</span></span><br><span class="line">    <span class="comment"># secretName: s3access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## GCS settings</span></span><br><span class="line">    <span class="comment"># gcsBucketName:</span></span><br><span class="line">    <span class="comment">## Use this line for access using access-id and private-key</span></span><br><span class="line">    <span class="comment"># secretName: gcsaccess</span></span><br><span class="line">    <span class="comment">## Use this line for access using google-application-credentials file</span></span><br><span class="line">    <span class="comment"># secretName: google-application-credentials</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## build 容器，用作 stage 中的基础容器</span></span><br><span class="line"><span class="attr">  builds:</span></span><br><span class="line">    <span class="comment"># cpuLimit: 200m</span></span><br><span class="line">    <span class="comment"># memoryLimit: 256Mi</span></span><br><span class="line"><span class="attr">    cpuRequests:</span> <span class="number">100</span><span class="string">m</span> <span class="comment"># 基础 cpu 占用量，表示 0.1 的cpu，m 表示 Milli 毫</span></span><br><span class="line"><span class="attr">    memoryRequests:</span> <span class="number">128</span><span class="string">Mi</span> <span class="comment"># 基础内存占用量，表示 128M 的内存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## service 容器，通过 link build 容器，以协助 build 容器完成特定功能</span></span><br><span class="line"><span class="attr">  services:</span></span><br><span class="line">    <span class="comment"># cpuLimit: 200m</span></span><br><span class="line">    <span class="comment"># memoryLimit: 256Mi</span></span><br><span class="line"><span class="attr">    cpuRequests:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">    memoryRequests:</span> <span class="number">128</span><span class="string">Mi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## helper 容器，用于执行 git, git-lfs, SSL certificates store 等命令</span></span><br><span class="line"><span class="attr">  helpers:</span></span><br><span class="line">    <span class="comment"># cpuLimit: 200m</span></span><br><span class="line">    <span class="comment"># memoryLimit: 256Mi</span></span><br><span class="line"><span class="attr">    cpuRequests:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">    memoryRequests:</span> <span class="number">128</span><span class="string">Mi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## runner 动态创建的 pod 所关联的 ServiceAccount 的名称，它可能需要被赋予特定角色</span></span><br><span class="line">  <span class="comment"># serviceAccountName:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## If Gitlab is not reachable through $CI_SERVER_URL</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># cloneUrl:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/</span></span><br><span class="line">  <span class="comment">## 限制 gitlab-ci 的 pod 只能被调度在指定 node 上</span></span><br><span class="line">  <span class="comment"># nodeSelector: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## 指定 gitlab-ci 的 pod 所包含的 labels</span></span><br><span class="line">  <span class="comment"># podLabels: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## 指定 gitlab-ci 的 pod 所包含的 annotations</span></span><br><span class="line">  <span class="comment"># podAnnotations: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/commands/#gitlab-runner-register</span></span><br><span class="line">  <span class="comment">## 为 gitlab-ci runner 注入指定的环境变量，注意不是 runner 动态创建的 pod 的环境变量</span></span><br><span class="line">  <span class="comment"># env:</span></span><br><span class="line">  <span class="comment">#   NAME: VALUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: http://kubernetes.io/docs/user-guide/compute-resources/</span></span><br><span class="line"><span class="comment">## 为 runner 配置资源限制</span></span><br><span class="line"><span class="attr">resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># limits:</span></span><br><span class="line">  <span class="comment">#   memory: 256Mi</span></span><br><span class="line">  <span class="comment">#   cpu: 200m</span></span><br><span class="line">  <span class="comment"># requests:</span></span><br><span class="line">  <span class="comment">#   memory: 128Mi</span></span><br><span class="line">  <span class="comment">#   cpu: 100m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity</span></span><br><span class="line"><span class="comment">## 配置 runner 所在 pod 的亲和性，同 label的作用类似，都用于指定 pod的调度策略，</span></span><br><span class="line"><span class="comment">## 但其功能更加强大，它可以设置简单的逻辑组合，不单单是 label 所局限的简单的相等匹配</span></span><br><span class="line"><span class="attr">affinity:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Ref: https://kubernetes.io/docs/user-guide/node-selection/</span></span><br><span class="line"><span class="comment">## gitlab runner 的节点选择器，即指定只能运行在哪些节点上</span></span><br><span class="line"><span class="attr">nodeSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># node-role.kubernetes.io/worker: "true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## List of node taints to tolerate (requires Kubernetes &gt;= 1.6)</span></span><br><span class="line"><span class="comment">## Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/</span></span><br><span class="line"><span class="comment">## tolerations 与 taints 相关。一个被标记为 Taints 的节点，除非 pod 也被标识为可以容忍污点节点，</span></span><br><span class="line"><span class="comment">## 否则该 Taints 节点不会被调度 pod。</span></span><br><span class="line"><span class="comment">## 典型的，在 kubernetes 集群，Master 节点通过被标记为 taints 以保留给 Kubernetes 系统组件使用</span></span><br><span class="line"><span class="comment">## 但若仍然希望某个 pod 调度到 taint 节点上，则必须在 Spec 中做出Toleration定义，才能调度到该节点</span></span><br><span class="line"><span class="attr">tolerations:</span> <span class="string">[]</span></span><br><span class="line">  <span class="comment"># Example: Regular worker nodes may have a taint, thus you need to tolerate the taint</span></span><br><span class="line">  <span class="comment"># when you assign the gitlab runner manager with nodeSelector or affinity to the nodes.</span></span><br><span class="line">  <span class="comment"># - key: "node-role.kubernetes.io/worker"</span></span><br><span class="line">  <span class="comment">#   operator: "Exists"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html</span></span><br><span class="line"><span class="comment">## 环境变量，在执行 register 命令时使用，以进一步控制注册的过程和 config.toml 配置文件</span></span><br><span class="line"><span class="comment"># envVars:</span></span><br><span class="line"><span class="comment">#   - name: RUNNER_EXECUTOR</span></span><br><span class="line"><span class="comment">#     value: kubernetes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 主机名与ip的映射，它们可以被注入到 runner 所在 pod 的 host 文件</span></span><br><span class="line"><span class="attr">hostAliases:</span> <span class="string">[]</span></span><br><span class="line">  <span class="comment"># Example:</span></span><br><span class="line">  <span class="comment"># - ip: "127.0.0.1"</span></span><br><span class="line">  <span class="comment">#   hostnames:</span></span><br><span class="line">  <span class="comment">#   - "foo.local"</span></span><br><span class="line">  <span class="comment">#   - "bar.local"</span></span><br><span class="line">  <span class="comment"># - ip: "10.1.2.3"</span></span><br><span class="line">  <span class="comment">#   hostnames:</span></span><br><span class="line">  <span class="comment">#   - "foo.remote"</span></span><br><span class="line">  <span class="comment">#   - "bar.remote"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 附加在 runner 所在 pod 上的 annotations</span></span><br><span class="line"><span class="attr">podAnnotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># Example:</span></span><br><span class="line">  <span class="comment"># iam.amazonaws.com/role: &lt;my_role_arn&gt;</span></span><br></pre></td></tr></table></figure><p>最后强调下关于<code>namespace</code>和<code>ServerAccount</code>的权限的问题。事实上<code>gitlab runner</code>会存在于某一个<code>namespace</code>，同时它会关联一个<code>ServiceAccount</code>，此<code>sa</code>决定了其为每个<code>job</code>动态创建的<code>pod</code>操作的权限问题。典型的，若其<code>sa</code>只具备某个<code>namespace</code>下的所有权限，则它不能在集群范围内其它<code>namespace</code>中创建<code>pod</code>。且动态创建的<code>pod</code>所在的<code>namespace</code>可以与<code>runner</code>所在<code>namespace</code>不同。最后，由<code>runner</code>动态创建出来的<code>pod</code>，也会关联一个<code>sa</code>，此<code>sa</code>所绑定的<code>role</code>决定了在对应的<code>job</code>中能够执行的脚本操作，比如，在<code>job</code>中又创建一个<code>pod</code>（我们后面的<code>ci/cd</code>方案中就属于此种情况），那么，此<code>pod</code>所处的<code>namespace</code>也可以和<code>job</code>对应的<code>pod</code>所处的<code>namespace</code>不同，这取决于<code>job</code>所关联的<code>sa</code>的权限。读者若有兴趣，完全可以自己尝试一下这些配置会带来什么影响。</p><p>至此，关于<code>runner</code>的相关的配置已经讲解完毕。大部分还是容易理解的，读者可以通过实验来验证它们的功能。在生产环境中，可能需要覆盖大多默认配置选项。</p><p>简单小结，本文详细分析了在<code>k8s</code>中安装<code>gitlab runner</code>的完整流程。在阐述具体的安装操作前，先是阐述了<code>gitlab-ci/cd</code>的核心概念和基本原理，这有助于了解<code>gitlab-ci</code>到底是如何工作。其次，阐述了<code>gitlab runner</code>的相关知识，<code>gitlab runner</code>才是定义在<code>.gitlab-ci.yml</code>的脚本的执行器，但它并不特殊，只是一个使用<code>go</code>写的应用程序而已。然后，重点阐述了<code>k8s</code>中安装<code>gitlab runner</code>的详细步骤，附带阐述了<code>kubernetes executor</code>的原理和<code>helm</code>的基本作用。同时，详细解释了<code>gitlab runner chart</code>包的<code>values.yml</code>配置文件的核心配置选项。最后，为了更深入了解<code>gitlab runner</code>的运行原理，简述了<code>values.yml</code>中几乎所有的配置选项。</p><p>需要提醒读者的是，整篇文件比较长。涉及到的内容也较多，提供的参考资料也挺多。但只要耐心跟随整个流程，在<code>k8s</code>中安装<code>gitlab runner</code>是完全没有问题的。</p><p>参考文献</p><p><code>minikube</code><br>[1].<a href="https://kubernetes.io/docs/tasks/tools/install-minikube/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/tools/install-minikube/</a><br>[2].<a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">https://github.com/kubernetes/minikube</a><br>[3].<a href="https://github.com/kubernetes/minikube/issues/2991" target="_blank" rel="noopener">https://github.com/kubernetes/minikube/issues/2991</a></p><p><code>gitlab-ci/cd</code><br>[1].<a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/</a><br>[2].<a href="https://docs.gitlab.com/ee/ci/introduction/index.html#how-gitlab-cicd-works" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/introduction/index.html#how-gitlab-cicd-works</a><br>[3].<a href="https://docs.gitlab.com/ee/ci/yaml/README.html" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/yaml/README.html</a><br>[4].<a href="https://gitlab.com/gitlab-examples" target="_blank" rel="noopener">https://gitlab.com/gitlab-examples</a></p><p><code>gitlab runner</code><br>[1].<a href="https://docs.gitlab.com/ee/ci/runners/README.html" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/runners/README.html</a><br>[2].<a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">https://docs.gitlab.com/runner/</a><br>[3].<a href="https://docs.gitlab.com/ce/ci/docker/using_docker_images.html#what-is-a-service" target="_blank" rel="noopener">https://docs.gitlab.com/ce/ci/docker/using_docker_images.html#what-is-a-service</a></p><p><code>helm</code><br>[1].<a href="https://helm.sh/docs/" target="_blank" rel="noopener">https://helm.sh/docs/</a><br>[2].<a href="https://zhaohuabing.com/2018/04/16/using-helm-to-deploy-to-kubernetes/" target="_blank" rel="noopener">https://zhaohuabing.com/2018/04/16/using-helm-to-deploy-to-kubernetes/</a><br>[3].<a href="https://www.qikqiak.com/post/first-use-helm-on-kubernetes/" target="_blank" rel="noopener">https://www.qikqiak.com/post/first-use-helm-on-kubernetes/</a></p><p><code>kubernetes executor</code><br>[1].<a href="https://docs.gitlab.com/runner/executors/kubernetes.html" target="_blank" rel="noopener">https://docs.gitlab.com/runner/executors/kubernetes.html</a></p><p><code>install runner in k8s</code><br>[1].<a href="https://docs.gitlab.com/runner/install/kubernetes.html" target="_blank" rel="noopener">https://docs.gitlab.com/runner/install/kubernetes.html</a><br>[2].<a href="https://docs.gitlab.com/runner/configuration/advanced-configuration.html" target="_blank" rel="noopener">https://docs.gitlab.com/runner/configuration/advanced-configuration.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作的内容属于&lt;code&gt;devops&lt;/code&gt;领域方向，研究的课题是基于&lt;code&gt;k8s&lt;/code&gt;并集成&lt;code&gt;gitlab-ci&lt;/code&gt;的持续集成部署方案。个人以前只使用过&lt;code&gt;Jenkins&lt;/code&gt;来做持续集成部署(&lt;code&gt;ci/cd&lt;/code&gt;)，而且，当时应该是部署在云主机上的。&lt;code&gt;gitlab&lt;/code&gt;本身一个企业级代码托管平台，在&lt;code&gt;8.0&lt;/code&gt;版本加入了&lt;code&gt;ci&lt;/code&gt;，并且默认为每个项目开启。持续集成基本解放了软件项目的开发测试到最终的部署上线的繁琐流程，简单而言，它保证了每一次往版本库提交的代码都符合预期。我们知道&lt;code&gt;docker&lt;/code&gt;解决了应用打包和发布这一运维技术难题，简单而言，&lt;code&gt;docker&lt;/code&gt;所提供的极为方便的打包机制直接打包了应用运行所需要的整个操作系统，从而保证了本地环境和云端环境的高度一致。但毕竟在整个云计算领域中，&lt;code&gt;docker&lt;/code&gt;只是整个容器生态的一个承载点，换言之，与开发者更为密切相关的事情是定义容器组织和管理规范的容器编排技术，这属于一个更高的层次，是一个平台级的技术。&lt;code&gt;kuberentes&lt;/code&gt;正是这样一个开源平台，简而言之，&lt;code&gt;kubernetes&lt;/code&gt;项目解决的问题是容器的编排、调度以及集群管理，当然，它也提供了一些高级的运维功能，如路由网关、水平扩展、监控、备份以及灾难恢复等。这也使得&lt;code&gt;kubernetes&lt;/code&gt;从一诞生就备受关注。因此，将&lt;code&gt;gitlab-ci&lt;/code&gt;与&lt;code&gt;k8s&lt;/code&gt;进行整合是&lt;code&gt;ci/cd&lt;/code&gt;实践中值得期待的方案。本系列博客会阐述个人基于&lt;code&gt;k8s&lt;/code&gt;并集成&lt;code&gt;gitlab-ci&lt;/code&gt;的持续集成部署方案的实现过程。实践环节包括两个部分，其一是在&lt;code&gt;k8s&lt;/code&gt;中安装&lt;code&gt;gitlab runner&lt;/code&gt;，其二是研究集成&lt;code&gt;gitlab-ci&lt;/code&gt;和&lt;code&gt;k8s&lt;/code&gt;来实现一个以&lt;code&gt;build-&amp;gt;test-&amp;gt;deploy&lt;/code&gt;为核心的持续集成部署流程。本文的内容为第一个部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="持续集成" scheme="http://geoffen.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="k8s" scheme="http://geoffen.github.io/tags/k8s/"/>
    
      <category term="gitlab-ci" scheme="http://geoffen.github.io/tags/gitlab-ci/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习笔记</title>
    <link href="http://geoffen.github.io/2019/06/23/Shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://geoffen.github.io/2019/06/23/Shell学习笔记/</id>
    <published>2019-06-23T15:20:46.000Z</published>
    <updated>2019-11-07T10:24:47.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell命令"><a href="#Shell命令" class="headerlink" title="Shell命令"></a>Shell命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">变量名:不需要使用$符号，<span class="string">"="</span>不能有空格</span></span><br><span class="line">my_name="BinZhiZhu"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输出:需要$符号</span></span><br><span class="line">echo $my_name</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单引号</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">'I try to learn shell '</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#双引号:可以有变量,可以有转义字符</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">"My name is \"<span class="variable">$my_name</span>\",Nice to meet u"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#拼接</span></span><br><span class="line"></span><br><span class="line">str1=<span class="string">"What's ur name,bro? My name is "</span><span class="variable">$my_name</span><span class="string">"!"</span></span><br><span class="line"></span><br><span class="line">str2=<span class="string">"What's ur name,bro? My name is "</span>&#123;<span class="variable">$my_name</span>&#125;<span class="string">"!"</span></span><br><span class="line"></span><br><span class="line">str3=<span class="string">"What's ur name,bro? My name is &#123;<span class="variable">$my_name</span>&#125;!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取长度:$&#123;# + 变量&#125;</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">'qwer'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#str&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#提取子字符串:</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">"my name is <span class="variable">$my_name</span> "</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#提取名字：BinZhiZhu</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:11&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#提取指定索引范围:name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:3:5&#125;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#括号括起来 元素之间用空格相隔</span></span><br><span class="line">array=(a b c d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以直接赋值</span></span><br><span class="line">array1[0]=1</span><br><span class="line">array1[1]=2</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"所有元素为：<span class="variable">$&#123;array[*]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第一个元素为：<span class="variable">$&#123;array[0]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第二个元素为：<span class="variable">$&#123;array[1]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第三个元素为：<span class="variable">$&#123;array[2]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第四个元素为：<span class="variable">$&#123;array[3]&#125;</span>"</span></span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h3 id="if的使用"><a href="#if的使用" class="headerlink" title="if的使用"></a>if的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">运算符 : -gt:大于; -lt:小于; -eq:等于</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span>使用</span></span><br><span class="line"></span><br><span class="line">a=6</span><br><span class="line">b=4</span><br><span class="line"></span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">     echo "a大于b咯"</span><br><span class="line">elif [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">     echo "a等于b咯"</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">     echo "a小于b咯"</span><br><span class="line">else</span><br><span class="line">     echo "没有找到该条件判断"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">test</span>命令</span></span><br><span class="line"></span><br><span class="line">let num1=2*3</span><br><span class="line">let num2=3+3</span><br><span class="line"></span><br><span class="line">if test $num1 -eq $num2</span><br><span class="line">then</span><br><span class="line">    echo '两个数字相等!'</span><br><span class="line">else</span><br><span class="line">    echo '两个数字不相等!'</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">等价于</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let num3=2*3</span><br><span class="line">let num4=3+2</span><br><span class="line"></span><br><span class="line">if [ $num3 -eq $num4 ]</span><br><span class="line">then</span><br><span class="line">    echo '两个数字相等!'</span><br><span class="line">else</span><br><span class="line">    echo '两个数字不相等!'</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr=(1 2 3 4)</span><br><span class="line">for loop in $&#123;arr[*]&#125;</span><br><span class="line">do</span><br><span class="line">    echo "The Number is: $loop"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">写成一行</span></span><br><span class="line">for loop in $&#123;arr[*]&#125;;do echo "Number is: $loop";done;</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">当num小于等于5条件为<span class="literal">true</span></span></span><br><span class="line">num=1</span><br><span class="line"></span><br><span class="line"><span class="meta">while(($</span><span class="bash">num &lt;= 5 ))</span></span><br><span class="line">do</span><br><span class="line">   echo "num is:$num"</span><br><span class="line">   let num++</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">读取键盘信息</span></span><br><span class="line"></span><br><span class="line">echo '按下 &lt;CTRL-D&gt; 退出'</span><br><span class="line">echo -n '输入你最喜欢的网站名: '</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo "是的！$FILM 是一个好网站"</span><br><span class="line">    break</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">until 循环执行一系列命令直至条件为 <span class="literal">true</span> 时停止，与<span class="keyword">while</span>相反</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">输入1-10数字咯</span></span><br><span class="line">a=0</span><br><span class="line">b=10</span><br><span class="line"></span><br><span class="line">until [ $a -eq $b ]</span><br><span class="line">do</span><br><span class="line">    echo " value is : $a"</span><br><span class="line">    let a++</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="case循环"><a href="#case循环" class="headerlink" title="case循环"></a>case循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">esac</span>的意思与<span class="keyword">case</span>相反 也就是结束执行</span></span><br><span class="line">echo "case 循环"</span><br><span class="line"></span><br><span class="line">echo '输入 1 到 4 之间的数字:'</span><br><span class="line">echo '你输入的数字为:'</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo '你选择了 1'</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo '你选择了 2'</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo '你选择了 3'</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo '你选择了 4'</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo '你没有输入 1 到 4 之间的数字'</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#输入 1 到 5 之间的数字才可结束循环</span></span></span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n "输入 1 到 5 之间的数字:"</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo "你输入的数字为 $aNum!"</span><br><span class="line">        ;;</span><br><span class="line">        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="简单的删除文件"><a href="#简单的删除文件" class="headerlink" title="简单的删除文件"></a>简单的删除文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">filePath=&quot;del.php&quot;</span><br><span class="line"></span><br><span class="line">echo &apos;确认删除del.php文件吗？(y/n)&apos;</span><br><span class="line">read check</span><br><span class="line">case $check in</span><br><span class="line">     &apos;y&apos;)</span><br><span class="line">         rm $filePath;;</span><br><span class="line">     &apos;n&apos;)</span><br><span class="line">         echo &apos;取消删除&apos;;;</span><br><span class="line">      *)</span><br><span class="line">         echo &apos;请输入y/n&apos;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Shell命令&quot;&gt;&lt;a href=&quot;#Shell命令&quot; class=&quot;headerlink&quot; title=&quot;Shell命令&quot;&gt;&lt;/a&gt;Shell命令&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#!/bin/bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;变量名:不需要使用$符号，&lt;span class=&quot;string&quot;&gt;&quot;=&quot;&lt;/span&gt;不能有空格&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;my_name=&quot;BinZhiZhu&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;输出:需要$符号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $my_name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h3&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#单引号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str=&lt;span class=&quot;string&quot;&gt;&#39;I try to learn shell &#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$str&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#双引号:可以有变量,可以有转义字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str=&lt;span class=&quot;string&quot;&gt;&quot;My name is \&quot;&lt;span class=&quot;variable&quot;&gt;$my_name&lt;/span&gt;\&quot;,Nice to meet u&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$str&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#拼接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str1=&lt;span class=&quot;string&quot;&gt;&quot;What&#39;s ur name,bro? My name is &quot;&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;$my_name&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2=&lt;span class=&quot;string&quot;&gt;&quot;What&#39;s ur name,bro? My name is &quot;&lt;/span&gt;&amp;#123;&lt;span class=&quot;variable&quot;&gt;$my_name&lt;/span&gt;&amp;#125;&lt;span class=&quot;string&quot;&gt;&quot;!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str3=&lt;span class=&quot;string&quot;&gt;&quot;What&#39;s ur name,bro? My name is &amp;#123;&lt;span class=&quot;variable&quot;&gt;$my_name&lt;/span&gt;&amp;#125;!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$str1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$str2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$str3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#获取长度:$&amp;#123;# + 变量&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str=&lt;span class=&quot;string&quot;&gt;&#39;qwer&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$&amp;#123;#str&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#提取子字符串:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str=&lt;span class=&quot;string&quot;&gt;&quot;my name is &lt;span class=&quot;variable&quot;&gt;$my_name&lt;/span&gt; &quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#提取名字：BinZhiZhu&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$&amp;#123;str:11&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#提取指定索引范围:name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$&amp;#123;str:3:5&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://geoffen.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="http://geoffen.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>nsq diskqueue 源码简析</title>
    <link href="http://geoffen.github.io/2019/05/19/nsq-diskqueue-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    <id>http://geoffen.github.io/2019/05/19/nsq-diskqueue-持久化存储源码简析/</id>
    <published>2019-05-19T04:08:17.000Z</published>
    <updated>2019-11-07T10:24:47.402Z</updated>
    
    <content type="html"><![CDATA[<p><code>diskQueue</code>是<code>nsq</code>分布式实时消息队列的消息持久化存储组件。考虑到<code>nsq</code>为了限制消息积压所占的内存，同时也为了保证节点宕机消息尽可能丢失，因此，当内存消息队列<code>memoryMsgChan</code>的长度达到配置的阈值时，会将消息写入到持久化存储消息队列中。是的，<code>diskQueue</code>提供两个关键特性，一是持久化存储，二是队列接口。而在<code>nsq</code>系统中<code>diskQueue</code>的用法和<code>memoryMsgChan</code>（<code>buffered go channel</code>）基本上是相同的，因此，对于生产者或者消费者而言，消息的存储方式对于它们而言是透明的，它们只需要调用相应的接口投递或获取消息即可。这确实是数据存储的最佳实践。在此前的6篇文章已经将<code>nsq</code>相关模块的源码阐述完毕。本文的主题是<code>diskQueue</code>——持久化消息队列存储组件。重点阐述其实现原理，同时分析其为上层应用程序提供的接口。</p><a id="more"></a><p>据官方介绍，<code>diskQueue</code>是从<code>nsq</code>项目中抽取而来，将它单独作为一个项目<a href="https://github.com/nsqio/go-diskqueue" target="_blank" rel="noopener"><code>go-diskqueue</code></a>。它本身比较简单，只有一个源文件<code>diskqueue.go</code>。本文阐述的内容更完整的源码注释可在<a href="https://github.com/qqzeng/nsqio/tree/master/go-diskqueue" target="_blank" rel="noopener">这里</a>找到，注释源码版本为<code>v1.1.0</code>，仅供参考。</p><p>本文阐述的内容可分两个部分：其一，分析<code>diskQueue</code>的工作原理，这包括如何从文件中读取一条消息以及如何写入一条消息到文件系统中（考虑到写入或读取文件时，可能涉及到文件的切换，因为它需要保证单个文件的大小 不能过大，因此采用滚动写入的方式。另外在读取或写入文件时，也要考虑文件损坏的情况）。同时分析<code>diskQueue</code>提供给应用程序的接口，典型地，包括将消息写入到<code>diskQueue</code>中，从<code>diskQueue</code>读取一条消息，以及删除或清空<code>diskQueue</code>存储的消息。但本文的行文方式为：从<code>diskQueue</code>实例结构开始，围绕<code>diskQueue.ioLoop</code>主循环展开，阐述上述介绍的各个流程。</p><h2 id="diskQueue-实例结构"><a href="#diskQueue-实例结构" class="headerlink" title="diskQueue 实例结构"></a>diskQueue 实例结构</h2><p><code>diskQueue</code>结构所包含字段可以分为四个部分：</p><ul><li>第一部分为<code>diskQueue</code>当前读写的文件的状态，如读取或写入索引<code>readPos/writePos</code>，读取或写入文件编号<code>readFileNum/writeFileNum</code>，以及<code>depth</code>表示当前可供读取或消费的消息的数量；</li><li>第二部分为<code>diskQueue</code>的元数据信息，如单个文件最大大小<code>maxBytesPerFile</code>，每写多少条消息需要执行刷盘操作<code>syncEvery</code>等待；</li><li>第三部分是读写文件句柄<code>readFile/wirteFile</code>，以及文件读取流<code>reader</code>或写入缓冲<code>writeBuf</code>；</li><li>最后一部分为用于传递信号的内部管道，如<code>writeChan</code>，应用程序可通过此管道向<code>diskQueue</code>间接压入消息，<code>emptyChan</code>应用程序通过此管道间接发出清空<code>diskQueue</code>的信号等。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// diskQueue 实现了一个基于后端持久化的 FIFO 队列</span></span><br><span class="line"><span class="keyword">type</span> diskQueue <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// run-time state (also persisted to disk)</span></span><br><span class="line"><span class="comment">// 运行时状态，需要被持久化</span></span><br><span class="line">readPos      <span class="keyword">int64</span><span class="comment">// 当前的文件读取索引</span></span><br><span class="line">writePos     <span class="keyword">int64</span><span class="comment">// 当前的文件写入索引</span></span><br><span class="line">readFileNum  <span class="keyword">int64</span><span class="comment">// 当前读取的文件号</span></span><br><span class="line">writeFileNum <span class="keyword">int64</span><span class="comment">// 当前写入的文件号</span></span><br><span class="line">depth        <span class="keyword">int64</span><span class="comment">// diskQueue 中等待被读取的消息数</span></span><br><span class="line"></span><br><span class="line">sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// instantiation time metadata</span></span><br><span class="line"><span class="comment">// 初始化时元数据</span></span><br><span class="line">name            <span class="keyword">string</span><span class="comment">// diskQueue 名称</span></span><br><span class="line">dataPath        <span class="keyword">string</span><span class="comment">// 数据持久化路径</span></span><br><span class="line">maxBytesPerFile <span class="keyword">int64</span> <span class="comment">// 目前，此此属性一旦被初始化，则不可变更</span></span><br><span class="line">minMsgSize      <span class="keyword">int32</span><span class="comment">// 最小消息的大小</span></span><br><span class="line">maxMsgSize      <span class="keyword">int32</span><span class="comment">// 最大消息的大小</span></span><br><span class="line">syncEvery       <span class="keyword">int64</span>         <span class="comment">// 累积的消息数量，才进行一次同步刷新到磁盘操作</span></span><br><span class="line">syncTimeout     time.Duration <span class="comment">// 两次同步之间的间隔</span></span><br><span class="line">exitFlag        <span class="keyword">int32</span><span class="comment">// 退出标志</span></span><br><span class="line">needSync        <span class="keyword">bool</span><span class="comment">// 是否需要同步刷新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keeps track of the position where we have read</span></span><br><span class="line"><span class="comment">// (but not yet sent over readChan)</span></span><br><span class="line"><span class="comment">// 之所以存在 nextReadPos &amp; nextReadFileNum 和 readPos &amp; readFileNum</span></span><br><span class="line">    <span class="comment">// 是因为虽然消费者已经发起了数据读取请求，但 diskQueue 还未将此消息发送给消费者，</span></span><br><span class="line"><span class="comment">// 当发送完成后，会将 readPos 更新到 nextReadPos，readFileNum 也类似</span></span><br><span class="line">nextReadPos     <span class="keyword">int64</span><span class="comment">// 下一个应该被读取的索引位置</span></span><br><span class="line">nextReadFileNum <span class="keyword">int64</span><span class="comment">// 下一个应该被读取的文件号</span></span><br><span class="line"></span><br><span class="line">readFile  *os.File<span class="comment">// 当前读取文件句柄</span></span><br><span class="line">writeFile *os.File<span class="comment">// 当前写入文件句柄</span></span><br><span class="line">reader    *bufio.Reader<span class="comment">// 当前文件读取流</span></span><br><span class="line">writeBuf  bytes.Buffer<span class="comment">// 当前文件写入流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// exposed via ReadChan()</span></span><br><span class="line"><span class="comment">// 应用程序可通过此通道从 diskQueue 中读取消息，</span></span><br><span class="line">    <span class="comment">// 因为 readChan 是 unbuffered的，所以，读取操作是同步的</span></span><br><span class="line"><span class="comment">// 另外当一个文件中的数据被读取完时，文件会被删除，同时切换到下一个被读取的文件</span></span><br><span class="line">readChan <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal channels</span></span><br><span class="line">    <span class="comment">// 应用程序通过此通道往 diskQueue压入消息，写入操作也是同步的</span></span><br><span class="line">writeChan         <span class="keyword">chan</span> []<span class="keyword">byte</span> </span><br><span class="line">writeResponseChan <span class="keyword">chan</span> error<span class="comment">// 可通过此通道向应用程序返回消息写入结果</span></span><br><span class="line">emptyChan         <span class="keyword">chan</span> <span class="keyword">int</span><span class="comment">// 应用程序可通过此通道发送清空 diskQueue 的消息</span></span><br><span class="line">emptyResponseChan <span class="keyword">chan</span> error<span class="comment">// 可通过此通道向应用程序返回清空 diskQueue 的结果</span></span><br><span class="line">exitChan          <span class="keyword">chan</span> <span class="keyword">int</span><span class="comment">// 退出信号</span></span><br><span class="line">exitSyncChan      <span class="keyword">chan</span> <span class="keyword">int</span><span class="comment">// 保证 ioLoop 已退出的信号</span></span><br><span class="line"></span><br><span class="line">logf AppLogFunc</span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br></pre></td></tr></table></figure><h2 id="diskQueue-构造方法"><a href="#diskQueue-构造方法" class="headerlink" title="diskQueue 构造方法"></a>diskQueue 构造方法</h2><p>首先考虑<code>diskQueue</code>在<code>nsq</code>系统中什么情况下会被实例化？答案是在实例化<code>topic</code>或<code>channel</code>时候。<code>diskQueue</code>的实例过程比较简单，首先根据传入的参数构造<code>diskQueue</code>实例，然后从配置文件中加载<code>diskQueue</code>的重要的属性状态，这包括<code>readPos &amp; writePos</code>,<code>readFileNum &amp; writerFileNum</code>和<code>depth</code>，并初始化<code>nextReadFileNum</code>和<code>nextReadPos</code>两个重要的属性。最后异步开启消息处理的主循环<code>ioLoop</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New 方法初始化一个 diskQueue 实例，并从持久化存储中加载元数据信息，然后开始启动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(name <span class="keyword">string</span>, dataPath <span class="keyword">string</span>, maxBytesPerFile <span class="keyword">int64</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">minMsgSize <span class="keyword">int32</span>, maxMsgSize <span class="keyword">int32</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">syncEvery <span class="keyword">int64</span>, syncTimeout time.Duration, logf AppLogFunc)</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 实例化 diskQueue</span></span><br><span class="line">d := diskQueue&#123;</span><br><span class="line">name:              name,</span><br><span class="line">dataPath:          dataPath,</span><br><span class="line">maxBytesPerFile:   maxBytesPerFile,</span><br><span class="line">minMsgSize:        minMsgSize,</span><br><span class="line">maxMsgSize:        maxMsgSize,</span><br><span class="line">readChan:          <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>),</span><br><span class="line">writeChan:         <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>),</span><br><span class="line">writeResponseChan: <span class="built_in">make</span>(<span class="keyword">chan</span> error),</span><br><span class="line">emptyChan:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">emptyResponseChan: <span class="built_in">make</span>(<span class="keyword">chan</span> error),</span><br><span class="line">exitChan:          <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">exitSyncChan:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">syncEvery:         syncEvery,</span><br><span class="line">syncTimeout:       syncTimeout,</span><br><span class="line">logf:              logf,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 从持久化存储中初始化 diskQueue 的一些属性状态： readPos, writerPos, depth 等</span></span><br><span class="line">err := d.retrieveMetaData()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 3. 在一个单独的 goroutien 中执行主循环</span></span><br><span class="line"><span class="keyword">go</span> d.ioLoop()</span><br><span class="line"><span class="keyword">return</span> &amp;d</span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从持久化存储中初始化 diskQueue 的一些属性状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">retrieveMetaData</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f *os.File</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// 1. 获取元数据文件名 *.diskqueue.meta.dat，并打开文件，准备读取文件</span></span><br><span class="line">fileName := d.metaDataFileName()</span><br><span class="line">f, err = os.OpenFile(fileName, os.O_RDONLY, <span class="number">0600</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="comment">// 2. 从文件中内容初始化特定状态属性信息 readPos, writerPos, depth</span></span><br><span class="line"><span class="keyword">var</span> depth <span class="keyword">int64</span></span><br><span class="line">_, err = fmt.Fscanf(f, <span class="string">"%d\n%d,%d\n%d,%d\n"</span>,</span><br><span class="line">&amp;depth,</span><br><span class="line">&amp;d.readFileNum, &amp;d.readPos,</span><br><span class="line">&amp;d.writeFileNum, &amp;d.writePos)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 初始化 nextReadFileNum 和 nextReadPos</span></span><br><span class="line">atomic.StoreInt64(&amp;d.depth, depth)</span><br><span class="line">d.nextReadFileNum = d.readFileNum</span><br><span class="line">d.nextReadPos = d.readPos</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="diskQueue-消息处理主循环"><a href="#diskQueue-消息处理主循环" class="headerlink" title="diskQueue 消息处理主循环"></a>diskQueue 消息处理主循环</h2><p><code>diskQueue</code>消息处理主循环<code>ioLoop</code>在其被实例化后就会开始执行。<code>diskQueue</code>包含的逻辑主要包括四个方面：从文件中读取一条消息，并压入到<code>readChan</code>管道中；将应用程序传入的消息，写入到文件；每隔一段时间，将写入缓冲的数据执行刷盘动作；最后是当应用程序调用清空<code>diskQueue</code>的接口时，执行删除并关闭<code>diskQueue</code>的动作。同时，笔者在阐述这些流程的实现细节的同时，将应用程序如何同<code>diskQueue</code>交互放在一起串联分析。下面的代码是<code>ioLoop</code>的大致框架，为了使框架更清晰省略了细节：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// diskQueue 消息处理主循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">ioLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 1. 只有写入缓冲中的消息达到一定数量，才执行同步刷新到磁盘的操作</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 2. 刷新磁盘操作，重置计数信息，即将 writeFile 流刷新到磁盘，同时持久化元数据</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 3. 从文件中读取消息的逻辑</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 4. 当读取到数据时，将它压入到 r/readChan 通道，</span></span><br><span class="line">            <span class="comment">// 同时判断是否需要更新到下一个文件读取，同时设置 needSync</span></span><br><span class="line"><span class="keyword">case</span> r &lt;- dataRead:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 5. 收到清空持久化存储 disQueue 的消息</span></span><br><span class="line"><span class="keyword">case</span> &lt;-d.emptyChan: <span class="comment">// (当应用程序调用 diskQueue.Empty 方法时触发)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 6. 收到写入消息到磁盘的消息 (当应用程序调用 diskQueue.Put 方法时触发)</span></span><br><span class="line"><span class="keyword">case</span> dataWrite := &lt;-d.writeChan:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 7. 定时执行刷盘操作，在存在数据等待刷盘时，才需要执行刷盘动作</span></span><br><span class="line"><span class="keyword">case</span> &lt;-syncTicker.C:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 8. 退出信号</span></span><br><span class="line"><span class="keyword">case</span> &lt;-d.exitChan:</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">exit:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br></pre></td></tr></table></figure><h3 id="diskQueue-读取消息"><a href="#diskQueue-读取消息" class="headerlink" title="diskQueue 读取消息"></a>diskQueue 读取消息</h3><p>从<code>diskQueue</code>读取一条消息涉及到的<code>ioLoop</code>方法中的步骤3和4，其中步骤2的核心逻辑为：若当前持久化中还有未被读取或消费的消息，则尝试从特定的文件(<code>readFileNum</code>)、特定偏移位置(<code>readPos</code>)读取一条消息。这个过程并不复杂，值得注意的一点是：程序中还使用了另外一组与读取相关的状态(<code>nextReadFileNum</code>和<code>nextReadPos</code>)。当消息未从文件中读取时，<code>readPos == nextReadPos &amp;&amp; readFileNum == nextReadFileNum</code> ，当消息已从文件中读出但未发送给应用程序时，<code>readPos + totalBytes == nextReadPos &amp;&amp; readFileNum == nextReadFileNum</code>（若涉及到文件切换，则<code>nextReadFileNum++ &amp;&amp; nextReadPos == 0</code>），当消息已经发送给应用程序时，<code>readPos == nextReadPos &amp;&amp; readFileNum == nextReadFileNum</code>。换言之，之所以存在<code>nextReadFileNum</code>和<code>nextReadPos</code>是因为虽然消费者已经发起了数据读取请求，但 <code>diskQueue</code>还未将此消息发送给消费者，当发送完成后，会将它们相应更新。好，文件读取过程已经阐述完毕。当消息从文件中读取出来后，是通过<code>diskQueue.readChan</code>发送给上层应用程序的，上层应用程序通过调用<code>diskQueue.ReadChan</code>获取到此管道实例，并一直等待从此管道接收消息。相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 diskQueu 的读取通道，即 readChan，通过此通道从 diskQueue 中读取/消费消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">ReadChan</span><span class="params">()</span> <span class="title">chan</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> d.readChan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">ioLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> dataRead []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> r <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line">syncTicker := time.NewTicker(d.syncTimeout)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// dont sync all the time :)</span></span><br><span class="line"><span class="comment">// 1. 只有写入缓冲中的消息达到一定数量，才执行同步刷新到磁盘的操作</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 2. 刷新磁盘操作，重置计数信息，即将 writeFile 流刷新到磁盘，同时持久化元数据</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 3. 若当前还有数据（消息）可供消费</span></span><br><span class="line">        <span class="comment">// （即当前读取的文件编号 readFileNum &lt; 目前已经写入的文件编号 writeFileNum</span></span><br><span class="line"><span class="comment">// 或者 当前的读取索引 readPos &lt; 当前的写的索引 writePos）</span></span><br><span class="line"><span class="comment">// 因为初始化读每一个文件时都需要重置 readPos = 0</span></span><br><span class="line"><span class="keyword">if</span> (d.readFileNum &lt; d.writeFileNum) || (d.readPos &lt; d.writePos) &#123;</span><br><span class="line"><span class="comment">// 保证当前处于可读取的状态，即 readPos + totalByte == nextReadPos，</span></span><br><span class="line"><span class="comment">// 若二者相等，则需要通过 d.readOne 方法先更新 nextReadPos</span></span><br><span class="line"><span class="keyword">if</span> d.nextReadPos == d.readPos &#123;</span><br><span class="line">dataRead, err = d.readOne()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">d.logf(ERROR, <span class="string">"DISKQUEUE(%s) reading at %d of %s - %s"</span>,</span><br><span class="line">d.name, d.readPos, d.fileName(d.readFileNum), err)</span><br><span class="line">d.handleReadError()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取出读取通道 readChan</span></span><br><span class="line">r = d.readChan</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当 r == nil时，代表此时消息已经全部读取完毕，</span></span><br><span class="line">            <span class="comment">// 因此使用 select 不能将数据（消息）压入其中</span></span><br><span class="line">r = <span class="literal">nil</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 4. 当读取到数据时，将它压入到 r/readChan 通道，</span></span><br><span class="line">            <span class="comment">// 同时判断是否需要更新到下一个文件读取，同时设置 needSync</span></span><br><span class="line"><span class="keyword">case</span> r &lt;- dataRead:</span><br><span class="line">count++ <span class="comment">// 更新当前等待刷盘的消息数量</span></span><br><span class="line"><span class="comment">// 判断是否可以将磁盘中读取的上一个文件删除掉（已经读取完毕），同时需要设置 needSync</span></span><br><span class="line"><span class="comment">// 值得注意的是，moveForward 方法中将 readPos 更新为了 nextReadPos，</span></span><br><span class="line">            <span class="comment">// 且 readFileNum 也被更新为 nextReadFileNum</span></span><br><span class="line"><span class="comment">// 因为此时消息已经发送给了消费者了。</span></span><br><span class="line">d.moveForward()</span><br><span class="line"><span class="comment">// 5. 收到清空持久化存储 disQueue 的消息</span></span><br><span class="line"><span class="keyword">case</span> &lt;-d.emptyChan: <span class="comment">// (当应用程序调用 diskQueue.Empty 方法时触发)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 6. 收到写入消息到磁盘的消息 (当应用程序调用 diskQueue.Put 方法时触发)</span></span><br><span class="line"><span class="keyword">case</span> dataWrite := &lt;-d.writeChan:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 7. 定时执行刷盘操作，在存在数据等待刷盘时，才需要执行刷盘动作</span></span><br><span class="line"><span class="keyword">case</span> &lt;-syncTicker.C:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 8. 退出信号</span></span><br><span class="line"><span class="keyword">case</span> &lt;-d.exitChan:</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">exit:</span><br><span class="line">syncTicker.Stop()</span><br><span class="line">d.exitSyncChan &lt;- <span class="number">1</span></span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br></pre></td></tr></table></figure><p>当消息被压入到<code>readChan</code>管道后，随即更新等待刷盘的消息数量，然后调用<code>diskQueue.moveForward</code>方法判断是否可以将磁盘中读取的上一个文件删除掉（已经读取完毕），同时考虑是否需要设置<code>needSync</code>（因为即将读取一个新的文件），最后复原<code>readFileNum</code>和<code>readPos</code>并更新等待被读取的消息数量<code>depth</code>。相关源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查当前读取的文件和上一次读取的文件是否为同一个，即读取是否涉及到文件的更换，</span></span><br><span class="line"><span class="comment">// 若是，则说明可以将磁盘中上一个文件删除掉，因为上一个文件包含的消息已经读取完毕，</span></span><br><span class="line"><span class="comment">// 同时需要设置 needSync</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">moveForward</span><span class="params">()</span></span> &#123;</span><br><span class="line">oldReadFileNum := d.readFileNum</span><br><span class="line">d.readFileNum = d.nextReadFileNum</span><br><span class="line">d.readPos = d.nextReadPos</span><br><span class="line">depth := atomic.AddInt64(&amp;d.depth, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> oldReadFileNum != d.nextReadFileNum &#123;</span><br><span class="line"><span class="comment">// 每当准备读取一个新的文件时，需要设置 needSync</span></span><br><span class="line">d.needSync = <span class="literal">true</span></span><br><span class="line">fn := d.fileName(oldReadFileNum)</span><br><span class="line">err := os.Remove(fn) <span class="comment">// 将老的文件删除</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测文件末尾是否已经损坏</span></span><br><span class="line">d.checkTailCorruption(depth)</span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br></pre></td></tr></table></figure><p>注意到在<code>moveForward</code>方法的最后，还检查了文件末尾是否损坏。它先通过元数据信息（4个变量）判断是否已经读到了最后一个文件的末尾，若未到，则返回。否则，通过<code>depth</code>与0的大小关系来判断文件损坏的类型或原因。详细可以查看源码中的注释，解释得较为清楚。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测文件末尾是否已经损坏</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">checkTailCorruption</span><span class="params">(depth <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 若当前还有消息可供读取，则说明未读取到文件末尾，暂时不用检查</span></span><br><span class="line"><span class="keyword">if</span> d.readFileNum &lt; d.writeFileNum || d.readPos &lt; d.writePos &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// we've reached the end of the diskqueue</span></span><br><span class="line"><span class="comment">// if depth isn't 0 something went wrong</span></span><br><span class="line"><span class="comment">// 若代码能够执行，则正常情况下，说明已经读取到 diskQueue 的尾部，</span></span><br><span class="line"><span class="comment">// 即读取到了最后一个文件的尾部了，因此，此时的 depth(累积等待读取或消费的消息数量)</span></span><br><span class="line"><span class="comment">// 应该为0,因此若其不为0,则表明文件尾部已经损坏，报错。</span></span><br><span class="line"><span class="comment">// 一方面，若其小于 0,则表明初始化加载的元数据已经损坏（depth从元数据文件中读取而来）</span></span><br><span class="line"><span class="comment">// 原因是：实际上文件还有可供读取的消息，但depth指示没有了，因此 depth 计数错误。</span></span><br><span class="line"><span class="comment">// 否则，说明是消息实体数据存在丢失的情况</span></span><br><span class="line"><span class="comment">// 原因是：实际上还有消息可供读取 depth &gt; 0,但是文件中已经没有消息了，因此文件被损坏。</span></span><br><span class="line"><span class="comment">// 同时，强制重置 depth，并且设置 needSync</span></span><br><span class="line"><span class="keyword">if</span> depth != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> depth &lt; <span class="number">0</span> &#123;</span><br><span class="line">d.logf(ERROR,</span><br><span class="line"><span class="string">"DISKQUEUE(%s) negative depth at tail (%d), metadata corruption,"</span> \</span><br><span class="line">                   resetting <span class="number">0.</span>..<span class="string">", d.name, depth)</span></span><br><span class="line"><span class="string">&#125; else if depth &gt; 0 &#123;</span></span><br><span class="line"><span class="string">d.logf(ERROR,</span></span><br><span class="line"><span class="string">"</span>DISKQUEUE(%s) positive depth at tail (%d), data loss, resetting <span class="number">0.</span>..<span class="string">",</span></span><br><span class="line"><span class="string">d.name, depth)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// force set depth 0</span></span><br><span class="line"><span class="string">atomic.StoreInt64(&amp;d.depth, 0)</span></span><br><span class="line"><span class="string">d.needSync = true</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 另外，若 depth == 0。</span></span><br><span class="line"><span class="string">// 但文件读取记录信息不合法 d.readFileNum != d.writeFileNum || d.readPos != d.writePos</span></span><br><span class="line"><span class="string">// 则跳过接下来需要被读或写的所有文件，类似于重置持久化存储的状态，格式化操作</span></span><br><span class="line"><span class="string">// 同时设置 needSync</span></span><br><span class="line"><span class="string">if d.readFileNum != d.writeFileNum || d.readPos != d.writePos &#123;</span></span><br><span class="line"><span class="string">if d.readFileNum &gt; d.writeFileNum &#123;</span></span><br><span class="line"><span class="string">d.logf(ERROR,</span></span><br><span class="line"><span class="string">"</span>DISKQUEUE(%s) readFileNum &gt; writeFileNum (%d &gt; %d), <span class="string">" \</span></span><br><span class="line"><span class="string">                   "</span>corruption, skipping to next writeFileNum and resetting <span class="number">0.</span>..<span class="string">",</span></span><br><span class="line"><span class="string">d.name, d.readFileNum, d.writeFileNum)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if d.readPos &gt; d.writePos &#123;</span></span><br><span class="line"><span class="string">d.logf(ERROR,</span></span><br><span class="line"><span class="string">"</span>DISKQUEUE(%s) readPos &gt; writePos (%d &gt; %d), corruption, <span class="string">"  \</span></span><br><span class="line"><span class="string">                   "</span>skipping to next writeFileNum and resetting <span class="number">0.</span>..<span class="string">",</span></span><br><span class="line"><span class="string">d.name, d.readPos, d.writePos)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">d.skipToNextRWFile()</span></span><br><span class="line"><span class="string">d.needSync = true</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125; // diskQueue.go</span></span><br></pre></td></tr></table></figure><p>当程序发现在<code>depth == 0</code>的情况下，即此时所有的消息已经被读取完毕，但若某个异常的情况下，可能会有：<code>readFileNum != writeFileNum || readPos != writePos</code>，则<code>diskQueue</code>会显式地删除掉接下来需要被读或写的所有文件，类似于重置持久化存储的状态或格式化操作。同时，<code>skipToNextRWFile</code>也可用作清空 <code>diskQueue</code>当前未读取的所有文件。具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 readFileNum 到 writeFileNum 之间的文件全部删除</span></span><br><span class="line"><span class="comment">// 将 readFileNum 设置为 writeFileNum</span></span><br><span class="line"><span class="comment">// 即将前面不正确的文件全部删除掉，重新开始读取</span></span><br><span class="line"><span class="comment">// 另外，其也可用作清空 diskQueue 当前未读取的所有文件的操作，重置 depth</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">skipToNextRWFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> d.readFile != <span class="literal">nil</span> &#123;</span><br><span class="line">d.readFile.Close()</span><br><span class="line">d.readFile = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> d.writeFile != <span class="literal">nil</span> &#123;</span><br><span class="line">d.writeFile.Close()</span><br><span class="line">d.writeFile = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := d.readFileNum; i &lt;= d.writeFileNum; i++ &#123;</span><br><span class="line">fn := d.fileName(i)</span><br><span class="line">innerErr := os.Remove(fn)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">d.writeFileNum++</span><br><span class="line">d.writePos = <span class="number">0</span></span><br><span class="line">d.readFileNum = d.writeFileNum</span><br><span class="line">d.readPos = <span class="number">0</span></span><br><span class="line">d.nextReadFileNum = d.writeFileNum</span><br><span class="line">d.nextReadPos = <span class="number">0</span></span><br><span class="line">atomic.StoreInt64(&amp;d.depth, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br></pre></td></tr></table></figure><p>至此，从<code>diskQueue</code>的文件系统中读取消息，并发送到上层应用程序的相关逻辑已经阐述完毕。除了需要清楚其读取核心逻辑外，还需要关注其对文件损坏的检测与处理。</p><h3 id="diskQueue-写入消息"><a href="#diskQueue-写入消息" class="headerlink" title="diskQueue 写入消息"></a>diskQueue 写入消息</h3><p>当<code>topic</code>或<code>channel</code>所维护的内存消息队列<code>memoryMsgChan</code>满了时，会通过调用<code>backend.Put</code>方法将消息写入到<code>diskQueue</code>。消息写入持久化存储的逻辑比从文件系统中读取一条消息的逻辑要简单。其关键步骤为先定位写入索引，同样是先写临时文件缓冲再执行数据刷新操作，最后需要更新<code>writePos</code>，当发现要切换写入文件时，还要更新<code>writeFileNum</code>。相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">ioLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 1-5.</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 6. 收到写入消息到磁盘的消息 (当应用程序调用 diskQueue.Put 方法时触发)</span></span><br><span class="line"><span class="keyword">case</span> dataWrite := &lt;-d.writeChan:</span><br><span class="line"><span class="comment">// 删除目前还未读取的文件，同时删除元数据文件</span></span><br><span class="line">d.emptyResponseChan &lt;- d.deleteAllFiles()</span><br><span class="line">count = <span class="number">0</span> <span class="comment">// 重置当前等待刷盘的消息数量</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个字节数组内容写入到持久化存储，同时更新读写位置信息，以及判断是否需要滚动文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">writeOne</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// 1. 若当前写入文件句柄为空，则需要先实例化</span></span><br><span class="line"><span class="keyword">if</span> d.writeFile == <span class="literal">nil</span> &#123;</span><br><span class="line">curFileName := d.fileName(d.writeFileNum)</span><br><span class="line">d.writeFile, err = os.OpenFile(curFileName, os.O_RDWR|os.O_CREATE, <span class="number">0600</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">d.logf(INFO, <span class="string">"DISKQUEUE(%s): writeOne() opened %s"</span>, d.name, curFileName)</span><br><span class="line"><span class="comment">// 2. 同时，若当前的写入索引大于0,则重新定位写入索引</span></span><br><span class="line"><span class="keyword">if</span> d.writePos &gt; <span class="number">0</span> &#123;</span><br><span class="line">_, err = d.writeFile.Seek(d.writePos, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 获取写入数据长度，并检查长度合法性。然后将数据写入到写入缓冲，</span></span><br><span class="line">    <span class="comment">// 最后将写入缓冲的数据一次性刷新到文件</span></span><br><span class="line">dataLen := <span class="keyword">int32</span>(<span class="built_in">len</span>(data))</span><br><span class="line"><span class="keyword">if</span> dataLen &lt; d.minMsgSize || dataLen &gt; d.maxMsgSize &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid message write size (%d) maxMsgSize=%d"</span>, </span><br><span class="line">                          dataLen, d.maxMsgSize)</span><br><span class="line">&#125;</span><br><span class="line">d.writeBuf.Reset()</span><br><span class="line">err = binary.Write(&amp;d.writeBuf, binary.BigEndian, dataLen)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">_, err = d.writeBuf.Write(data)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// only write to the file once</span></span><br><span class="line">_, err = d.writeFile.Write(d.writeBuf.Bytes())</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 更新写入索引 writePos 及 depth，且若 writePos 大于 maxBytesPerFile，</span></span><br><span class="line">    <span class="comment">// 则说明当前已经写入到文件的末尾。</span></span><br><span class="line"><span class="comment">// 因此需要更新 writeFileNum，重置 writePos，</span></span><br><span class="line">    <span class="comment">// 即更换到一个新的文件执行写入操作（为了避免一直写入单个文件）</span></span><br><span class="line"><span class="comment">// 且每一次更换到下一个文件，都需要将写入文件同步到磁盘</span></span><br><span class="line">totalBytes := <span class="keyword">int64</span>(<span class="number">4</span> + dataLen)</span><br><span class="line">d.writePos += totalBytes</span><br><span class="line">atomic.AddInt64(&amp;d.depth, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> d.writePos &gt; d.maxBytesPerFile &#123;</span><br><span class="line">d.writeFileNum++</span><br><span class="line">d.writePos = <span class="number">0</span></span><br><span class="line"><span class="comment">// sync every time we start writing to a new file</span></span><br><span class="line">err = d.sync()</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br></pre></td></tr></table></figure><h3 id="diskQueue-清空消息"><a href="#diskQueue-清空消息" class="headerlink" title="diskQueue 清空消息"></a>diskQueue 清空消息</h3><p>当应用程序调用<code>diskQueue.Empty</code>接口时，会将持久化存储<code>diskQueue</code>中的所有消息清空，并重置了所有状态属性信息，类似于一个格式化操作。还记得上面在阐述读取消息的流程中涉及到的<code>diskQueue.skipToNextRWFile</code>方法吗，它的一个作用就是删除<code>diskQueue</code>当前未读取的所有文件。除此之外，清空消息操作还删除了元数据文件。相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空 diskQueue 中未读取的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">d.RLock()</span><br><span class="line"><span class="keyword">defer</span> d.RUnlock()</span><br><span class="line"><span class="keyword">if</span> d.exitFlag == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br><span class="line">d.logf(INFO, <span class="string">"DISKQUEUE(%s): emptying"</span>, d.name)</span><br><span class="line">d.emptyChan &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> &lt;-d.emptyResponseChan</span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// diskQueue 消息处理主循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">ioLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 1-3.</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line">        <span class="comment">// ...    </span></span><br><span class="line"><span class="comment">// 5. 收到清空持久化存储 disQueue 的消息</span></span><br><span class="line"><span class="keyword">case</span> &lt;-d.emptyChan: <span class="comment">// (当应用程序调用 diskQueue.Empty 方法时触发)</span></span><br><span class="line"><span class="comment">// 删除目前还未读取的文件，同时删除元数据文件</span></span><br><span class="line">d.emptyResponseChan &lt;- d.deleteAllFiles()</span><br><span class="line">count = <span class="number">0</span> <span class="comment">// 重置当前等待刷盘的消息数量</span></span><br><span class="line"><span class="comment">// 6-8</span></span><br><span class="line">        <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 skipToNextRWFile 方法清空 readFileNum -&gt; writeFileNum 之间的文件，</span></span><br><span class="line"><span class="comment">// 并且设置 depth 为 0。 同时删除元数据文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">deleteAllFiles</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := d.skipToNextRWFile()</span><br><span class="line">innerErr := os.Remove(d.metaDataFileName())</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br></pre></td></tr></table></figure><h3 id="diskQueue-刷盘操作"><a href="#diskQueue-刷盘操作" class="headerlink" title="diskQueue 刷盘操作"></a>diskQueue 刷盘操作</h3><p>同大多的存储系统类似，<code>diskQueue</code>采用批量刷新缓冲区的操作来提高消息写入文件系统的性能。其中，<code>diskQueue</code>规定触发刷盘动作的有个条件，其中任一条件成立即可。一是当缓冲区中的消息的数量达到阈值(<code>syncEvery</code>)时，二是每隔指定时间(<code>syncTimeout</code>)。需要注意的一点为在执行刷盘动作，也会重新持久化<code>diskQueue</code>的元数据信息。相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">ioLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">syncTicker := time.NewTicker(d.syncTimeout)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// dont sync all the time :)</span></span><br><span class="line"><span class="comment">// 1. 只有写入缓冲中的消息达到一定数量，才执行同步刷新到磁盘的操作</span></span><br><span class="line"><span class="keyword">if</span> count == d.syncEvery &#123;</span><br><span class="line">d.needSync = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 刷新磁盘操作，重置计数信息，即将 writeFile 流刷新到磁盘，同时持久化元数据</span></span><br><span class="line"><span class="keyword">if</span> d.needSync &#123;</span><br><span class="line">err = d.sync()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">count = <span class="number">0</span> <span class="comment">// 重置当前等待刷盘的消息数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 4-6</span></span><br><span class="line">        <span class="comment">// ...    </span></span><br><span class="line"><span class="comment">// 7. 定时执行刷盘操作，在存在数据等待刷盘时，才需要执行刷盘动作</span></span><br><span class="line"><span class="keyword">case</span> &lt;-syncTicker.C:</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// avoid sync when there's no activity</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">d.needSync = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 8.</span></span><br><span class="line">        <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// diskQueue.go</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 同步刷新 writeFile 文件流（即将操作系统缓冲区中的数据写入到磁盘），同时持久化元数据信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *diskQueue)</span> <span class="title">sync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> d.writeFile != <span class="literal">nil</span> &#123;</span><br><span class="line">err := d.writeFile.Sync()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">err := d.persistMetaData()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 重置了刷新开关</span></span><br><span class="line">d.needSync = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单小结，本文详细分析了持久化消息队列存储组件——<code>diskQueue</code>，它被用作<code>nsq</code>的消息持久化存储。围绕<code>diskQueue</code>展开，通过阐述其提供给上层应用程序的功能接口来分析其工作原理，重点梳理了从<code>diskQueue</code>中读取和写消息的逻辑，同一般的队列实现类似，采用一组索引标记读写的位置，只不过<code>diskQueue</code>采用了两组读取索引。另外，在读取消息的过程检测文件是否被损坏，同时在写入过程中，通过不断切换文件来限制写入单个文件的数据量。<code>diskQueue</code>同样提供了清空存储的所有消息（删除所有文件，并重置<code>diskQueue</code>状态信息）的操作（类似于文件系统的格式化操作），最后不要忘记缓冲区的批量刷新刷盘动作助于提高文件系统的写入性能。更完整的源码注释可参考<a href="https://github.com/qqzeng/nsqio/tree/master/go-diskqueue" target="_blank" rel="noopener">这里</a>。</p><p>参考文献</p><p>[1].<a href="https://github.com/nsqio/go-diskqueue" target="_blank" rel="noopener">https://github.com/nsqio/go-diskqueue</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;diskQueue&lt;/code&gt;是&lt;code&gt;nsq&lt;/code&gt;分布式实时消息队列的消息持久化存储组件。考虑到&lt;code&gt;nsq&lt;/code&gt;为了限制消息积压所占的内存，同时也为了保证节点宕机消息尽可能丢失，因此，当内存消息队列&lt;code&gt;memoryMsgChan&lt;/code&gt;的长度达到配置的阈值时，会将消息写入到持久化存储消息队列中。是的，&lt;code&gt;diskQueue&lt;/code&gt;提供两个关键特性，一是持久化存储，二是队列接口。而在&lt;code&gt;nsq&lt;/code&gt;系统中&lt;code&gt;diskQueue&lt;/code&gt;的用法和&lt;code&gt;memoryMsgChan&lt;/code&gt;（&lt;code&gt;buffered go channel&lt;/code&gt;）基本上是相同的，因此，对于生产者或者消费者而言，消息的存储方式对于它们而言是透明的，它们只需要调用相应的接口投递或获取消息即可。这确实是数据存储的最佳实践。在此前的6篇文章已经将&lt;code&gt;nsq&lt;/code&gt;相关模块的源码阐述完毕。本文的主题是&lt;code&gt;diskQueue&lt;/code&gt;——持久化消息队列存储组件。重点阐述其实现原理，同时分析其为上层应用程序提供的接口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="消息队列" scheme="http://geoffen.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="分布式系统" scheme="http://geoffen.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="消息队列" scheme="http://geoffen.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>物联网的设备防伪认证</title>
    <link href="http://geoffen.github.io/2019/05/18/2019-05-18-%E7%89%A9%E8%81%94%E7%BD%91%E7%9A%84%E8%AE%BE%E5%A4%87%E9%98%B2%E4%BC%AA%E8%AE%A4%E8%AF%81/"/>
    <id>http://geoffen.github.io/2019/05/18/2019-05-18-物联网的设备防伪认证/</id>
    <published>2019-05-18T07:44:17.000Z</published>
    <updated>2019-11-07T10:24:47.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是防伪认证"><a href="#什么是防伪认证" class="headerlink" title="什么是防伪认证"></a>什么是防伪认证</h1><p>&emsp;&emsp;毫无疑问，是为了校验物联网产品的合法性，只有通过了合法性认证的物联网产品才能和物联网云建立连接。   </p><h1 id="为什么需要防伪认证"><a href="#为什么需要防伪认证" class="headerlink" title="为什么需要防伪认证"></a>为什么需要防伪认证</h1><p>&emsp;&emsp;物联网安全是物联网的重中之重，必须得到重视，而防伪认证时物联网安全的<strong>第一道门槛</strong>。  </p><h1 id="防伪模式有哪些"><a href="#防伪模式有哪些" class="headerlink" title="防伪模式有哪些"></a>防伪模式有哪些</h1><ol><li><strong>密钥认证模式</strong></li><li><strong>签名认证模式</strong></li></ol><a id="more"></a><h1 id="如何实现防伪认证"><a href="#如何实现防伪认证" class="headerlink" title="如何实现防伪认证"></a>如何实现防伪认证</h1><h2 id="密钥认证模式"><a href="#密钥认证模式" class="headerlink" title="密钥认证模式"></a>密钥认证模式</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>&emsp;&emsp;物联网平台给每一个设备或者每一型号设备分配固定的<strong>产品ID</strong>和<strong>产品密钥</strong>，将SN码，MAC地址，产品ID和产品密钥四个参数写入flash，当设备注册时，携带以上四个参数请求物联网云，物联网云认证数据正确性之后，再响应<code>auth_token</code>和分配连接地址，每一次数据上传都需要携带<code>auth_token</code>。  </p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://assets.processon.com/chart_image/5cdfbd4ee4b00446dc694dac.png" alt="物联网设备密钥防伪认证" title="物联网设备密钥防伪认证"></p><h2 id="签名认证模式"><a href="#签名认证模式" class="headerlink" title="签名认证模式"></a>签名认证模式</h2><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>&emsp;&emsp;物联网平台给每一个设备的SN码和MAC地址进行私钥签名（如<strong>ECDSA_sign</strong>），将SN码，MAC地址和签名三个参数写入<code>flash</code>，当设备注册时，携带以上三个参数请求物联网云，然后物联网云进行公钥校验（如<strong>ECDSA_verify</strong>），再响应<code>auth_token</code>和分配连接地址，每一次数据上传都需要携带<code>auth_token</code>。  </p><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://assets.processon.com/chart_image/5cde7588e4b006c6eaa177c5.png" alt="物联网设备签名防伪认证" title="物联网设备签名防伪认证"></p><h2 id="两种模式比较"><a href="#两种模式比较" class="headerlink" title="两种模式比较"></a>两种模式比较</h2><table><thead><tr><th>模式</th><th>性能</th><th>安全</th><th>备注</th></tr></thead><tbody><tr><td>密钥认证模式</td><td>低</td><td>中</td><td>1. 需要查询数据或者缓存，增加服务端负载； 2. 需要提前将数据产生并持久化，要防止出现重复数据，生产烧写flash时进行下发数据；</td></tr><tr><td>签名认证模式</td><td>高</td><td>高</td><td>1. 要求硬件高性能的加密方式保存签名；2. 动态数字签名消耗的性能也不低，固定签名的数据需要持久化，也需要生产烧写flash时进行下发数据；</td></tr></tbody></table><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cnblogs.com/fishou/p/4175509.html" target="_blank" rel="noopener">智能硬件设备防伪设计</a><br><a href="https://help.aliyun.com/document_detail/42649.html?spm=a2c4g.11186623.6.641.5b495483ULe3ox" target="_blank" rel="noopener">阿里云文档</a><br><a href="https://smartdev.jd.com/docCenterDoc/view/2/102/134000001/134000001#topMaoDot" target="_blank" rel="noopener">京东小京鱼文档</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是防伪认证&quot;&gt;&lt;a href=&quot;#什么是防伪认证&quot; class=&quot;headerlink&quot; title=&quot;什么是防伪认证&quot;&gt;&lt;/a&gt;什么是防伪认证&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;毫无疑问，是为了校验物联网产品的合法性，只有通过了合法性认证的物联网产品才能和物联网云建立连接。   &lt;/p&gt;
&lt;h1 id=&quot;为什么需要防伪认证&quot;&gt;&lt;a href=&quot;#为什么需要防伪认证&quot; class=&quot;headerlink&quot; title=&quot;为什么需要防伪认证&quot;&gt;&lt;/a&gt;为什么需要防伪认证&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;物联网安全是物联网的重中之重，必须得到重视，而防伪认证时物联网安全的&lt;strong&gt;第一道门槛&lt;/strong&gt;。  &lt;/p&gt;
&lt;h1 id=&quot;防伪模式有哪些&quot;&gt;&lt;a href=&quot;#防伪模式有哪些&quot; class=&quot;headerlink&quot; title=&quot;防伪模式有哪些&quot;&gt;&lt;/a&gt;防伪模式有哪些&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;密钥认证模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;签名认证模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="万物互联" scheme="http://geoffen.github.io/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>nsq 消息发送订阅源码简析</title>
    <link href="http://geoffen.github.io/2019/05/15/nsq-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E8%AE%A2%E9%98%85%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    <id>http://geoffen.github.io/2019/05/15/nsq-消息发送订阅源码简析/</id>
    <published>2019-05-15T05:38:28.000Z</published>
    <updated>2019-11-07T10:24:47.404Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章阐述了<code>channel</code>模块的源码。以<code>channel</code>为核心分析<code>channel</code>结构组件、<code>channel</code>实例的创建、删除以及查找这四方面的源码逻辑，另外也简要分析了<code>Message</code>结构的字段，以及两个与消息发送相关的优先级队列<code>in-flight queue</code>和<code>deferred queue</code>。同时也将对应方法与其它方法进行串联分析，以在整体上把握程序逻辑。本文的主题是<code>nsq</code>消息队列系统中消息的发送和订阅相关源码的逻辑。本文的核心是阐述，当生产者将消息投递到某个<code>nsqd</code>实例上对应的<code>topic</code>时，消息是如何在<code>nsqd</code>内部各组件（包括<code>nsqd</code>、<code>topic</code>和<code>chanel</code>）之间流动的，并且分析<code>nsq</code>是如何处理延时消息的投递。另外，结合网络传输模块的源码，分析两个典型的过程：生产者发布消息的逻辑，以及消费者是订阅并获取消息的逻辑。此篇文章内容较前两篇复杂，它是<code>nsq</code>实时消息队列的核心部分，对理解<code>nsq</code>的关键工作原理至关重要。</p><a id="more"></a><p>本文阐述的内容更详细的源码注释可在<a href="https://github.com/qqzeng/nsqio/tree/master/nsq" target="_blank" rel="noopener">这里</a>找到，注释源码版本为<code>v1.1.0</code>，仅供参考。本文所涉及到源码文件主要为<code>/nsq/nsqd/</code>和<code>/nsq/internal/</code>下的若干子目录。具体而言，围绕<code>nsqd.go</code>、<code>topic.go</code>、<code>channel.go</code>展开，同时也会涉及到<code>protocol_v2.go</code>和<code>http.go</code>。</p><p>本文侧重于分析消息在<code>nsq</code>系统内部各组件之间是如何流动的，典型地，如消息是何时通过何种方式从<code>topic</code>实例流向<code>channel</code>实例的，另外，如何实现消息的延时投递逻辑，消息投递超时处理逻辑等。另外，也分析生产者是发布消息的到指定的<code>topic</code>的逻辑，以及消费者是订阅<code>channel</code>的逻辑，并且如何从订阅的<code>channel</code>收到消息。最后阐述客户端（生产者和消费者）使用的几个典型的命令请求。</p><h2 id="topic-消息处理逻辑"><a href="#topic-消息处理逻辑" class="headerlink" title="topic 消息处理逻辑"></a>topic 消息处理逻辑</h2><p>我们依据正常的消息发布的流程来阐述，以<code>topic</code>作为切入点，分析<code>topic</code>如何将从生产者收到的消息传递给与其关联的<code>channel</code>实例。当生产者发布一条消息到指定的<code>topic</code>时，请求在<code>protocolV2(protocol_v2.go)</code>实例接收，然后交由<code>protocolV2.PUB</code>方法处理，其接着调用<code>topic.PutMessage</code>方法向<code>topic</code>实例添加一条消息，由此消息就正式进入了<code>nsq</code>系统内部了。<code>PutMessage</code>方法通过调用<code>put</code>方法将接收的消息写入到消息队列，若内存消息队列(<code>memoryMsgChan</code>)未满，则 push 到内存消息队列，否则 push 到持久化存储消息队列(<code>backend</code>)。然后在<code>topic</code>的消息处理主循环中，从<code>memoryMsgChan</code>或<code>backendChan</code>管道中接收到新的消息，其随即遍历自己维护的所有<code>channel</code>实例，将此消息副本发送给每一个<code>channel</code>实例，即调用<code>chanel.PutMessage</code>将消息压入到<code>channel</code>维护的消息队列中（同样包括<code>memoryMsgChan</code>和<code>backend</code>两个），或者若此消息需要被延迟，则调用<code>channel.PutMessageDeferred</code>方法将消息压入到消息延时的优先级队列(<code>deferred queue</code>)。</p><p>好，<code>topic</code>处理消息的核心逻辑已经阐述完毕。我们贴出这个过程中消息流动所涉及到的方法调用链：<code>protocolV2.PUB-&gt;topic.PutMessage-&gt;topic.put-&gt;topic.messagPump-&gt;</code>，从这里开始分叉，对于正常的消息：<code>channel.PutMessage-&gt;channel.put</code>，最后写入<code>channel.memoryMsgChan</code>或<code>channel.backend</code>；对于被延时的消息：<code>channel.PutMessageDeferred-&gt;channel.StartDeferredTimeout-&gt;chanel.addToDeferredPQ-&gt;deferredPQ.push</code>。</p><p>核心流程如上所述，补充几点，<code>topic.messagePump</code>方法在<code>topic</code>启动（有可能是从配置文件中加载启动<code>LoadMetadata</code>或新创建时启动<code>GetTopic</code>）时开始工作，换言之，开始处理生产者给它发送的消息。另外，<code>messagePump</code>循环中也可能收到<code>topic</code>所维护的<code>channel</code>集合更新的消息（添加或移除），此时需要重新初始化两个消息队列管道(<code>memoryMsgChan &amp; backendChan</code>)。最后，当收到<code>paused</code>的消息时，会重置这两个消息队列管道，因为一旦<code>topic.Paused</code>属性被设置，则表示此<code>topic</code>不应该再处理消息。相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [ topic.go 文件中，由 topic 实例的消息处理逻辑 ]</span></span><br><span class="line"><span class="comment">// 此方法由 httpServer.PUB 或 protocolV2.PUB 方法中调用，即生产者通过 http/tcp 投递消息到 topic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">PutMessage</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">t.RLock()</span><br><span class="line"><span class="keyword">defer</span> t.RUnlock()</span><br><span class="line"><span class="comment">// 1. 消息写入操作只在 exitFlag 为0时才进行</span></span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt32(&amp;t.exitFlag) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 写入消息内存队列 memoryMsgChan 或者 持久化存储 backend</span></span><br><span class="line">err := t.put(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 更新当前 topic 所对应的消息数量以及消息总大小</span></span><br><span class="line">atomic.AddUint64(&amp;t.messageCount, <span class="number">1</span>)</span><br><span class="line">atomic.AddUint64(&amp;t.messageBytes, <span class="keyword">uint64</span>(<span class="built_in">len</span>(m.Body)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/topic.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定消息进行持久化</span></span><br><span class="line"><span class="comment">// 通常情况下，在 memoryMsChan 未达到其设置的最大的消息的数量时</span></span><br><span class="line"><span class="comment">// （即内存中的消息队列中保存的消息的数量未达到上限时，由 MemQueueSize 指定）</span></span><br><span class="line"><span class="comment">// 会先将消息 push 到内在消息队列 memoryChan 中，否则会被 push 到后端持久化队列 backend 中。</span></span><br><span class="line"><span class="comment">// 这是通过 go buffered channel 语法来实现。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">put</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.memoryMsgChan &lt;- m:</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 内存消息队列已满时，会将消息存放到持久化存储</span></span><br><span class="line"><span class="comment">// 从缓冲池中获取缓冲</span></span><br><span class="line">b := bufferPoolGet()</span><br><span class="line"><span class="comment">// 将消息写入持久化消息队列</span></span><br><span class="line">err := writeMessageToBackend(b, m, t.backend)</span><br><span class="line">bufferPoolPut(b) <span class="comment">// 回收从缓冲池中获取的缓冲</span></span><br><span class="line">t.ctx.nsqd.SetHealth(err)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.ctx.nsqd.logf(LOG_ERROR,</span><br><span class="line"><span class="string">"TOPIC(%s) ERROR: failed to write message to backend - %s"</span>,</span><br><span class="line">t.name, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;  <span class="comment">// /nsq/nsqd/topic.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// messagePump 监听 message 的更新的一些状态，以及时将消息持久化，</span></span><br><span class="line"><span class="comment">// 同时写入到此 topic 对应的channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">messagePump</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> msg *Message</span><br><span class="line"><span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> chans []*Channel</span><br><span class="line"><span class="keyword">var</span> memoryMsgChan <span class="keyword">chan</span> *Message</span><br><span class="line"><span class="keyword">var</span> backendChan <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 等待开启 topic 消息处理循环，即等待调用 topic.Start，</span></span><br><span class="line">    <span class="comment">// 在 nsqd.GetTopic 和 nsqd.LoadMetadata 方法中调用</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.channelUpdateChan:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.pauseChan:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.exitChan:</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line"><span class="comment">// 在 nsqd.Main 中最后一个阶段会开启消息处理循环 topic.Start</span></span><br><span class="line">            <span class="comment">// （处理由客户端（producers）向 topci 投递的消息）</span></span><br><span class="line"><span class="comment">// 在此之前的那些信号全部忽略</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.startChan:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">t.RLock()</span><br><span class="line"><span class="comment">// 2. 根据 topic.channelMap 初始化两个通道 memoryMsgChan，backendChan</span></span><br><span class="line"><span class="comment">// 并且保证 topic.channelMap 存在 channel，且 topic 未被 paused</span></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> t.channelMap &#123;</span><br><span class="line">chans = <span class="built_in">append</span>(chans, c)</span><br><span class="line">&#125;</span><br><span class="line">t.RUnlock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(chans) &gt; <span class="number">0</span> &amp;&amp; !t.IsPaused() &#123;</span><br><span class="line">memoryMsgChan = t.memoryMsgChan</span><br><span class="line">backendChan = t.backend.ReadChan()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. topic 处理消息的主循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 3.1 从内存消息队列 memoryMsgChan 或 持久化存储 backend 中收到消息</span></span><br><span class="line"><span class="comment">// 则将消息解码，然后会将消息 push 到此 topic 关联的所有 channel</span></span><br><span class="line"><span class="keyword">case</span> msg = &lt;-memoryMsgChan:</span><br><span class="line"><span class="keyword">case</span> buf = &lt;-backendChan:</span><br><span class="line">msg, err = decodeMessage(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.ctx.nsqd.logf(LOG_ERROR, <span class="string">"failed to decode message - %s"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.2 当从 channelUpdateChan 读取到消息时，</span></span><br><span class="line">            <span class="comment">// 表明有 channel 更新，比如创建了新的 channel，</span></span><br><span class="line"><span class="comment">// 因此需要重新初始化 memoryMsgChan及 backendChan</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.channelUpdateChan:</span><br><span class="line">chans = chans[:<span class="number">0</span>]</span><br><span class="line">t.RLock()</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> t.channelMap &#123;</span><br><span class="line">chans = <span class="built_in">append</span>(chans, c)</span><br><span class="line">&#125;</span><br><span class="line">t.RUnlock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(chans) == <span class="number">0</span> || t.IsPaused() &#123;</span><br><span class="line">memoryMsgChan = <span class="literal">nil</span></span><br><span class="line">backendChan = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memoryMsgChan = t.memoryMsgChan</span><br><span class="line">backendChan = t.backend.ReadChan()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment">// 3.3 当收到 pause 消息时，则将 memoryMsgChan及backendChan置为 nil，注意不能 close，</span></span><br><span class="line"><span class="comment">// 二者的区别是 nil的chan不能接收消息了，但不会报错。</span></span><br><span class="line">            <span class="comment">// 而若从一个已经 close 的 chan 中尝试取消息，则会 panic。</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.pauseChan:</span><br><span class="line"><span class="comment">// 当 topic 被 paused 时，其不会将消息投递到 channel 的消息队列</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(chans) == <span class="number">0</span> || t.IsPaused() &#123;</span><br><span class="line">memoryMsgChan = <span class="literal">nil</span></span><br><span class="line">backendChan = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memoryMsgChan = t.memoryMsgChan</span><br><span class="line">backendChan = t.backend.ReadChan()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment">// 3.4 当调用 topic.exit 时会收到信号，以终止 topic 的消息处理循环</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.exitChan:</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 当从 memoryMsgChan 或 backendChan 中 pull 到一个 msg 后，会执行这里：</span></span><br><span class="line"><span class="comment">// 遍历 channelMap 中的每一个 channel，将此 msg 拷贝到 channel 中的后备队列。</span></span><br><span class="line"><span class="comment">// 注意，因为每个 channel 需要一个独立 msg，因此需要在拷贝时需要创建 msg 的副本</span></span><br><span class="line"><span class="comment">// 同时，针对 msg 是否需要被延时投递来选择将 msg 放到</span></span><br><span class="line">        <span class="comment">// 延时队列 deferredMessages中还是 in-flight queue 中</span></span><br><span class="line"><span class="keyword">for</span> i, channel := <span class="keyword">range</span> chans &#123;</span><br><span class="line">chanMsg := msg</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &#123; <span class="comment">// 若此 topic 只有一个 channel，则不需要显式地拷贝了</span></span><br><span class="line">chanMsg = NewMessage(msg.ID, msg.Body)</span><br><span class="line">chanMsg.Timestamp = msg.Timestamp</span><br><span class="line">chanMsg.deferred = msg.deferred</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 msg push 到 channel 所维护的延时消息队列 deferred queue</span></span><br><span class="line"><span class="comment">// 等待消息的延时时间走完后，会把消息进一步放入到 in-flight queue 中</span></span><br><span class="line"><span class="keyword">if</span> chanMsg.deferred != <span class="number">0</span> &#123;</span><br><span class="line">channel.PutMessageDeferred(chanMsg, chanMsg.deferred)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 msg push 到普通消息队列 in-flight queue</span></span><br><span class="line">err := channel.PutMessage(chanMsg)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">exit:</span><br><span class="line">t.ctx.nsqd.logf(LOG_INFO, <span class="string">"TOPIC(%s): closing ... messagePump"</span>, t.name)</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/topic.go</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [ channel.go 文件中，topic 发送消息到 in-flight queue 相关逻辑 ]</span></span><br><span class="line"><span class="comment">// 此方法会由 topic.messagePump 方法中调用。</span></span><br><span class="line"><span class="comment">// 即当 topic 收到生产者投递的消息时，将此消息放到与其关联的 channels 的延迟队列 deferred queue</span></span><br><span class="line"><span class="comment">// 或者 普通的消息队列中(包括 内存消息队列 memoryMsgChan 或 后端持久化 backend)（即此方法）</span></span><br><span class="line"><span class="comment">// channel 调用 put 方法将消息放到消息队列中，同时更新消息计数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">PutMessage</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.RUnlock()</span><br><span class="line"><span class="keyword">if</span> c.Exiting() &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br><span class="line">err := c.put(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">atomic.AddUint64(&amp;c.messageCount, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br><span class="line"><span class="comment">// 同 topic.put 方法类似，其在 put message 时，</span></span><br><span class="line"><span class="comment">// 依据实际情况将消息 push 到内在队列 memoryMsgChan 或者后端持久化 backend</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">put</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c.memoryMsgChan &lt;- m:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">b := bufferPoolGet()</span><br><span class="line">err := writeMessageToBackend(b, m, c.backend)</span><br><span class="line">bufferPoolPut(b)</span><br><span class="line">c.ctx.nsqd.SetHealth(err)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [ channel.go 文件中，topic 发送消息到 deferred queue 相关逻辑 ]</span></span><br><span class="line"><span class="comment">// 将 message 添加到 deferred queue 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">PutMessageDeferred</span><span class="params">(msg *Message, timeout time.Duration)</span></span> &#123;</span><br><span class="line">atomic.AddUint64(&amp;c.messageCount, <span class="number">1</span>)</span><br><span class="line">c.StartDeferredTimeout(msg, timeout)</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 message 加入到 deferred queue 中，等待被 queueScanWorker 处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">StartDeferredTimeout</span><span class="params">(msg *Message, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 计算超时超时戳，作为 Priority</span></span><br><span class="line">absTs := time.Now().Add(timeout).UnixNano()</span><br><span class="line"><span class="comment">// 2. 构造 item</span></span><br><span class="line">item := &amp;pqueue.Item&#123;Value: msg, Priority: absTs&#125;</span><br><span class="line"><span class="comment">// 3. item 添加到 deferred 字典</span></span><br><span class="line">err := c.pushDeferredMessage(item)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 将 item 放入到 deferred message 优先级队列</span></span><br><span class="line">c.addToDeferredPQ(item)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">addToDeferredPQ</span><span class="params">(item *pqueue.Item)</span></span> &#123;</span><br><span class="line">c.deferredMutex.Lock()</span><br><span class="line">heap.Push(&amp;c.deferredPQ, item)</span><br><span class="line">c.deferredMutex.Unlock()</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br></pre></td></tr></table></figure><p>至此，关于<code>topic</code>如何处理消息，如何将消息传递给<code>channel</code>已经讲述完毕，接下来，分析对于那些超时的消息应该如何处理，<code>deferred queue</code>中存储的延时投递的消息如何发送给客户端。这涉及到<code>nsqd.go</code>文件中<code>nsqd</code>实例的消息处理主循环，它循环扫描所有的<code>channel</code>关联的两个消息队列中的消息，并做针对性处理。</p><h2 id="nsqd-消息处理循环"><a href="#nsqd-消息处理循环" class="headerlink" title="nsqd 消息处理循环"></a>nsqd 消息处理循环</h2><p>在<code>nsqd</code>源码分析的文章中，没有涉及到<code>nsqd</code>消息处理循环相关的逻辑，考虑到在介绍之前必须要先了解<code>topic</code>及<code>channel</code>的相关功能。因此，把<code>nsqd</code>关于消息处理的部分单独开篇文章介绍。在<code>nsqd.Main</code>启动方法中，异步开启三个处理循环：<code>nsqd.queueScanLoop</code>、<code>nsqd.lookupLoop</code>和<code>nsqd.statsLoop</code>，分别作为消息处理循环，同<code>nsqlookupd</code>通信交互循环，以及数据统计循环。在<code>nsqd.queueScanLoop</code>方法中：</p><p>它首先根据配置文件参数初始化了一些重要属性：<code>workTicker</code>根据<code>QueueScanInterval</code>初始化，表示每隔<code>QueueScanInterval</code>的时间（默认<code>100ms</code>），<code>nsqd</code>随机挑选<code>QueueScanSelectionCount</code>数量的<code>channel</code>执行<code>dirty channel</code>的计数统计；另外<code>refreshTicker</code>根据<code>QueueScanRefreshInterval</code>初始化，每过<code>QueueScanRefreshInterval</code>时间（默认<code>5s</code>）就调整<code>queueScanWorker pool</code>的大小。之后，</p><p><code>queueScanLoop</code>的任务是处理发送中的消息队列(<code>in-flight queue</code>)，以及被延迟发送的消息队列(<code>deferred queue</code>)两个优先级消息队列中的消息。具体而言，它循环执行两个定时任务：</p><ul><li><p>其一，由<code>workTicker</code>计时器触发，每过<code>QueueScanInterval</code>（默认为<code>100ms</code>）的时间，就从本地的消息缓存队列中（<code>nsqd</code>维护的所有<code>topic</code>所关联的<code>channel</code>集合），随机选择<code>QueueScanSelectionCount</code>（默认<code>20</code>）个<code>channel</code>。检查这些<code>channel</code>集合中被标记为<code>dirty</code>属性的<code>channel</code>的数量，所谓的<code>dirty channel</code>即表示此<code>channel</code>实例中存在消息需要处理，这包含两个方面的处理逻辑：</p><ul><li>对于<code>in-flight queue</code>而言，检查消息是否已经处理超时（消费者处理超时），若存在超时的消息，则将消息从<code>in-flight queue</code>中移除，并重新将它压入到此<code>channel</code>的消息队列中(<code>memoryMsgChan</code>或<code>backend</code>)，等待后面重新被发送（即之后还会被重新压入到<code>in-flight queue</code>中），此为消息发送超时的处理逻辑。</li><li>对于<code>deferred queue</code>而言，检查消息的延迟时间是否已经走完，换言之，检查被延迟的消息现在是否应该发送给消费者了。若某个被延时的消息的延时时间已经达到，则将它从<code>deferred queue</code>中移除，并重新压入到此<code>channel</code>的消息队列中(<code>memoryMsgChan</code>或<code>backend</code>)，等待后面正式被发送（即之后还会被重新压入到<code>in-flight queue</code>中），此为消息延迟发送超时的处理逻辑。</li></ul><p>若处理的结果显示，<code>dirty channel</code>的数量超过<code>QueueScanDirtyPercent</code>（默认<code>25%</code>）的比例，则再次随机选择<code>QueueScanSelectionCount</code>（默认<code>20</code>）个<code>channel</code>，并让<code>queueScanWorker</code>对它们进行处理。</p></li><li><p>另一个定时任何由<code>refreshTicker</code>计时器触发，每过<code>QueueScanRefreshInterval</code>（默认<code>5s</code>）的时间，就调整<code>queueScanWorker pool</code>的大小。具体的调整措施为：</p><ul><li>若现有的<code>queueScanWorker</code>的数量低于理想值（<code>nsqd</code>包含的<code>channel</code>集合的总数的<code>1/4</code>，程序硬编码），则显式地增加<code>queueScanWorker</code>的数量，即异步执行<code>queueScanWorker</code>方法。</li><li>否则，若现有的<code>queueScanWorker</code>数量高于理想值，则通过<code>exitCh</code>显式地结束执行<code>queueScanWorker</code>方法。</li></ul><p>所谓的<code>queueScanWorker</code>实际上只是一个循环消息处理的方法，一旦它从<code>workCh</code>管道接收到消息，则会开始处理<code>in-fligth queue</code>和<code>deferred queue</code>中的消息，最后将处理结果，即队列中是否存在<code>dirty channel</code>通过<code>responseCh</code>通知给<code>queeuScanLoop</code>主循环。</p></li></ul><p>上述逻辑即为<code>nsqd</code>对两个消息队列(<code>in-flight queue</code>和<code>deferred queue</code>)的核心处理逻辑。相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queueScanLoop 方法在一个单独的 go routine 中运行。</span></span><br><span class="line"><span class="comment">// 用于处理正在发送的 in-flight 消息以及被延迟处理的 deferred 消息</span></span><br><span class="line"><span class="comment">// 它管理了一个 queueScanWork pool，其默认数量为5。queueScanWorker 可以并发地处理 channel。</span></span><br><span class="line"><span class="comment">// 它借鉴了Redis随机化超时的策略，即它每 QueueScanInterval 时间（默认100ms）就从本地的缓存队列中</span></span><br><span class="line"><span class="comment">// 随机选择 QueueScanSelectionCount 个（默认20个） channels。</span></span><br><span class="line"><span class="comment">// 其中 缓存队列每间隔  QueueScanRefreshInterval 还会被刷新。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">queueScanLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 获取随机选择的 channel 的数量，以及队列扫描的时间间隔，及队列刷新时间间隔</span></span><br><span class="line">workCh := <span class="built_in">make</span>(<span class="keyword">chan</span> *Channel, n.getOpts().QueueScanSelectionCount)</span><br><span class="line">responseCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, n.getOpts().QueueScanSelectionCount)</span><br><span class="line">closeCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">workTicker := time.NewTicker(n.getOpts().QueueScanInterval)</span><br><span class="line">refreshTicker := time.NewTicker(n.getOpts().QueueScanRefreshInterval)</span><br><span class="line"><span class="comment">// 2. 获取 nsqd 所包含的 channel 集合，一个 topic 包含多个 channel，</span></span><br><span class="line">    <span class="comment">// 而一个 nsqd 实例可包含多个 topic 实例</span></span><br><span class="line">channels := n.channels()</span><br><span class="line">n.resizePool(<span class="built_in">len</span>(channels), workCh, responseCh, closeCh)</span><br><span class="line"><span class="comment">// 3. 这个循环中的逻辑就是依据配置参数，</span></span><br><span class="line">    <span class="comment">// 反复处理 nsqd 所维护的 topic 集合所关联的 channel 中的消息</span></span><br><span class="line"><span class="comment">// 即循环处理将 channel 从 topic 接收到的消息，发送给订阅了对应的 channel 的客户端</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 3.1 每过 QueueScanInterval 时间（默认100ms），</span></span><br><span class="line">            <span class="comment">// 则开始随机挑选 QueueScanSelectionCount 个 channel。转到 loop: 开始执行</span></span><br><span class="line"><span class="keyword">case</span> &lt;-workTicker.C:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(channels) == <span class="number">0</span> &#123; <span class="comment">// 此 nsqd 没有包含任何 channel　实例当然就不用处理了</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.2 每过 QueueScanRefreshInterval 时间（默认5s），</span></span><br><span class="line">            <span class="comment">// 则调整 pool 的大小，即调整开启的 queueScanWorker 的数量为 pool 的大小</span></span><br><span class="line"><span class="keyword">case</span> &lt;-refreshTicker.C:</span><br><span class="line">channels = n.channels()</span><br><span class="line">n.resizePool(<span class="built_in">len</span>(channels), workCh, responseCh, closeCh)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment">// 3.3 nsqd 已退出</span></span><br><span class="line"><span class="keyword">case</span> &lt;-n.exitChan:</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line">num := n.getOpts().QueueScanSelectionCount</span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="built_in">len</span>(channels) &#123;</span><br><span class="line">num = <span class="built_in">len</span>(channels)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.4 利用 util.UniqRands，随机选取 num（QueueScanSelectionCount 默认20个）channel</span></span><br><span class="line"><span class="comment">// 将它们 push 到 workCh 管道，queueScanWorker 中会收到此消息，</span></span><br><span class="line">        <span class="comment">// 然后立即处理 in-flight queue 和 deferred queue 中的消息。</span></span><br><span class="line"><span class="comment">// 注意，因为这里是随机抽取 channel 因此，有可能被选中的 channel 中并没有消息</span></span><br><span class="line">loop:</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> util.UniqRands(num, <span class="built_in">len</span>(channels)) &#123;</span><br><span class="line">workCh &lt;- channels[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.5 统计 dirty 的 channel 的数量， responseCh 管道在上面的 nsqd.resizePool 方法中</span></span><br><span class="line">        <span class="comment">// 传递给了 len(channels) * 0.25 个 queueScanWorker。</span></span><br><span class="line"><span class="comment">// 它们会在循环中反复查看两个消息优先级队列中是否有消息等待被处理： </span></span><br><span class="line">        <span class="comment">// 即查看 inFlightPQ 和 deferredPQ。</span></span><br><span class="line">numDirty := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> &lt;-responseCh &#123;</span><br><span class="line">numDirty++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.6 若其 dirtyNum 的比例超过配置的 QueueScanDirtyPercent（默认为25%）</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">float64</span>(numDirty)/<span class="keyword">float64</span>(num) &gt; n.getOpts().QueueScanDirtyPercent &#123;</span><br><span class="line"><span class="keyword">goto</span> loop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">n.logf(LOG_INFO, <span class="string">"QUEUESCAN: closing"</span>)</span><br><span class="line"><span class="built_in">close</span>(closeCh)</span><br><span class="line">workTicker.Stop()</span><br><span class="line">refreshTicker.Stop()</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/nsqd.go</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整 queueScanWorker 的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">resizePool</span><span class="params">(num <span class="keyword">int</span>, workCh <span class="keyword">chan</span> *Channel, responseCh <span class="keyword">chan</span> <span class="keyword">bool</span>, closeCh <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 根据 channel 的数量来设置合适的 pool size，默认为 1/4 的 channel 数量</span></span><br><span class="line">idealPoolSize := <span class="keyword">int</span>(<span class="keyword">float64</span>(num) * <span class="number">0.25</span>)</span><br><span class="line"><span class="keyword">if</span> idealPoolSize &lt; <span class="number">1</span> &#123;</span><br><span class="line">idealPoolSize = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> idealPoolSize &gt; n.getOpts().QueueScanWorkerPoolMax &#123;</span><br><span class="line">idealPoolSize = n.getOpts().QueueScanWorkerPoolMax</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 开启一个循环，直到理想的 pool size 同实际的 pool size 相同才退出。</span></span><br><span class="line"><span class="comment">// 否则，若理想值更大，则需扩展已有的 queueScanWorker 的数量，</span></span><br><span class="line"><span class="comment">// 即在一个单独的 goroutine 中调用一次 nsqd.queueScanWorker 方法（开启了一个循环）。</span></span><br><span class="line"><span class="comment">// 反之， 需要减少已有的 queueScanWorker 的数量，</span></span><br><span class="line">    <span class="comment">// 即往 closeCh 中 push 一条消息，强制 queueScanWorker goroutine 退出</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> idealPoolSize == n.poolSize &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> idealPoolSize &lt; n.poolSize &#123;</span><br><span class="line"><span class="comment">// contract</span></span><br><span class="line">closeCh &lt;- <span class="number">1</span></span><br><span class="line">n.poolSize--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// expand</span></span><br><span class="line">n.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">n.queueScanWorker(workCh, responseCh, closeCh)</span><br><span class="line">&#125;)</span><br><span class="line">n.poolSize++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// /nsq/nsqd/nsqd.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 queueScanLoop 中处理 channel 的具体就是由 queueScanWorker 来负责。</span></span><br><span class="line"><span class="comment">// 调用方法 queueScanWorker 即表示新增一个  queueScanWorker goroutine 来处理 channel。</span></span><br><span class="line"><span class="comment">// 一旦开始工作 (从 workCh 中收到了信号， 即 dirty 的 channel 的数量达到阈值)，</span></span><br><span class="line"><span class="comment">// 则循环处理 in-flight queue 和 deferred queue 中的消息，</span></span><br><span class="line"><span class="comment">// 并将处理结果（即是否是 dirty channel）通过 reponseCh 反馈给 queueScanWorker。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">queueScanWorker</span><span class="params">(workCh <span class="keyword">chan</span> *Channel, responseCh <span class="keyword">chan</span> <span class="keyword">bool</span>, closeCh <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 开始处理两个消息队列中的消息</span></span><br><span class="line"><span class="keyword">case</span> c := &lt;-workCh:</span><br><span class="line">now := time.Now().UnixNano()</span><br><span class="line">dirty := <span class="literal">false</span></span><br><span class="line"><span class="comment">// 若返回true，则表明　in-flight 优先队列中有存在处理超时的消息，</span></span><br><span class="line"><span class="comment">// 因此将消息再次写入到　内存队列 memoryMsgChan　或 后端持久化　backend</span></span><br><span class="line"><span class="comment">// 等待消息被重新投递给消费者（重新被加入到 in-flight queue）</span></span><br><span class="line"><span class="keyword">if</span> c.processInFlightQueue(now) &#123;</span><br><span class="line">dirty = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若返回 true，则表明　deferred 优先队列中存在延时时间已到的消息，</span></span><br><span class="line">            <span class="comment">// 因此需要将此消息从 deferred queue 中移除，</span></span><br><span class="line"><span class="comment">// 并将消息重新写入到　内存队列 memoryMsgChan　或后端持久化　backend</span></span><br><span class="line">            <span class="comment">// 等待消息被正式投递给消费者 （正式被加入到 in-flight queue）</span></span><br><span class="line"><span class="keyword">if</span> c.processDeferredQueue(now) &#123;</span><br><span class="line">dirty = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报告 queueScanLoop 主循环，发现一个 dirty channel</span></span><br><span class="line">responseCh &lt;- dirty</span><br><span class="line"><span class="comment">// 退出处理循环，缩减 queueScanWorker 数量时，被调用</span></span><br><span class="line"><span class="keyword">case</span> &lt;-closeCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/nsqd.go</span></span><br></pre></td></tr></table></figure><p>为了更好的理解消息的流动，小结一下，生产者投递消息到指定<code>topic</code>后，消息进入了<code>topic</code>维护的消息队列(<code>memoryMsgChan</code>和<code>backend</code>)，而在启动<code>nsqd</code>时，会异步开启一个消息处理循环即<code>queueScanLoop</code>，它包含两个计时任务，其中一个是，定时调整已经正在运行的<code>queueScanWorker</code>数量，其中<code>queueScanWorker</code>的任务为查看两个优先级队列中是否存在需要被处理的消息，若存在，则标记对应的<code>channel</code>为<code>dirty channel</code>。另一个计时任务是，定时抽取一定数量的<code>channel</code>，查看其中为<code>dirty channel</code>的比例（由<code>queueScanWorker</code>完成），若达到一定比例，则继续执行抽取<code>channel</code>的动作，如此反复。</p><p>好，到目前为止，<code>nsq</code>内部的消息处理逻辑已经阐述完毕。这对于理解整个<code>nsq</code>实时消息队列的关键原理至关重要。下面阐述几个典型的命令请求的核心实现逻辑。</p><h2 id="生产者消息发布消息"><a href="#生产者消息发布消息" class="headerlink" title="生产者消息发布消息"></a>生产者消息发布消息</h2><p>考虑到<code>nsq</code>为生产者提供了<code>http/tcp</code>两种方式来发布消息。因此，笔者以<code>tcp</code>的命令请求处理器为示例来阐述其核心处理逻辑（<code>http</code>的方式也类似）。当生产者通过<code>go-nsq</code>库以<code>tcp</code>的方式发送消息发布请求命令给指定<code>topic</code>时，请求首先从<code>protocolV2.IOLoop</code>中被读取，然后其调用<code>protocolV2.Exec</code>方法根据命令请求的类型调用相应的处理方法，此为<code>PUB</code>命令，因此调用<code>protocolV2.PUB</code>方法处理。处理过程比较简单，首先解析请求，取出<code>topic</code>名称，然后执行权限检查，检查通过后，便依据<code>topic</code>名称获取此<code>topic</code>实例，然后，构建一条消息，并调用<code>topic.PutMessage</code>方法发布消息，最后，调用<code>cleint.PublishedMessage</code>方法更新一些信息，并返回<code>ok</code>。整个流程比较简单，因为关键的处理逻辑在前文介绍过了，读者需要把它们串联起来。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端在指定的 topic 上发布消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">PUB</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(params) &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span></span><br><span class="line">                             , <span class="string">"PUB insufficient number of parameters"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 读取 topic 名称</span></span><br><span class="line">topicName := <span class="keyword">string</span>(params[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> !protocol.IsValidTopicName(topicName) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_BAD_TOPIC"</span>,</span><br><span class="line">fmt.Sprintf(<span class="string">"PUB topic name %q is not valid"</span>, topicName))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 读取消息体长度 bodyLen，并在长度上进行校验</span></span><br><span class="line">bodyLen, err := readLen(client.Reader, client.lenSlice)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(err, </span><br><span class="line">                            <span class="string">"E_BAD_MESSAGE"</span>, <span class="string">"PUB failed to read message body size"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> bodyLen &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_BAD_MESSAGE"</span>,</span><br><span class="line">fmt.Sprintf(<span class="string">"PUB invalid message body size %d"</span>, bodyLen))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int64</span>(bodyLen) &gt; p.ctx.nsqd.getOpts().MaxMsgSize &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_BAD_MESSAGE"</span>,</span><br><span class="line">fmt.Sprintf(<span class="string">"PUB message too big %d &gt; %d"</span>, bodyLen, p.ctx.nsqd.getOpts().MaxMsgSize))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 读取指定字节长度的消息内容到 messageBody</span></span><br><span class="line">messageBody := <span class="built_in">make</span>([]<span class="keyword">byte</span>, bodyLen)</span><br><span class="line">_, err = io.ReadFull(client.Reader, messageBody)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 4. 检查客户端是否具备 PUB 此 topic 命令的权限</span></span><br><span class="line"><span class="keyword">if</span> err := p.CheckAuth(client, <span class="string">"PUB"</span>, topicName, <span class="string">""</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 获取 topic 实例</span></span><br><span class="line">topic := p.ctx.nsqd.GetTopic(topicName)</span><br><span class="line"><span class="comment">// 6. 构造一条 message，并将此 message 投递到此 topic 的消息队列中</span></span><br><span class="line">msg := NewMessage(topic.GenerateID(), messageBody)</span><br><span class="line">err = topic.PutMessage(msg)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 7. 开始发布此消息，即将对应的 client 修改为此 topic 保存的消息的计数。</span></span><br><span class="line">client.PublishedMessage(topicName, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 回复 Ok</span></span><br><span class="line"><span class="keyword">return</span> okBytes, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/protocol_v2.go</span></span><br></pre></td></tr></table></figure><p>生产者除了可以发送<code>PUB</code>命令外，类似地，还有命令请求<code>MPUB</code>来一次性发布多条消息，<code>DPUB</code>用于发布延时投递的消息等等，逻辑都比较简单，不多阐述。下面介绍消费者处理消息的相关流程。</p><h2 id="消费者处理消息"><a href="#消费者处理消息" class="headerlink" title="消费者处理消息"></a>消费者处理消息</h2><p>消费者处理消息的流程包括，消费者发送<code>SUB</code>命令请求以订阅<code>channel</code>，消费者发送<code>RDY</code>命令请求以通知服务端自的消息处理能力，消费者发送<code>FIN</code>消息表示消息已经处理完成，最后还有个消费者发送<code>REQ</code>消息请求服务端重新将消息入队。下面依次分析这些命令请求的核心实现。</p><h3 id="消费者订阅消息"><a href="#消费者订阅消息" class="headerlink" title="消费者订阅消息"></a>消费者订阅消息</h3><p>当消费者通过<code>tcp</code>发送订阅消息的请求时，请求同样是首先从<code>protocolV2.IOLoop</code>方法中被接收，然后交由<code>Exec</code>方法处理。最后进入到<code>SUB</code>方法的流程，它首先执行必要的请求校验工作，其中容易被忽略的一点是，只有当<code>client</code>处于<code>stateInit</code>状态才能订阅某个<code>topic</code>的<code>channel</code>，换言之，当一个<code>client</code>订阅了某个<code>channel</code>后，它的状态会被更新为<code>stateSubscribed</code>，因此不能再订阅其它<code>channel</code>了。总而言之，<strong>一个 <code>client</code>同一时间只能订阅一个<code>channel</code></strong>。之后，获取并校验订阅的<code>topic</code>名称、<code>channel</code>名称，然后，客户端是否有订阅的权限，权限检查通过后，通过<code>topic</code>和<code>channel</code>名称获取对应的实例，并将此<code>client</code>实例添加到其订阅的<code>channel</code>的客户端集合中。最后，也是最关键的步骤是，它将订阅的<code>channel</code>实例传递给了<code>client</code>，同时将<code>channel</code>发送到了<code>client.SubEventChan</code>管道中，因此在<code>protocolV2.messagePump</code>方法中就能够根据，此客户端可以利用<code>channel.memoryMsgChan</code>和<code>channel.backend</code>来获取<code>channel</code>实例从<code>topic</code>实例接收到的消息，具体过程可以参考<a href="https://qqzeng.top/2019/05/13/nsq-nsqd-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%A4%84%E7%90%86" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端在指定的 topic 上订阅消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">SUB</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 做一些校验工作，只有当 client 处于 stateInit 状态才能订阅某个 topic 的 channel</span></span><br><span class="line"><span class="comment">// 换言之，当一个 client 订阅了某个 channel 之后，</span></span><br><span class="line">    <span class="comment">// 它的状态会被更新为 stateSubscribed，因此不能再订阅 channel 了。</span></span><br><span class="line"><span class="comment">// 总而言之，一个 client 只能订阅一个 channel</span></span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt32(&amp;client.State) != stateInit &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, <span class="string">"cannot SUB in current state"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> client.HeartbeatInterval &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, <span class="string">"cannot SUB with heartbeats disabled"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(params) &lt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, <span class="string">"SUB insufficient number of parameters"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 获取订阅的 topic 名称、channel 名称，并对它们进行校验</span></span><br><span class="line">topicName := <span class="keyword">string</span>(params[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> !protocol.IsValidTopicName(topicName) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_BAD_TOPIC"</span>,</span><br><span class="line">fmt.Sprintf(<span class="string">"SUB topic name %q is not valid"</span>, topicName))</span><br><span class="line">&#125;</span><br><span class="line">channelName := <span class="keyword">string</span>(params[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> !protocol.IsValidChannelName(channelName) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_BAD_CHANNEL"</span>,</span><br><span class="line">fmt.Sprintf(<span class="string">"SUB channel name %q is not valid"</span>, channelName))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 同时检查此客户端是否有订阅的权限</span></span><br><span class="line"><span class="keyword">if</span> err := p.CheckAuth(client, <span class="string">"SUB"</span>, topicName, channelName); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此循环是为了避免 client 订阅到正在退出的 ephemeral 属性的 channel 或 topic</span></span><br><span class="line"><span class="keyword">var</span> channel *Channel</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 4. 获取 topic 及 channel 实例</span></span><br><span class="line">topic := p.ctx.nsqd.GetTopic(topicName)</span><br><span class="line">channel = topic.GetChannel(channelName)</span><br><span class="line"><span class="comment">// 5. 调用 channel的 AddClient 方法添加指定客户端</span></span><br><span class="line"><span class="keyword">if</span> err := channel.AddClient(client.ID, client); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_TOO_MANY_CHANNEL_CONSUMERS"</span>,</span><br><span class="line">fmt.Sprintf(<span class="string">"channel consumers for %s:%s exceeds limit of %d"</span>,</span><br><span class="line">topicName, channelName, p.ctx.nsqd.getOpts().MaxChannelConsumers))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6. 若此 channel 或 topic 为ephemeral，并且channel或topic正在退出，则移除此client</span></span><br><span class="line"><span class="keyword">if</span> (channel.ephemeral &amp;&amp; channel.Exiting()) || (topic.ephemeral &amp;&amp; topic.Exiting()) &#123;</span><br><span class="line">channel.RemoveClient(client.ID)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6. 修改客户端的状态为 stateSubscribed</span></span><br><span class="line">atomic.StoreInt32(&amp;client.State, stateSubscribed)</span><br><span class="line"><span class="comment">// 7. 这一步比较关键，将订阅的 channel 实例传递给了 client，</span></span><br><span class="line">    <span class="comment">// 同时将 channel 发送到了 client.SubEventChan 通道中。</span></span><br><span class="line"><span class="comment">// 后面的 SubEventChan 就会使得当前的 client 在一个 goroutine 中订阅这个 channel 的消息</span></span><br><span class="line">client.Channel = channel</span><br><span class="line"><span class="comment">// update message pump</span></span><br><span class="line"><span class="comment">// 8. 通知后台订阅协程来订阅消息,包括内存管道和磁盘</span></span><br><span class="line">client.SubEventChan &lt;- channel</span><br><span class="line"><span class="comment">// 9. 返回 ok</span></span><br><span class="line"><span class="keyword">return</span> okBytes, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/protocol_v2.go</span></span><br></pre></td></tr></table></figure><h3 id="消费者发送-RDY-命令"><a href="#消费者发送-RDY-命令" class="headerlink" title="消费者发送 RDY 命令"></a>消费者发送 RDY 命令</h3><p>在消费者未发送<code>RDY</code>命令给服务端之前，服务端不会推送消息给客户端，因为此时服务端认为消费者还未准备好接收消息（由方法<code>client.IsReadyForMessages</code>实现）。另外，此<code>RDY</code>命令的含义，简而言之，当<code>RDY 100</code>即表示客户端具备一次性接收并处理100个消息的能力，因此服务端此时更可推送100条消息给消费者（如果有的话），每推送一条消息，就要修改<code>client.ReadyCount</code>的值。而<code>RDY</code>命令请求的处理非常简单，即通过<code>client.SetReadyCount</code>方法直接设置<code>client.ReadyCount</code>的值。注意在这之前的两个状态检查动作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者发送 RDY 命令请求表示服务端可以开始推送指定数目的消息了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">RDY</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">state := atomic.LoadInt32(&amp;client.State)</span><br><span class="line"><span class="keyword">if</span> state == stateClosing &#123;</span><br><span class="line"><span class="comment">// just ignore ready changes on a closing channel</span></span><br><span class="line">p.ctx.nsqd.logf(LOG_INFO,</span><br><span class="line"><span class="string">"PROTOCOL(V2): [%s] ignoring RDY after CLS in state ClientStateV2Closing"</span>,</span><br><span class="line">client)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> state != stateSubscribed &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, </span><br><span class="line">                                               <span class="string">"cannot RDY in current state"</span>)</span><br><span class="line">&#125;</span><br><span class="line">count := <span class="keyword">int64</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(params) &gt; <span class="number">1</span> &#123;</span><br><span class="line">b10, err := protocol.ByteToBase10(params[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(err, <span class="string">"E_INVALID"</span>,</span><br><span class="line">fmt.Sprintf(<span class="string">"RDY could not parse count %s"</span>, params[<span class="number">1</span>]))</span><br><span class="line">&#125;</span><br><span class="line">count = <span class="keyword">int64</span>(b10)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count &lt; <span class="number">0</span> || count &gt; p.ctx.nsqd.getOpts().MaxRdyCount &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>,</span><br><span class="line">fmt.Sprintf(<span class="string">"RDY count %d out of range 0-%d"</span>, count,</span><br><span class="line">                        p.ctx.nsqd.getOpts().MaxRdyCount))</span><br><span class="line">&#125;</span><br><span class="line">client.SetReadyCount(count)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/protocol_v2.go</span></span><br></pre></td></tr></table></figure><h3 id="消费者发送-FIN-命令"><a href="#消费者发送-FIN-命令" class="headerlink" title="消费者发送 FIN 命令"></a>消费者发送 FIN 命令</h3><p>当消费者将<code>channel</code>发送的消息消费完毕后，会显式向<code>nsq</code>发送<code>FIN</code>命令（类似于<code>ACK</code>）。当服务端收到此命令后，就可将消息从消息队列中删除。<code>FIN</code>方法首先调用<code>client.Channel.FinishMessage</code>方法将消息从<code>channel</code>的两个集合<code>in-flight queue</code>队列及<code>inFlightMessages</code> 字典中移除。然后调用<code>client.FinishedMessage</code>更新<code>client</code>的维护的消息消费的统计信息。相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者 client 收到消息后，会向 nsqd　响应　FIN+msgID　通知服务器成功投递消息，可以清空消息了'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">FIN</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 正式处理　FIN　请求前，对 client 及 请求参数属性信息进行校验</span></span><br><span class="line">state := atomic.LoadInt32(&amp;client.State)</span><br><span class="line"><span class="keyword">if</span> state != stateSubscribed &amp;&amp; state != stateClosing &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, <span class="string">"cannot FIN in current state"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(params) &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, <span class="string">"FIN insufficient number of params"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 获取 msgID</span></span><br><span class="line">id, err := getMessageID(params[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 3. client 调用 channel.FinishMessage 方法，</span></span><br><span class="line">    <span class="comment">// 即将消息从 channel 的 in-flight queue 及 inFlightMessages 字典中移除</span></span><br><span class="line">err = client.Channel.FinishMessage(client.ID, *id)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 4. 更新 client 维护的消息消费的统计信息</span></span><br><span class="line">client.FinishedMessage()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/protocol_v2.go</span></span><br></pre></td></tr></table></figure><h3 id="消费者发送-REQ-命令"><a href="#消费者发送-REQ-命令" class="headerlink" title="消费者发送 REQ 命令"></a>消费者发送 REQ 命令</h3><p>消费者可以通过向服务端发送<code>REQ</code>命令以将消息重新入队，即让服务端一定时间后（也可能是立刻）将消息重新发送给<code>channel</code>关联的客户端。此方法的核心是<code>client.Channel.RequeueMessage</code>，它会先将消息从<code>in-flight queue</code>优先级队列中移除，然后根据客户端是否需要延时<code>timeout</code>发送，分别将消息压入<code>channel</code>的消息队列(<code>memoryMsgChan</code>或<code>backend</code>)，或者构建一个延时消息，并将其压入到<code>deferred queue</code>。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nsqd 为此 client 将 message 重新入队，并指定是否需要延时发送</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">REQ</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 先检验 client 的状态以及参数信息</span></span><br><span class="line">state := atomic.LoadInt32(&amp;client.State)</span><br><span class="line"><span class="keyword">if</span> state != stateSubscribed &amp;&amp; state != stateClosing &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, <span class="string">"cannot REQ in current state"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(params) &lt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, <span class="string">"REQ insufficient number of params"</span>)</span><br><span class="line">&#125;</span><br><span class="line">id, err := getMessageID(params[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 从请求中取出重入队的消息被延迟的时间，</span></span><br><span class="line">    <span class="comment">// 并转化单位，同时限制其不能超过最大的延迟时间 maxReqTimeout</span></span><br><span class="line">timeoutMs, err := protocol.ByteToBase10(params[<span class="number">2</span>])</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">timeoutDuration := time.Duration(timeoutMs) * time.Millisecond</span><br><span class="line">maxReqTimeout := p.ctx.nsqd.getOpts().MaxReqTimeout</span><br><span class="line">clampedTimeout := timeoutDuration</span><br><span class="line"><span class="keyword">if</span> timeoutDuration &lt; <span class="number">0</span> &#123;</span><br><span class="line">clampedTimeout = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> timeoutDuration &gt; maxReqTimeout &#123;</span><br><span class="line">clampedTimeout = maxReqTimeout</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 3. 调用 channel.RequeueMessage 将消息重新入队。首先会将其从 in-flight queue 中删除，</span></span><br><span class="line"><span class="comment">// 然后依据其 timeout 而定，若其为0,则直接将其添加到消息队列中，</span></span><br><span class="line"><span class="comment">// 否则，若其 timeout 不为0,则构建一个 deferred message，</span></span><br><span class="line">    <span class="comment">// 并设置好延迟时间为 timeout，并将其添加到 deferred queue 中</span></span><br><span class="line">err = client.Channel.RequeueMessage(client.ID, *id, timeoutDuration)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 4. 更新 client 保存的关于消息的统计计数</span></span><br><span class="line">client.RequeuedMessage()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/protocol_v2.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将消息重新入队。这与 timeout 参数密切相关。</span></span><br><span class="line"><span class="comment">// 当 timeout == 0 时，直接将此消息重入队。</span></span><br><span class="line"><span class="comment">// 否则，异步等待此消息超时，然后 再将此消息重入队，即是相当于消息被延迟了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">RequeueMessage</span><span class="params">(clientID <span class="keyword">int64</span>, id MessageID, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 先将消息从 inFlightMessages 移除</span></span><br><span class="line">msg, err := c.popInFlightMessage(clientID, id)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 同时将消息从 in-flight queue 中移除，并更新 chanel 维护的消息重入队数量 requeueCount</span></span><br><span class="line">c.removeFromInFlightPQ(msg)</span><br><span class="line">atomic.AddUint64(&amp;c.requeueCount, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 3. 若 timeout 为0,则将消息重新入队。即调用 channel.put 方法，</span></span><br><span class="line">    <span class="comment">// 将消息添加到 memoryMsgChan 或 backend</span></span><br><span class="line"><span class="keyword">if</span> timeout == <span class="number">0</span> &#123;</span><br><span class="line">c.exitMutex.RLock()</span><br><span class="line"><span class="keyword">if</span> c.Exiting() &#123;</span><br><span class="line">c.exitMutex.RUnlock()</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br><span class="line">err := c.put(msg)</span><br><span class="line">c.exitMutex.RUnlock()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则，创建一个延迟消息，并设置延迟时间</span></span><br><span class="line"><span class="keyword">return</span> c.StartDeferredTimeout(msg, timeout)</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br></pre></td></tr></table></figure><p>至此，关于客户端的消息处理相关的命令请求已经阐述完毕，其实还有一些，比如<code>TOUCH</code>命令请求，即重置消息的超时时间。但这些处理过程都比较简单，只是对前面两小节的逻辑进行封装调用。</p><p>简单小结，本文的重点在两个方面：<code>topic</code>消息处理逻辑，即消息是如何从<code>topic</code>实例流向<code>channel</code>实例的，实际上就是将从<code>topic.memoryMsgChan</code>或<code>topic.backend</code>收到的消息的副本依次压入到其关联的<code>channel</code>的<code>in-flight queue</code>（对于正常的消息）或者<code>deferred queue</code>（对于延时消息）。另一个方面，<code>nsqd</code>消息处理处理逻辑，<code>nsqd</code>负责<code>in-flight queue</code>中的消息超时的处理工作，以及<code>deferred queue</code>中的消息延时时间已到的处理工作。另外，也阐述了一些有关客户端的命令请求的核心处理逻辑，包括生产者发布消息的流程，消费者订阅消息，以及发送<code>RDY/FIN/REQ</code>命令请求的实现逻辑。</p><p>至此，整个<code>nsq</code>实时消息队列的源码基本已经分析完毕，总共包括<a href="https://qqzeng.top/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">6篇文章</a>。这里简单总结：</p><ol><li><a href="https://qqzeng.top/2019/05/11/nsq-%E7%AE%80%E4%BB%8B%E5%92%8C%E7%89%B9%E6%80%A7%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">nsq 简介和特性理解</a>简要介绍<code>nsq</code>的各个组件及系统的核心工作流程，并重点阐述几个值得关注的特性；</li><li><a href="https://qqzeng.top/2019/05/12/nsq-nsqlookupd-%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/" target="_blank" rel="noopener">nsq nsqlookupd 源码简析</a>是以<code>nsqlookupd</code>命令为切入点，详细阐述<code>nsqlookupd</code>启动过程，其重点在于分析<code>nsqlookupd</code>的<code>tcp</code>请求处理器的相关逻辑，并梳理了<code>topic</code>查询和创建这两个典型的流程；</li><li><a href="https://qqzeng.top/2019/05/13/nsq-nsqd-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/" target="_blank" rel="noopener">nsq nsqd 服务启动源码简析</a>同样是以<code>nsqd</code>命令为切入点，行文逻辑同上一篇类似，即阐述<code>nsqd</code>服务启动的一系列流程，并详述<code>nsqd</code>与<code>nsqlookupd</code>交互的主循环逻辑，以及<code>nsqd</code>为客户端建立的<code>tcp</code>请求处理器；</li><li><a href="https://qqzeng.top/2019/05/14/nsq-topic-%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/" target="_blank" rel="noopener">nsq topic 源码简析</a>内容相对简单，以<code>topic</code>为核心，阐述<code>topic</code>实例结构组成以及<code>topic</code>实例的创建、删除、关闭和查询流程；</li><li><a href="https://qqzeng.top/2019/05/14/nsq-channel-%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/" target="_blank" rel="noopener">nsq channel 源码简析</a>文章的行文同上一篇文章类似，以<code>channel</code>为核心，阐述<code>channel</code>实例结构组成以及<code>channel</code>实例的创建、删除、关闭和查询流程，并附带分析了<code>Message</code>实例结构；</li><li><a href="https://qqzeng.top/2019/05/15/nsq-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E8%AE%A2%E9%98%85%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/" target="_blank" rel="noopener">nsq 消息发送订阅源码简析</a>，是这一系列文章中最重要的一篇，它对于理解<code>nsq</code>分布式实时消息消息队列的关键工作原理至关重要。它重点阐述<code>topic</code>实例如何将消息发送给它所关联的<code>channel</code>集合，以及<code>nsqd</code>实例如何处理消息处理超时和被延迟的消息处理。另外，简要分析了客户端执行的几条命令请求，如生产者发布消息流程和消费者订阅消息流程。</li></ol><p>完整的源码注释可以参考<a href="https://github.com/qqzeng/nsqio/tree/master/nsq" target="_blank" rel="noopener">这里</a>。考虑到个人能力有限，因此无论文章内容或源码注释存在错误，欢迎留言指正！</p><p>参考文献</p><p>[1]. <a href="https://github.com/nsqio/nsq" target="_blank" rel="noopener">https://github.com/nsqio/nsq</a><br>[2]. <a href="https://nsq.io/overview/quick_start.html" target="_blank" rel="noopener">https://nsq.io/overview/quick_start.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章阐述了&lt;code&gt;channel&lt;/code&gt;模块的源码。以&lt;code&gt;channel&lt;/code&gt;为核心分析&lt;code&gt;channel&lt;/code&gt;结构组件、&lt;code&gt;channel&lt;/code&gt;实例的创建、删除以及查找这四方面的源码逻辑，另外也简要分析了&lt;code&gt;Message&lt;/code&gt;结构的字段，以及两个与消息发送相关的优先级队列&lt;code&gt;in-flight queue&lt;/code&gt;和&lt;code&gt;deferred queue&lt;/code&gt;。同时也将对应方法与其它方法进行串联分析，以在整体上把握程序逻辑。本文的主题是&lt;code&gt;nsq&lt;/code&gt;消息队列系统中消息的发送和订阅相关源码的逻辑。本文的核心是阐述，当生产者将消息投递到某个&lt;code&gt;nsqd&lt;/code&gt;实例上对应的&lt;code&gt;topic&lt;/code&gt;时，消息是如何在&lt;code&gt;nsqd&lt;/code&gt;内部各组件（包括&lt;code&gt;nsqd&lt;/code&gt;、&lt;code&gt;topic&lt;/code&gt;和&lt;code&gt;chanel&lt;/code&gt;）之间流动的，并且分析&lt;code&gt;nsq&lt;/code&gt;是如何处理延时消息的投递。另外，结合网络传输模块的源码，分析两个典型的过程：生产者发布消息的逻辑，以及消费者是订阅并获取消息的逻辑。此篇文章内容较前两篇复杂，它是&lt;code&gt;nsq&lt;/code&gt;实时消息队列的核心部分，对理解&lt;code&gt;nsq&lt;/code&gt;的关键工作原理至关重要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="消息队列" scheme="http://geoffen.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="分布式系统" scheme="http://geoffen.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="消息队列" scheme="http://geoffen.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>nsq channel 源码简析</title>
    <link href="http://geoffen.github.io/2019/05/14/nsq-channel-%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    <id>http://geoffen.github.io/2019/05/14/nsq-channel-源码简析/</id>
    <published>2019-05-14T11:37:53.000Z</published>
    <updated>2019-11-07T10:24:47.401Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章阐述了<code>topic</code>模块的源码。即以<code>topic</code>为核心分析<code>topic</code>结构组件、<code>topic</code>实例的创建、删除以及查找这四方面的源码逻辑。同时也将这些方法放到一个完整的请求调用链中串联分析，以在整体上把握程序逻辑。本文的主题是<code>channel</code>（注意不要与<code>go channel</code>混淆）。<code>channel</code>可以视为发送消息的队列，它更贴近于消费者端，一旦<code>topic</code>实例从生产者那里收到一条消息，它会将这条消息复制并发送到每一个与它关联的<code>channel</code>，然后由<code>channel</code>将此消息随机发送到一个订阅了此<code>channel</code>的客户端。<code>channel</code>实例存储消息涉及到两个消息队列：内存消息队列和持久化消息队列。另外，<code>channel</code>还维护两个和消息发送相关的优先级队列：正在发送的消息队列和被推迟发送的消息队列。同样，本文只论述<code>channel</code>本身的相关逻辑，不涉及<code>channel</code>收发消息的逻辑。</p><a id="more"></a><p>本文分析<code>nsq channel</code>模块的源码，更详细<code>nsq</code>源码注释可在<a href="https://github.com/qqzeng/nsqio/tree/master/nsq" target="_blank" rel="noopener">这里</a>找到，注释源码版本为<code>v1.1.0</code>，仅供参考。本文所涉及到源码主要为<code>/nsq/nsqd/</code>和<code>/nsq/internal/</code>下的若干子目录。</p><p>同上一篇分析<code>topic</code>的源码类似，本文侧重于分析<code>channel</code>模块本身相关源码，而关于<code>channel</code>如何接收<code>topic</code>发送的消息、又如何对消息进行存储管理，最后又如何将消息推送给客户端，这部分会另外写一篇文章专门阐述。本文从五个方面来阐述<code>channel</code>：其一，简要介绍<code>channel</code>结构字段的组成；其二，由于<code>channel</code>同<code>message</code>密切相关，因此，也会分析<code>message</code>相关的字段，以及<code>chanel</code>维护的两个和消息发送相关的优先级队列。其三，阐述创建<code>channel</code>相关逻辑；其四，分析删除<code>channel</code>的过程；最后阐述<code>chanel</code>的查询过程。显然，本文分析<code>channel</code>的模式大体上同上一篇文章分析<code>topic</code>的模式相同，因此笔者会尽量精简介绍。</p><h2 id="channel-实例结构"><a href="#channel-实例结构" class="headerlink" title="channel 实例结构"></a>channel 实例结构</h2><p>相比<code>topic</code>结构，<code>channel</code>结构所包含的字段稍复杂些，重要的有：<code>topicName</code>代表<code>channel</code>实例所隶属的<code>topic</code>实例的名称；两个消息队列实例：<code>backend</code>表示<code>channel</code>使用的消息持久化队列接口，<code>memoryMsgChan</code>则表示内存消息队列；<code>clients</code>表示订阅此<code>channel</code>的客户端实例集合；<code>ephemeral</code>字段表示<code>channel</code>是否是临时的，临时的<code>channel</code>（<code>#ephemeral</code>开头）同样不会被持久化(<code>PersistMetadata</code>)，且当<code>channel</code> 关联的所有客户端都被移除后，此<code>channel</code>也会被删除（同临时的<code>topic</code>含义类似）。最后还有两个和消息发送相关的优先级队列：<code>deferredPQ</code>代表被延迟发送的消息集合，它是一个最小堆优先级队列，其中优先级比较字段为消息发送时间(<code>Item.Priority</code>)。<code>inFlightPQ</code>代表正在发送的消息集合，同样是最小堆优先级队列，优先级比较字段也为消息发送时间(<code>Message.pri</code>)。相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Channel <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 64bit atomic vars need to be first for proper alignment on 32bit platforms</span></span><br><span class="line">requeueCount <span class="keyword">uint64</span><span class="comment">// 需要重新排队的消息数</span></span><br><span class="line">messageCount <span class="keyword">uint64</span><span class="comment">// 接收到的消息的总数</span></span><br><span class="line">timeoutCount <span class="keyword">uint64</span><span class="comment">// 正在发送的消息的数量</span></span><br><span class="line"></span><br><span class="line">sync.RWMutex<span class="comment">// guards</span></span><br><span class="line"></span><br><span class="line">topicName <span class="keyword">string</span><span class="comment">// 其所对应的 topic 名称</span></span><br><span class="line">name      <span class="keyword">string</span><span class="comment">// channel 名称</span></span><br><span class="line">ctx       *context<span class="comment">// nsqd 实例</span></span><br><span class="line">backend BackendQueue<span class="comment">// 后端消息持久化的队列</span></span><br><span class="line"><span class="comment">// 内存消息通道。 其关联的 topic 会向此 channel 发送消息，</span></span><br><span class="line">    <span class="comment">// 且所有订阅的 client 会开启一个 go routine 订阅此 channel</span></span><br><span class="line">memoryMsgChan <span class="keyword">chan</span> *Message</span><br><span class="line">exitFlag      <span class="keyword">int32</span><span class="comment">// 退出标识（同 topic 的 exitFlag 作用类似）</span></span><br><span class="line">exitMutex     sync.RWMutex</span><br><span class="line"><span class="comment">// state tracking</span></span><br><span class="line">clients        <span class="keyword">map</span>[<span class="keyword">int64</span>]Consumer<span class="comment">// 与此 channel关联的client集合，即订阅的Consumer 集合</span></span><br><span class="line">paused         <span class="keyword">int32</span> <span class="comment">// 若paused属性被设置，则那些订阅了此channel的客户端不会被推送消息</span></span><br><span class="line">ephemeral      <span class="keyword">bool</span><span class="comment">// 标记此 channel 是否是临时的</span></span><br><span class="line">deleteCallback <span class="function"><span class="keyword">func</span><span class="params">(*Channel)</span>// 删除回调函数（同 <span class="title">topic</span> 的 <span class="title">deleteCallback</span> 作用类似）</span></span><br><span class="line"><span class="function"><span class="title">deleter</span>        <span class="title">sync</span>.<span class="title">Once</span></span></span><br><span class="line"><span class="function">// <span class="title">Stats</span> <span class="title">tracking</span></span></span><br><span class="line"><span class="function"><span class="title">e2eProcessingLatencyStream</span> *<span class="title">quantile</span>.<span class="title">Quantile</span></span></span><br><span class="line"><span class="function">// 延迟投递消息集合，消息体会放入 <span class="title">deferredPQ</span>，并且由后台的<span class="title">queueScanLoop</span>协程来扫描消息</span></span><br><span class="line"><span class="function">// 将过期的消息照常使用 <span class="title">c</span>.<span class="title">put</span><span class="params">(msg)</span> 发送出去。</span></span><br><span class="line"><span class="function"><span class="title">deferredMessages</span> <span class="title">map</span>[<span class="title">MessageID</span>]*<span class="title">pqueue</span>.<span class="title">Item</span></span></span><br><span class="line"><span class="function"><span class="title">deferredPQ</span>       <span class="title">pqueue</span>.<span class="title">PriorityQueue</span>// 被延迟投递消息集合对应的 <span class="title">PriorityQueue</span></span></span><br><span class="line"><span class="function"><span class="title">deferredMutex</span>    <span class="title">sync</span>.<span class="title">Mutex</span>// <span class="title">guards</span> <span class="title">deferredMessages</span></span></span><br><span class="line"><span class="function">// 正在发送中的消息记录集合，直到收到客户端的 <span class="title">FIN</span> 才删除，否则一旦超过 <span class="title">timeout</span>，则重传消息。</span></span><br><span class="line"><span class="function">// （因此<span class="title">client</span>需要对消息做去重处理 <span class="title">de</span>-<span class="title">duplicate</span>）</span></span><br><span class="line"><span class="function"><span class="title">inFlightMessages</span> <span class="title">map</span>[<span class="title">MessageID</span>]*<span class="title">Message</span></span></span><br><span class="line"><span class="function"><span class="title">inFlightPQ</span>       <span class="title">inFlightPqueue</span>// 正在发送中的消息记录集合 对应的 <span class="title">inFlightPqueue</span></span></span><br><span class="line"><span class="function"><span class="title">inFlightMutex</span>    <span class="title">sync</span>.<span class="title">Mutex</span>// <span class="title">guards</span> <span class="title">inFlightMessages</span></span></span><br><span class="line"><span class="function">&#125; // /<span class="title">nsq</span>/<span class="title">nsqd</span>/<span class="title">channel</span>.<span class="title">go</span></span></span><br></pre></td></tr></table></figure><h2 id="Message-实例结构"><a href="#Message-实例结构" class="headerlink" title="Message 实例结构"></a>Message 实例结构</h2><p><code>Message</code>代表生产者生产或消费者消费的一条消息。它是<code>nsq</code>消息队列系统中最基本的元素。<code>Message</code>结构包含的重要字段有：<code>Attempts</code>表示消息已经重复发送的次数（一旦消息投递次数过多，客户端可针对性地做处理）；<code>deliveryTS</code>表示<code>channel</code>向<code>client</code>发送消息时刻的时间戳；<code>clientID</code>表示消息被投递的目的客户端标识；<code>pri</code>表示消息优先级（即为消息被处理的<code>deadline</code>）；<code>deferred</code>为消息被延迟的时间（若消息确实被延迟了）。另外，网络传输的消息包格式构成为：<code>Timestamp</code>(<code>8byte</code>) + <code>Attempts</code>(<code>2byte</code>) + <code>MessageID</code>(<code>16byte</code>) + <code>MessageBody</code>(<code>N-byte</code>)。具体可参考相关源码，<code>Message</code>相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表逻辑消息实体结构</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        MessageID<span class="comment">// 消息 ID</span></span><br><span class="line">Body      []<span class="keyword">byte</span><span class="comment">// 消息体</span></span><br><span class="line">Timestamp <span class="keyword">int64</span><span class="comment">// 当前时间戳</span></span><br><span class="line">Attempts  <span class="keyword">uint16</span><span class="comment">// 消息重复投递次数</span></span><br><span class="line"><span class="comment">// for in-flight handling</span></span><br><span class="line">deliveryTS time.Time<span class="comment">// 投递消息的时间戳</span></span><br><span class="line">clientID   <span class="keyword">int64</span><span class="comment">// 接收此消息的 client ID</span></span><br><span class="line">pri        <span class="keyword">int64</span><span class="comment">// 消息的优先级（即消息被处理的 deadline 时间戳）</span></span><br><span class="line">index      <span class="keyword">int</span><span class="comment">// 当前消息在 priority queue 中的索引</span></span><br><span class="line">deferred   time.Duration<span class="comment">// 若消息被延迟，则为延迟时间</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/message.go</span></span><br></pre></td></tr></table></figure><p>另外简要贴出两个消息发送优先级队列<code>inFlightPQ</code>和<code>deferredPQ</code>核心组成代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> inFlightPqueue []*Message</span><br><span class="line"><span class="comment">// 使用一个 heap 堆来存储所有的 message，</span></span><br><span class="line"><span class="comment">// 根据 Message.pri（即消息处理时间的 deadline 时间戳） 来组织成一个小顶堆</span></span><br><span class="line"><span class="comment">// 非线程安全，需要 caller 来保证线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInFlightPqueue</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">inFlightPqueue</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>(inFlightPqueue, <span class="number">0</span>, capacity)</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/in_flight_pqueue.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若堆顶元素的 pri 大于此时的 timestamp，则返回　nil, 及二者的差值</span></span><br><span class="line"><span class="comment">// 此种情况表示还未到处理超时时间，即 nsqd 还不需要将它重新加入发送队列。</span></span><br><span class="line"><span class="comment">// 否则返回堆顶元素, 0，表示堆顶元素已经被客户端处理超时了，需要重新加入发送队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *inFlightPqueue)</span> <span class="title">PeekAndShift</span><span class="params">(max <span class="keyword">int64</span>)</span> <span class="params">(*Message, <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*pq) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">x := (*pq)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> x.pri &gt; max &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, x.pri - max</span><br><span class="line">&#125;</span><br><span class="line">pq.Pop()</span><br><span class="line"><span class="keyword">return</span> x, <span class="number">0</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/in_flight_pqueue.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆优先级队列，其操作接口同 in_flight_queue （nsqd/in_flight_queue.go）类似</span></span><br><span class="line"><span class="comment">// 不同的是它借用了标准库 container/heap/heap.go</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">Value    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Priority <span class="keyword">int64</span></span><br><span class="line">Index    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">PriorityQueue</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>(PriorityQueue, <span class="number">0</span>, capacity)</span><br><span class="line">&#125; <span class="comment">// /nsq/internal/pqueue/pqueue.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">PeekAndShift</span><span class="params">(max <span class="keyword">int64</span>)</span> <span class="params">(*Item, <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pq.Len() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">item := (*pq)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> item.Priority &gt; max &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, item.Priority - max</span><br><span class="line">&#125;</span><br><span class="line">heap.Remove(pq, <span class="number">0</span>) <span class="comment">// Remove 方法中重新调整了堆的结构</span></span><br><span class="line"><span class="keyword">return</span> item, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-topic-实例"><a href="#创建-topic-实例" class="headerlink" title="创建 topic 实例"></a>创建 topic 实例</h2><p><code>channel</code>的构造方法同<code>topic</code>的构造方法所涉及的逻辑非常相似，只不过<code>channel</code>还初始化了前面阐述的两个用于存储发送消息的优先级队列<code>inFlightPQ</code>和<code>deferredPQ</code>。因此就不再阐述，读者若需参考，可以看<a href="https://qqzeng.top/2019/05/14/nsq-topic-%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/#%E5%88%9B%E5%BB%BA-topic-%E5%AE%9E%E4%BE%8B" target="_blank" rel="noopener">这里</a>。注意，它同样会通过<code>nsqd.Notify</code>通知<code>nsqlookupd</code>有新的<code>channel</code>创建，因此需要重新调用<code>PersistMetadata</code>以持久化元数据。（方法调用链为：<code>NewChannel-&gt;nsqd.Notify-&gt;nsqd.lookupLoop-&gt;nsqd.PersistMetadata</code>）相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChannel</span><span class="params">(topicName <span class="keyword">string</span>, channelName <span class="keyword">string</span>, ctx *context,</span></span></span><br><span class="line"><span class="function"><span class="params">deleteCallback <span class="keyword">func</span>(*Channel)</span>) *<span class="title">Channel</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 初始化 channel 部分参数</span></span><br><span class="line">c := &amp;Channel&#123;</span><br><span class="line">topicName:      topicName,</span><br><span class="line">name:           channelName,</span><br><span class="line">memoryMsgChan:  <span class="built_in">make</span>(<span class="keyword">chan</span> *Message, ctx.nsqd.getOpts().MemQueueSize),</span><br><span class="line">clients:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]Consumer),</span><br><span class="line">deleteCallback: deleteCallback,</span><br><span class="line">ctx:            ctx,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ctx.nsqd.getOpts().E2EProcessingLatencyPercentiles) &gt; <span class="number">0</span> &#123;</span><br><span class="line">c.e2eProcessingLatencyStream = quantile.New(</span><br><span class="line">ctx.nsqd.getOpts().E2EProcessingLatencyWindowTime,</span><br><span class="line">ctx.nsqd.getOpts().E2EProcessingLatencyPercentiles,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 初始化 channel 维护的两个消息队列</span></span><br><span class="line">c.initPQ()</span><br><span class="line"><span class="comment">// 3. 同　topic　类似，那些 ephemeral 类型的 channel 不会关联到一个 BackendQueue，</span></span><br><span class="line">    <span class="comment">// 而只是被赋予了一个 dummy BackendQueue</span></span><br><span class="line"><span class="keyword">if</span> strings.HasSuffix(channelName, <span class="string">"#ephemeral"</span>) &#123;</span><br><span class="line">c.ephemeral = <span class="literal">true</span></span><br><span class="line">c.backend = newDummyBackendQueue()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dqLogf := <span class="function"><span class="keyword">func</span><span class="params">(level diskqueue.LogLevel, f <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">opts := ctx.nsqd.getOpts()</span><br><span class="line">lg.Logf(opts.Logger, opts.LogLevel, lg.LogLevel(level), f, args...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// backend names, for uniqueness, automatically include the topic...</span></span><br><span class="line"><span class="comment">// 4. 实例化一个后端持久化存储，同样是通过 go-diskqueue  来创建的，</span></span><br><span class="line">        <span class="comment">// 其初始化参数同 topic 中实例化 backendQueue 参数类似</span></span><br><span class="line">backendName := getBackendName(topicName, channelName)</span><br><span class="line">c.backend = diskqueue.New(</span><br><span class="line">backendName,</span><br><span class="line">ctx.nsqd.getOpts().DataPath,</span><br><span class="line">ctx.nsqd.getOpts().MaxBytesPerFile,</span><br><span class="line"><span class="keyword">int32</span>(minValidMsgLength),</span><br><span class="line"><span class="keyword">int32</span>(ctx.nsqd.getOpts().MaxMsgSize)+minValidMsgLength,</span><br><span class="line">ctx.nsqd.getOpts().SyncEvery,</span><br><span class="line">ctx.nsqd.getOpts().SyncTimeout,</span><br><span class="line">dqLogf,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 通知 lookupd 添加注册信息</span></span><br><span class="line">c.ctx.nsqd.Notify(c)</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br></pre></td></tr></table></figure><p>类似地，前文提过<code>channel</code>不会被预先创建，一般是因为某个消费者在订阅<code>channel</code>时才被创建的。同样，我们追踪方法调用，发现只有<code>topic.getOrCreateChannel</code>方法调用了<code>NewChannel</code>构造方法，而它又只会被<code>topic.GetChannel</code>方法调用。因此，程序中只存在三条调用链：其一，<code>nsqd.Start-&gt;nsqd.LoadMetadata-&gt;topic.GetChannel-&gt;topic.getOrCreateChannel-&gt;NewChannel</code>；其二，<code>httpServer.doCreateChannel-&gt;topic.GetChannel</code>；以及<code>protocolV2.SUB-&gt;topic.GetChannel</code>。</p><h2 id="删除或关闭-channel-实例"><a href="#删除或关闭-channel-实例" class="headerlink" title="删除或关闭 channel 实例"></a>删除或关闭 channel 实例</h2><p>删除(<code>Delete</code>)或者关闭(<code>Close</code>)<code>channel</code>实例的方法逻辑同<code>topic</code>也非常类似。相似部分不多阐述，读者若需要参考，可以看<a href="https://qqzeng.top/2019/05/14/nsq-topic-%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/#%E5%88%A0%E9%99%A4%E6%88%96%E5%85%B3%E9%97%AD-topic-%E5%AE%9E%E4%BE%8B" target="_blank" rel="noopener">这里</a>。这里重点阐述两个不同点：其一，无论是关闭还是删除<code>channel</code>都会显式地将订阅了此<code>channel</code>的客户端强制关闭（当然是关闭客户端在服务端的实体）；其二，关闭和删除<code>channel</code>都会显式刷新<code>channel</code>，即将<code>channel</code>所维护的三个消息队列：内存消息队列<code>memoryMsgChan</code>、正在发送的优先级消息队列<code>inFlightPQ</code>以及被推迟发送的优先级消息队列<code>deferredPQ</code>，将它们的消息显式写入到持久化存储消息队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除此 channel，清空所有消息，然后关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">Delete</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.exit(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只是将三个消息队列中的消息刷盘，然后关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.exit(<span class="literal">false</span>)</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">exit</span><span class="params">(deleted <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c.exitMutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.exitMutex.Unlock()</span><br><span class="line"><span class="comment">// 1. 保证还未被设置 exitFlag，即还在运行中，同时设置 exitFlag</span></span><br><span class="line"><span class="keyword">if</span> !atomic.CompareAndSwapInt32(&amp;c.exitFlag, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 若需要删除数据，则通知 nsqlookupd，有 channel 被删除</span></span><br><span class="line"><span class="keyword">if</span> deleted &#123;</span><br><span class="line">c.ctx.nsqd.logf(LOG_INFO, <span class="string">"CHANNEL(%s): deleting"</span>, c.name)</span><br><span class="line">c.ctx.nsqd.Notify(c)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.ctx.nsqd.logf(LOG_INFO, <span class="string">"CHANNEL(%s): closing"</span>, c.name)</span><br><span class="line">&#125;</span><br><span class="line">c.RLock()</span><br><span class="line"><span class="comment">// 3. 强制关闭所有订阅了此 channel 的客户端</span></span><br><span class="line"><span class="keyword">for</span> _, client := <span class="keyword">range</span> c.clients &#123;</span><br><span class="line">client.Close()</span><br><span class="line">&#125;</span><br><span class="line">c.RUnlock()</span><br><span class="line"><span class="comment">// 4. 清空此 channel 所维护的内存消息队列和持久化存储消息队列中的消息</span></span><br><span class="line"><span class="keyword">if</span> deleted &#123;</span><br><span class="line"><span class="comment">// empty the queue (deletes the backend files, too)</span></span><br><span class="line">c.Empty()</span><br><span class="line"><span class="comment">// 5. 删除持久化存储消息队列中的消息</span></span><br><span class="line"><span class="keyword">return</span> c.backend.Delete()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6. 强制将内存消息队列、以及两个发送消息优先级队列中的消息写到持久化存储中</span></span><br><span class="line">c.flush()</span><br><span class="line"><span class="comment">// 7. 关闭持久化存储消息队列</span></span><br><span class="line"><span class="keyword">return</span> c.backend.Close()</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 channel 的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.Unlock()</span><br><span class="line"><span class="comment">// 1. 重新初始化（清空） in-flight queue 及 deferred queue</span></span><br><span class="line">c.initPQ()</span><br><span class="line"><span class="comment">// 2. 清空由 channel 为客户端维护的一些信息，比如 当前正在发送的消息的数量 InFlightCount</span></span><br><span class="line"><span class="comment">// 同时更新了 ReadyStateChan</span></span><br><span class="line"><span class="keyword">for</span> _, client := <span class="keyword">range</span> c.clients &#123;</span><br><span class="line">client.Empty()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 将 memoryMsgChan 中的消息清空</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c.memoryMsgChan:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">goto</span> finish</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 最后将后端持久化存储中的消息清空</span></span><br><span class="line">finish:</span><br><span class="line"><span class="keyword">return</span> c.backend.Empty()</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将未消费的消息都写到持久化存储中，</span></span><br><span class="line"><span class="comment">// 主要包括三个消息集合：memoryMsgChan、inFlightMessages和deferredMessages</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">flush</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> msgBuf bytes.Buffer</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 1. 将内存消息队列中的积压的消息刷盘</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-c.memoryMsgChan:</span><br><span class="line">err := writeMessageToBackend(&amp;msgBuf, msg, c.backend)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">goto</span> finish</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 将还未发送出去的消息 inFlightMessages 也写到持久化存储</span></span><br><span class="line">finish:</span><br><span class="line">c.inFlightMutex.Lock()</span><br><span class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> c.inFlightMessages &#123;</span><br><span class="line">err := writeMessageToBackend(&amp;msgBuf, msg, c.backend)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">c.inFlightMutex.Unlock()</span><br><span class="line"><span class="comment">// 3. 将被推迟发送的消息集合中的 deferredMessages 消息也到持久化存储</span></span><br><span class="line">c.deferredMutex.Lock()</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> c.deferredMessages &#123;</span><br><span class="line">msg := item.Value.(*Message)</span><br><span class="line">err := writeMessageToBackend(&amp;msgBuf, msg, c.backend)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">c.deferredMutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/channel.go</span></span><br></pre></td></tr></table></figure><h2 id="查询-channel-实例"><a href="#查询-channel-实例" class="headerlink" title="查询 channel 实例"></a>查询 channel 实例</h2><p>同样是即依据名称查询（获取）<code>channel</code>实例，它被定义为<code>topic</code>实例的方法。查询逻辑的关键是，若此<code>channl</code>不在<code>topic</code>的<code>channel</code>集合中，则需要创建一个新的<code>channel</code>实例。并为其注册<code>channel</code>实例的删除回调函数。接下来，还要更新<code>topic.memoryMsgChan</code>和<code>topoc.backendChan</code>结构（因为<code>channel</code>集合更新了）。相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 channel 名称返回 channel 实例，且有可能是新建的。线程安全方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">GetChannel</span><span class="params">(channelName <span class="keyword">string</span>)</span> *<span class="title">Channel</span></span> &#123;</span><br><span class="line">t.Lock()</span><br><span class="line">channel, isNew := t.getOrCreateChannel(channelName)</span><br><span class="line">t.Unlock()</span><br><span class="line"><span class="keyword">if</span> isNew &#123;</span><br><span class="line"><span class="comment">// update messagePump state</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 若此 channel 为新创建的，则 push 消息到 channelUpdateChan中，</span></span><br><span class="line">            <span class="comment">// 使 memoryMsgChan 及 backend 刷新状态</span></span><br><span class="line"><span class="keyword">case</span> t.channelUpdateChan &lt;- <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> &lt;-t.exitChan:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> channel</span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/topic.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 channel 名称获取指定的 channel，若不存在，则创建一个新的 channel 实例。非线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">getOrCreateChannel</span><span class="params">(channelName <span class="keyword">string</span>)</span> <span class="params">(*Channel, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">channel, ok := t.channelMap[channelName]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// 注册 channel 被删除时的回调函数</span></span><br><span class="line">deleteCallback := <span class="function"><span class="keyword">func</span><span class="params">(c *Channel)</span></span> &#123;</span><br><span class="line">t.DeleteExistingChannel(c.name)</span><br><span class="line">&#125;</span><br><span class="line">channel = NewChannel(t.name, channelName, t.ctx, deleteCallback)</span><br><span class="line">t.channelMap[channelName] = channel</span><br><span class="line">t.ctx.nsqd.logf(LOG_INFO, <span class="string">"TOPIC(%s): new channel(%s)"</span>, t.name, channel.name)</span><br><span class="line"><span class="keyword">return</span> channel, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> channel, <span class="literal">false</span></span><br><span class="line">&#125; <span class="comment">// /nsq/nsqd/topic.go</span></span><br></pre></td></tr></table></figure><p>简单小结，本文内容同上一篇文章分析<code>topic</code>源码非常相似，因此阐述得比较简单，只是贴了注释的源码，并重点阐述二者不同。文章围绕<code>channel</code>展开，首先简要介绍<code>channel</code>结构字段的组成；然后，分析<code>message</code>相关的字段，以及<code>chanel</code>维护的两个和消息发送相关的优先级队列：<code>inFlightPQ</code>，存放正在发送的消息的优先级队列，以及<code>deferredPQ</code>，存放被推迟发送的消息的优先级队列。接下来，分析了<code>channel</code>实例化的逻辑以及<code>channel</code>删除逻辑；最后阐述<code>channel</code>的查询过程，查询过程需要注意的是通知<code>topic</code>的消息处理主循环<code>messagePump</code>更新两个消息队列实例。</p><p>参考文献</p><p>[1]. <a href="https://github.com/nsqio/nsq" target="_blank" rel="noopener">https://github.com/nsqio/nsq</a><br>[2]. <a href="https://nsq.io/overview/quick_start.html" target="_blank" rel="noopener">https://nsq.io/overview/quick_start.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章阐述了&lt;code&gt;topic&lt;/code&gt;模块的源码。即以&lt;code&gt;topic&lt;/code&gt;为核心分析&lt;code&gt;topic&lt;/code&gt;结构组件、&lt;code&gt;topic&lt;/code&gt;实例的创建、删除以及查找这四方面的源码逻辑。同时也将这些方法放到一个完整的请求调用链中串联分析，以在整体上把握程序逻辑。本文的主题是&lt;code&gt;channel&lt;/code&gt;（注意不要与&lt;code&gt;go channel&lt;/code&gt;混淆）。&lt;code&gt;channel&lt;/code&gt;可以视为发送消息的队列，它更贴近于消费者端，一旦&lt;code&gt;topic&lt;/code&gt;实例从生产者那里收到一条消息，它会将这条消息复制并发送到每一个与它关联的&lt;code&gt;channel&lt;/code&gt;，然后由&lt;code&gt;channel&lt;/code&gt;将此消息随机发送到一个订阅了此&lt;code&gt;channel&lt;/code&gt;的客户端。&lt;code&gt;channel&lt;/code&gt;实例存储消息涉及到两个消息队列：内存消息队列和持久化消息队列。另外，&lt;code&gt;channel&lt;/code&gt;还维护两个和消息发送相关的优先级队列：正在发送的消息队列和被推迟发送的消息队列。同样，本文只论述&lt;code&gt;channel&lt;/code&gt;本身的相关逻辑，不涉及&lt;code&gt;channel&lt;/code&gt;收发消息的逻辑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="消息队列" scheme="http://geoffen.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="分布式系统" scheme="http://geoffen.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="消息队列" scheme="http://geoffen.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
